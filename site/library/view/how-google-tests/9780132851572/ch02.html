<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage"" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/how-google-tests/9780132851572/ch02.html"
data-csrf-cookie="csrfsafari"
data-highlight-privacy=""


  data-user-id="859452"
  data-user-uuid="4d373bec-fada-4717-9823-769db3ed3a36"
  data-username="dchen267"
  data-account-type="B2B"
  
  data-activated-trial-date="04/25/2016"


  data-archive="9780132851572"
  data-publishers="Addison-Wesley Professional"



  data-htmlfile-name="ch02.html"
  data-epub-title="How Google Tests Software" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class=" js flexbox flexboxlegacy no-touch websqldatabase indexeddb history csscolumns csstransforms localstorage sessionstorage applicationcache svg inlinesvg zoom gr__safaribooksonline_com" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#" itemscope="" itemtype="http://schema.org/Book http://schema.org/ItemPage" "="" data-login-url="/accounts/login/" data-offline-url="/" data-url="/library/view/how-google-tests/9780132851572/ch02.html" data-csrf-cookie="csrfsafari" data-highlight-privacy="" data-user-id="859452" data-user-uuid="4d373bec-fada-4717-9823-769db3ed3a36" data-username="dchen267" data-account-type="B2B" data-activated-trial-date="04/25/2016" data-archive="9780132851572" data-publishers="Addison-Wesley Professional" data-htmlfile-name="ch02.html" data-epub-title="How Google Tests Software" data-debug="0" data-testing="0"><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="author" content="Safari Books Online"><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9780132851572"><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"><meta property="twitter:account_id" content="4503599627559754"><link rel="apple-touch-icon" href="https://www.safaribooksonline.com/static/images/apple-touch-icon.8cc2fd27400e.png"><link rel="shortcut icon" href="https://www.safaribooksonline.com/favicon.ico" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic" rel="stylesheet" type="text/css"><title>Chapter 2. The Software Engineer in Test - How Google Tests Software</title><link rel="stylesheet" href="https://www.safaribooksonline.com/static/CACHE/css/e4b0fef39b55.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://www.safaribooksonline.com/static/css/annotator.min.fd58f69f4908.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book">
    #sbo-rt-content div{margin-top:4pt;margin-bottom:4pt;margin-right:15pt}#sbo-rt-content .cover{margin-top:2pt;margin-bottom:2pt;text-align:center}#sbo-rt-content h1{margin-top:5pt;text-align:center;margin-bottom:12pt;font-weight:bold}#sbo-rt-content h2{margin-top:7pt;margin-bottom:25pt;font-weight:bold}#sbo-rt-content h3{margin-top:9pt;margin-bottom:8pt;font-weight:bold}#sbo-rt-content h4{margin-top:9pt;margin-bottom:6pt;font-weight:bold}#sbo-rt-content .h4a{margin-top:9pt;margin-left:13pt;margin-bottom:6pt;font-weight:bold}#sbo-rt-content h5{margin-top:9pt;margin-bottom:6pt;font-weight:bold}#sbo-rt-content .author{text-align:center;font-weight:bold;margin-top:60pt;margin-bottom:12pt}#sbo-rt-content .publisher{text-align:center;margin-top:210pt;margin-bottom:6pt}#sbo-rt-content .publishertext{text-align:center;margin-top:6pt;margin-bottom:6pt}#sbo-rt-content .copy{margin-top:5pt;margin-bottom:5pt;text-indent:.024pt}#sbo-rt-content .copy1{margin-top:5pt;margin-bottom:6pt;margin-left:13pt}#sbo-rt-content p{margin-top:5pt;margin-bottom:4pt;text-indent:.024pt}#sbo-rt-content .toc-preface{margin-top:12pt;margin-bottom:8pt;text-indent:.024pt}#sbo-rt-content .toc-chapter{margin-top:12pt;margin-bottom:6pt;text-indent:.024pt}#sbo-rt-content .toc-appendix{margin-top:12pt;margin-bottom:6pt;text-indent:.024pt}#sbo-rt-content .toc-section{margin-top:4pt;margin-bottom:4pt;margin-left:21pt}#sbo-rt-content .toc-section1{margin-top:4pt;margin-bottom:4pt;margin-left:50pt}#sbo-rt-content strong{font-weight:bold}#sbo-rt-content em{font-style:italic}#sbo-rt-content .em{font-family:"Courier New Italic";font-style:italic}#sbo-rt-content .strong{font-family:"Courier New Bold"}#sbo-rt-content code{font-size:small}#sbo-rt-content .dedication{margin-top:70pt;margin-bottom:4pt;margin-left:100pt}#sbo-rt-content .dedication1{margin-top:15pt;margin-bottom:4pt;margin-left:100pt}#sbo-rt-content div.image,#sbo-rt-content img{margin:0 auto;padding:0;text-align:center;max-width:99%;max-height:99%;clear:both}#sbo-rt-content .toc-index{margin-top:12pt;margin-bottom:6pt;text-indent:.024pt}#sbo-rt-content .blockquote{margin-top:8pt;margin-bottom:8pt;margin-left:17pt;margin-right:17pt}#sbo-rt-content .blockquote1{margin-top:4pt;margin-bottom:4pt;text-indent:.024pt}#sbo-rt-content .attribution{margin-top:4pt;margin-bottom:8pt;text-align:right;margin-right:70pt}#sbo-rt-content .attribution1{margin-top:1pt;margin-bottom:1pt;margin-left:100pt}#sbo-rt-content .note{font-size:medium;margin-top:9pt;margin-bottom:8pt;font-weight:bold;margin-left:20pt;page-break-inside:avoid;page-break-after:avoid}#sbo-rt-content .note1{font-size:medium;margin-top:6pt;margin-bottom:12pt;margin-left:36pt;margin-right:24pt;page-break-inside:avoid;background-color:#E6E6E6}#sbo-rt-content .note2{font-size:medium;margin-top:4pt;margin-bottom:4pt;margin-left:36pt;margin-right:24pt;page-break-inside:avoid}#sbo-rt-content .notepara{margin-top:5pt;margin-bottom:4pt;margin-left:30pt;margin-right:30pt}#sbo-rt-content .sidebar{font-size:medium;margin-top:9pt;margin-bottom:8pt;page-break-inside:avoid;page-break-after:avoid;font-weight:bold;margin-left:15pt}#sbo-rt-content .sidebar2{font-size:medium;margin-top:9pt;margin-bottom:8pt;page-break-inside:avoid;page-break-after:avoid;margin-left:15pt}#sbo-rt-content .sidebar1{font-size:medium;margin-top:5pt;margin-bottom:12pt;margin-left:15pt;background-color:#E6E6E6}#sbo-rt-content .sidebarpara{margin-top:5pt;margin-bottom:4pt;margin-left:25pt;margin-right:25pt}#sbo-rt-content .footnotes{margin-top:5pt;margin-bottom:4pt;font-size:small;text-indent:-7pt;margin-left:20pt}#sbo-rt-content .right{margin-top:5pt;margin-bottom:5pt;text-align:right;margin-right:70pt}#sbo-rt-content .right1{margin-top:5pt;margin-bottom:10pt;text-align:right;margin-right:35pt}#sbo-rt-content .caption{font-size:medium;page-break-before:avoid;page-break-inside:avoid;text-align:center}#sbo-rt-content .caption1{font-size:medium;page-break-after:avoid;page-break-inside:avoid;text-align:center}#sbo-rt-content .indenthanging{margin-top:4pt;margin-bottom:4pt;margin-left:30pt}#sbo-rt-content .indenthangingB{margin-top:4pt;margin-bottom:4pt;margin-left:43pt;text-indent:-8pt}#sbo-rt-content .indenthangingB1{margin-top:4pt;margin-bottom:4pt;margin-left:55pt;text-indent:-8pt}#sbo-rt-content .indenthangingB2{margin-top:4pt;margin-bottom:4pt;margin-left:52pt;text-indent:-12pt}#sbo-rt-content .indenthangingN{margin-top:4pt;margin-bottom:4pt;margin-left:25pt;text-indent:-12pt}#sbo-rt-content .indenthangingN2{margin-top:4pt;margin-bottom:4pt;margin-left:25pt;text-indent:-13pt}#sbo-rt-content .indenthangingN1{margin-top:4pt;margin-bottom:4pt;margin-left:48pt;text-indent:-10pt}#sbo-rt-content .indentparab{margin-top:4pt;margin-bottom:4pt;margin-left:43pt}#sbo-rt-content .programlisting{font-family:"Courier New";font-size:small;margin-top:5pt;margin-bottom:4pt}#sbo-rt-content .indexmain{margin-top:2pt;margin-bottom:2pt;text-indent:.024pt}#sbo-rt-content .indexsub{margin-top:2pt;margin-bottom:2pt;margin-left:15pt;text-indent:.024pt}#sbo-rt-content .indexsubsub{margin-top:2pt;margin-bottom:2pt;margin-left:31pt;text-indent:.024pt}
    </style><link rel="canonical" href="/safari-books-archive/site/library/view/how-google-tests/9780132851572/ch02.html"><meta name="description" content="Chapter 2. The Software Engineer in Test Imagine for a moment the perfect development process. It would begin with test. Before even a single line of code is written, a ... "><meta property="og:title" content="Chapter 2. The Software Engineer in Test"><meta itemprop="isPartOf" content="/library/view/how-google-tests/9780132851572/"><meta itemprop="name" content="Chapter 2. The Software Engineer in Test"><meta property="og:url" itemprop="url" content="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/ch02.html"><meta property="og:site_name" content="Safari"><meta property="og:image" itemprop="thumbnailUrl" content="https://www.safaribooksonline.com/library/cover/9780132851572/"><meta property="og:description" itemprop="description" content="Chapter 2. The Software Engineer in Test Imagine for a moment the perfect development process. It would begin with test. Before even a single line of code is written, a ... "><meta itemprop="inLanguage" content="en"><meta itemprop="publisher" content="Addison-Wesley Professional"><meta property="og:type" content="book"><meta property="og:book:isbn" itemprop="isbn" content="9780132851572"><meta property="og:book:author" itemprop="author" content="Jeff Carollo"><meta property="og:book:author" itemprop="author" content="Jason Arbon"><meta property="og:book:author" itemprop="author" content="James A. Whittaker"><meta property="og:book:tag" itemprop="about" content="Core Programming"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@safari"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><!--[if lt IE 9]><script src="/static/js/src/respond.min.cf5c9b7980e5.js"></script><![endif]--><style id="annotator-dynamic-style">.annotator-adder, .annotator-outer, .annotator-notice {
  z-index: 100019;
}
.annotator-filter {
  z-index: 100009;
}</style></head>


<body class="reading sidenav nav-collapsed  scalefonts library" data-gr-c-s-loaded="true">

    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        




<a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#container" class="skip">Skip to content</a><header class="topbar t-topbar" style="display:None"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li class="t-logo"><a href="https://www.safaribooksonline.com/home/" class="l0 None safari-home nav-icn js-keyboard-nav-home"><svg width="20" height="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" version="1.1" fill="#4A3C31"><desc>Safari Home Icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M4 9.9L4 9.9 4 18 16 18 16 9.9 10 4 4 9.9ZM2.6 8.1L2.6 8.1 8.7 1.9 10 0.5 11.3 1.9 17.4 8.1 18 8.7 18 9.5 18 18.1 18 20 16.1 20 3.9 20 2 20 2 18.1 2 9.5 2 8.7 2.6 8.1Z"></path><rect x="10" y="12" width="3" height="7"></rect><rect transform="translate(18.121320, 10.121320) rotate(-315.000000) translate(-18.121320, -10.121320) " x="16.1" y="9.1" width="4" height="2"></rect><rect transform="translate(2.121320, 10.121320) scale(-1, 1) rotate(-315.000000) translate(-2.121320, -10.121320) " x="0.1" y="9.1" width="4" height="2"></rect></g></svg><span>Safari Home</span></a></li><li><a href="https://www.safaribooksonline.com/r/" class="t-recommendations-nav l0 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>recommendations icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M50 25C50 18.2 44.9 12.5 38.3 11.7 37.5 5.1 31.8 0 25 0 18.2 0 12.5 5.1 11.7 11.7 5.1 12.5 0 18.2 0 25 0 31.8 5.1 37.5 11.7 38.3 12.5 44.9 18.2 50 25 50 31.8 50 37.5 44.9 38.3 38.3 44.9 37.5 50 31.8 50 25ZM25 3.1C29.7 3.1 33.6 6.9 34.4 11.8 30.4 12.4 26.9 15.1 25 18.8 23.1 15.1 19.6 12.4 15.6 11.8 16.4 6.9 20.3 3.1 25 3.1ZM34.4 15.6C33.6 19.3 30.7 22.2 27.1 22.9 27.8 19.2 30.7 16.3 34.4 15.6ZM22.9 22.9C19.2 22.2 16.3 19.3 15.6 15.6 19.3 16.3 22.2 19.2 22.9 22.9ZM3.1 25C3.1 20.3 6.9 16.4 11.8 15.6 12.4 19.6 15.1 23.1 18.8 25 15.1 26.9 12.4 30.4 11.8 34.4 6.9 33.6 3.1 29.7 3.1 25ZM22.9 27.1C22.2 30.7 19.3 33.6 15.6 34.4 16.3 30.7 19.2 27.8 22.9 27.1ZM25 46.9C20.3 46.9 16.4 43.1 15.6 38.2 19.6 37.6 23.1 34.9 25 31.3 26.9 34.9 30.4 37.6 34.4 38.2 33.6 43.1 29.7 46.9 25 46.9ZM27.1 27.1C30.7 27.8 33.6 30.7 34.4 34.4 30.7 33.6 27.8 30.7 27.1 27.1ZM38.2 34.4C37.6 30.4 34.9 26.9 31.3 25 34.9 23.1 37.6 19.6 38.2 15.6 43.1 16.4 46.9 20.3 46.9 25 46.9 29.7 43.1 33.6 38.2 34.4Z" fill="currentColor"></path></g></svg><span>Recommended</span></a></li><li><a href="https://www.safaribooksonline.com/s/" class="t-queue-nav l0 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>queue icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 29.2C25.4 29.2 25.8 29.1 26.1 28.9L48.7 16.8C49.5 16.4 50 15.5 50 14.6 50 13.7 49.5 12.8 48.7 12.4L26.1 0.3C25.4-0.1 24.6-0.1 23.9 0.3L1.3 12.4C0.5 12.8 0 13.7 0 14.6 0 15.5 0.5 16.4 1.3 16.8L23.9 28.9C24.2 29.1 24.6 29.2 25 29.2ZM7.3 14.6L25 5.2 42.7 14.6 25 24 7.3 14.6ZM48.7 22.4L47.7 21.9 25 34.2 2.3 21.9 1.3 22.4C0.5 22.9 0 23.7 0 24.7 0 25.6 0.5 26.5 1.3 26.9L23.9 39.3C24.2 39.5 24.6 39.6 25 39.6 25.4 39.6 25.8 39.5 26.1 39.3L48.7 26.9C49.5 26.5 50 25.6 50 24.7 50 23.7 49.5 22.9 48.7 22.4ZM48.7 32.8L47.7 32.3 25 44.6 2.3 32.3 1.3 32.8C0.5 33.3 0 34.1 0 35.1 0 36 0.5 36.9 1.3 37.3L23.9 49.7C24.2 49.9 24.6 50 25 50 25.4 50 25.8 49.9 26.1 49.7L48.7 37.3C49.5 36.9 50 36 50 35.1 50 34.1 49.5 33.3 48.7 32.8Z" fill="currentColor"></path></g></svg><span>Queue</span></a></li><li class="search"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z" fill="currentColor"></path></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"></path></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li><a href="https://www.safaribooksonline.com/history/" class="t-recent-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>recent items icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 0C11.2 0 0 11.2 0 25 0 38.8 11.2 50 25 50 38.8 50 50 38.8 50 25 50 11.2 38.8 0 25 0ZM6.3 25C6.3 14.6 14.6 6.3 25 6.3 35.4 6.3 43.8 14.6 43.8 25 43.8 35.4 35.4 43.8 25 43.8 14.6 43.8 6.3 35.4 6.3 25ZM31.8 31.5C32.5 30.5 32.4 29.2 31.6 28.3L27.1 23.8 27.1 12.8C27.1 11.5 26.2 10.4 25 10.4 23.9 10.4 22.9 11.5 22.9 12.8L22.9 25.7 28.8 31.7C29.2 32.1 29.7 32.3 30.2 32.3 30.8 32.3 31.3 32 31.8 31.5Z" fill="currentColor"></path></g></svg><span>History</span></a></li><li><a href="https://www.safaribooksonline.com/topics" class="t-topics-link l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 55" version="1.1" fill="#4A3C31"><desc>topics icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 55L50 41.262 50 13.762 25 0 0 13.762 0 41.262 25 55ZM8.333 37.032L8.333 17.968 25 8.462 41.667 17.968 41.667 37.032 25 46.538 8.333 37.032Z" fill="currentColor"></path></g></svg><span>Topics</span></a></li><li><a href="https://www.safaribooksonline.com/tutorials/" class="l1 nav-icn t-tutorials-nav js-toggle-menu-item None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" version="1.1" fill="#4A3C31"><desc>tutorials icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M15.8 18.2C15.8 18.2 15.9 18.2 16 18.2 16.1 18.2 16.2 18.2 16.4 18.2 16.5 18.2 16.7 18.1 16.9 18 17 17.9 17.1 17.8 17.2 17.7 17.3 17.6 17.4 17.5 17.4 17.4 17.5 17.2 17.6 16.9 17.6 16.7 17.6 16.6 17.6 16.5 17.6 16.4 17.5 16.2 17.5 16.1 17.4 15.9 17.3 15.8 17.2 15.6 17 15.5 16.8 15.3 16.6 15.3 16.4 15.2 16.2 15.2 16 15.2 15.8 15.2 15.7 15.2 15.5 15.3 15.3 15.4 15.2 15.4 15.1 15.5 15 15.7 14.9 15.8 14.8 15.9 14.7 16 14.7 16.1 14.6 16.3 14.6 16.4 14.6 16.5 14.6 16.6 14.6 16.6 14.6 16.7 14.6 16.9 14.6 17 14.6 17.1 14.7 17.3 14.7 17.4 14.8 17.6 15 17.7 15.1 17.9 15.2 18 15.3 18 15.5 18.1 15.5 18.1 15.6 18.2 15.7 18.2 15.7 18.2 15.7 18.2 15.8 18.2L15.8 18.2ZM9.4 11.5C9.5 11.5 9.5 11.5 9.6 11.5 9.7 11.5 9.9 11.5 10 11.5 10.2 11.5 10.3 11.4 10.5 11.3 10.6 11.2 10.8 11.1 10.9 11 10.9 10.9 11 10.8 11.1 10.7 11.2 10.5 11.2 10.2 11.2 10 11.2 9.9 11.2 9.8 11.2 9.7 11.2 9.5 11.1 9.4 11 9.2 10.9 9.1 10.8 8.9 10.6 8.8 10.5 8.7 10.3 8.6 10 8.5 9.9 8.5 9.7 8.5 9.5 8.5 9.3 8.5 9.1 8.6 9 8.7 8.8 8.7 8.7 8.8 8.6 9 8.5 9.1 8.4 9.2 8.4 9.3 8.2 9.5 8.2 9.8 8.2 10 8.2 10.1 8.2 10.2 8.2 10.3 8.2 10.5 8.3 10.6 8.4 10.7 8.5 10.9 8.6 11.1 8.7 11.2 8.9 11.3 9 11.4 9.1 11.4 9.2 11.4 9.3 11.5 9.3 11.5 9.3 11.5 9.4 11.5 9.4 11.5L9.4 11.5ZM3 4.8C3.1 4.8 3.1 4.8 3.2 4.8 3.4 4.8 3.5 4.8 3.7 4.8 3.8 4.8 4 4.7 4.1 4.6 4.3 4.5 4.4 4.4 4.5 4.3 4.6 4.2 4.6 4.1 4.7 4 4.8 3.8 4.8 3.5 4.8 3.3 4.8 3.1 4.8 3 4.8 2.9 4.7 2.8 4.7 2.6 4.6 2.5 4.5 2.3 4.4 2.2 4.2 2.1 4 1.9 3.8 1.9 3.6 1.8 3.5 1.8 3.3 1.8 3.1 1.8 2.9 1.8 2.7 1.9 2.6 2 2.4 2.1 2.3 2.2 2.2 2.3 2.1 2.4 2 2.5 2 2.6 1.8 2.8 1.8 3 1.8 3.3 1.8 3.4 1.8 3.5 1.8 3.6 1.8 3.8 1.9 3.9 2 4 2.1 4.2 2.2 4.4 2.4 4.5 2.5 4.6 2.6 4.7 2.7 4.7 2.8 4.7 2.9 4.8 2.9 4.8 3 4.8 3 4.8 3 4.8L3 4.8ZM13.1 15.2C13.2 15.1 13.2 15.1 13.2 15.1 13.3 14.9 13.4 14.7 13.6 14.5 13.8 14.2 14.1 14 14.4 13.8 14.7 13.6 15.1 13.5 15.5 13.4 15.9 13.4 16.3 13.4 16.7 13.5 17.2 13.5 17.6 13.7 17.9 13.9 18.2 14.1 18.5 14.4 18.7 14.7 18.9 15 19.1 15.3 19.2 15.6 19.3 15.9 19.4 16.1 19.4 16.4 19.4 17 19.3 17.5 19.1 18.1 19 18.3 18.9 18.5 18.7 18.7 18.5 19 18.3 19.2 18 19.4 17.7 19.6 17.3 19.8 16.9 19.9 16.6 20 16.3 20 16 20 15.8 20 15.6 20 15.4 19.9 15.4 19.9 15.4 19.9 15.4 19.9 15.2 19.9 15 19.8 14.9 19.8 14.8 19.7 14.7 19.7 14.6 19.7 14.4 19.6 14.3 19.5 14.1 19.3 13.7 19.1 13.4 18.7 13.2 18.4 13.1 18.1 12.9 17.8 12.9 17.5 12.8 17.3 12.8 17.1 12.8 16.9L3.5 14.9C3.3 14.9 3.1 14.8 3 14.8 2.7 14.7 2.4 14.5 2.1 14.3 1.7 14 1.4 13.7 1.2 13.3 1 13 0.9 12.6 0.8 12.3 0.7 12 0.7 11.7 0.7 11.4 0.7 11 0.8 10.5 1 10.1 1.1 9.8 1.3 9.5 1.6 9.2 1.8 8.9 2.1 8.7 2.4 8.5 2.8 8.3 3.2 8.1 3.6 8.1 3.9 8 4.2 8 4.5 8 4.6 8 4.8 8 4.9 8.1L6.8 8.5C6.8 8.4 6.8 8.4 6.8 8.4 6.9 8.2 7.1 8 7.2 7.8 7.5 7.5 7.7 7.3 8 7.1 8.4 6.9 8.7 6.8 9.1 6.7 9.5 6.7 10 6.7 10.4 6.8 10.8 6.8 11.2 7 11.5 7.2 11.8 7.5 12.1 7.7 12.4 8 12.6 8.3 12.7 8.6 12.8 8.9 12.9 9.2 13 9.4 13 9.7 13 9.7 13 9.8 13 9.8 13.6 9.9 14.2 10.1 14.9 10.2 15 10.2 15 10.2 15.1 10.2 15.3 10.2 15.4 10.2 15.6 10.2 15.8 10.1 16 10 16.2 9.9 16.4 9.8 16.5 9.6 16.6 9.5 16.8 9.2 16.9 8.8 16.9 8.5 16.9 8.3 16.9 8.2 16.8 8 16.8 7.8 16.7 7.7 16.6 7.5 16.5 7.3 16.3 7.2 16.2 7.1 16 7 15.9 6.9 15.8 6.9 15.7 6.9 15.6 6.8 15.5 6.8L6.2 4.8C6.2 5 6 5.2 5.9 5.3 5.7 5.6 5.5 5.8 5.3 6 4.9 6.2 4.5 6.4 4.1 6.5 3.8 6.6 3.5 6.6 3.2 6.6 3 6.6 2.8 6.6 2.7 6.6 2.6 6.6 2.6 6.5 2.6 6.5 2.5 6.5 2.3 6.5 2.1 6.4 1.8 6.3 1.6 6.1 1.3 6 1 5.7 0.7 5.4 0.5 5 0.3 4.7 0.2 4.4 0.1 4.1 0 3.8 0 3.6 0 3.3 0 2.8 0.1 2.2 0.4 1.7 0.5 1.5 0.7 1.3 0.8 1.1 1.1 0.8 1.3 0.6 1.6 0.5 2 0.3 2.3 0.1 2.7 0.1 3.1 0 3.6 0 4 0.1 4.4 0.2 4.8 0.3 5.1 0.5 5.5 0.8 5.7 1 6 1.3 6.2 1.6 6.3 1.9 6.4 2.3 6.5 2.5 6.6 2.7 6.6 3 6.6 3 6.6 3.1 6.6 3.1 9.7 3.8 12.8 4.4 15.9 5.1 16.1 5.1 16.2 5.2 16.4 5.2 16.7 5.3 16.9 5.5 17.2 5.6 17.5 5.9 17.8 6.2 18.1 6.5 18.3 6.8 18.4 7.2 18.6 7.5 18.6 7.9 18.7 8.2 18.7 8.6 18.7 9 18.6 9.4 18.4 9.8 18.3 10.1 18.2 10.3 18 10.6 17.8 10.9 17.5 11.1 17.3 11.3 16.9 11.6 16.5 11.8 16 11.9 15.7 12 15.3 12 15 12 14.8 12 14.7 12 14.5 11.9 13.9 11.8 13.3 11.7 12.6 11.5 12.5 11.7 12.4 11.9 12.3 12 12.1 12.3 11.9 12.5 11.7 12.7 11.3 12.9 10.9 13.1 10.5 13.2 10.2 13.3 9.9 13.3 9.6 13.3 9.4 13.3 9.2 13.3 9 13.2 9 13.2 9 13.2 9 13.2 8.8 13.2 8.7 13.2 8.5 13.1 8.2 13 8 12.8 7.7 12.6 7.4 12.4 7.1 12 6.8 11.7 6.7 11.4 6.6 11.1 6.5 10.8 6.4 10.6 6.4 10.4 6.4 10.2 5.8 10.1 5.2 9.9 4.5 9.8 4.4 9.8 4.4 9.8 4.3 9.8 4.1 9.8 4 9.8 3.8 9.8 3.6 9.9 3.4 10 3.2 10.1 3 10.2 2.9 10.4 2.8 10.5 2.6 10.8 2.5 11.1 2.5 11.5 2.5 11.6 2.5 11.8 2.6 12 2.6 12.1 2.7 12.3 2.8 12.5 2.9 12.6 3.1 12.8 3.2 12.9 3.3 13 3.5 13.1 3.6 13.1 3.7 13.1 3.8 13.2 3.9 13.2L13.1 15.2 13.1 15.2Z" fill="currentColor"></path></g></svg><span>Tutorials</span></a></li><li class="nav-offers flyout-parent"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#" class="l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>offers icon</desc><path d="M10.8 43.7L0 39 0 10.2 13.6 4.6 23.3 8.7 11.5 13.5C11 13.6 10.8 13.9 10.8 14.3L10.8 43.7 10.8 43.7Z"></path><polygon points="12.3 44.4 25 50 38 44.3 38 14.7 25.2 9.4 12.3 14.7 12.3 44.4"></polygon><path d="M36.6 4.7L50 10.2 50 39 39.5 43.6 39.5 14.3C39.5 13.8 39.2 13.6 38.8 13.5L27 8.7 36.6 4.7 36.6 4.7Z"></path><polygon points="34.8 4 25 0 15.4 3.9 25.2 7.9 34.8 4"></polygon></svg><span>Offers</span></a><ul class="flyout"><li><a href="https://www.safaribooksonline.com/oreilly-conferences/" class="l2 nav-icn"><span>Conferences</span></a></li><li><a href="https://www.safaribooksonline.com/oreilly-newsletters/" class="l2 nav-icn"><span>Newsletter</span></a></li></ul></li><li class="nav-highlights"><a href="https://www.safaribooksonline.com/u/003o000000t5q9fAAA/" class="t-highlights-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 35" version="1.1" fill="#4A3C31"><desc>highlights icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M13.325 18.071L8.036 18.071C8.036 11.335 12.36 7.146 22.5 5.594L22.5 0C6.37 1.113 0 10.632 0 22.113 0 29.406 3.477 35 10.403 35 15.545 35 19.578 31.485 19.578 26.184 19.578 21.556 17.211 18.891 13.325 18.071L13.325 18.071ZM40.825 18.071L35.565 18.071C35.565 11.335 39.86 7.146 50 5.594L50 0C33.899 1.113 27.5 10.632 27.5 22.113 27.5 29.406 30.977 35 37.932 35 43.045 35 47.078 31.485 47.078 26.184 47.078 21.556 44.74 18.891 40.825 18.071L40.825 18.071Z" fill="currentColor"></path></g></svg><span>Highlights</span></a></li><li><a href="https://www.safaribooksonline.com/u/" class="t-settings-nav l1 js-settings nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z" fill="currentColor"></path></g></svg><span>Settings</span></a></li><li><a href="https://community.safaribooksonline.com/" class="l1 no-icon">Feedback</a></li><li><a href="https://www.safaribooksonline.com/accounts/logout/" class="l1 no-icon">Sign Out</a></li></ul><ul class="profile"><li><a href="https://www.safaribooksonline.com/u/" class="l2 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z" fill="currentColor"></path></g></svg><span>Settings</span></a></li><li><a href="https://community.safaribooksonline.com/" class="l2">Feedback</a></li><li><a href="https://www.safaribooksonline.com/accounts/logout/" class="l2">Sign Out</a></li></ul></div></li></ul></nav></header>


      </div>
      <div id="container" class="application">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      How Google Tests Software
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#" title="Search in archive" class="js-search-controls search-controls"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><button type="button" class="rec-fav ss-queue js-queue js-current-chapter-queue" data-queue-endpoint="/api/v1/book/9780132851572/chapter/ch02.html" data-for-analytics="9780132851572:ch02.html"><span>Add to Queue</span></button></li><li class="js-font-control-panel font-control-activator"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a class="twitter share-button t-twitter" target="_blank" aria-label="Share this section on Twitter" title="Share this section on Twitter" href="https://twitter.com/share?url=https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/ch02.html&amp;text=How%20Google%20Tests%20Software&amp;via=safari"><span>Twitter</span></a></li><li><a class="facebook share-button t-facebook" target="_blank" aria-label="Share this section on Facebook" title="Share this section on Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/ch02.html"><span>Facebook</span></a></li><li><a class="googleplus share-button t-googleplus" target="_blank" aria-label="Share this secton on Google Plus" title="Share this secton on Google Plus" href="https://plus.google.com/share?url=https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/ch02.html"><span>Google Plus</span></a></li><li><a class="email share-button t-email" aria-label="Share this section via email" title="Share this section via email" href="mailto:?subject=Safari:%20Chapter%202.%20The%20Software%20Engineer%20in%20Test&amp;body=https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/ch02.html%0D%0Afrom%20How%20Google%20Tests%20Software%0D%0A"><span>Email</span></a></li></ul></li>
      </ul>
    </div>

    <section role="document">
      
	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="/safari-books-archive/site/library/view/how-google-tests/9780132851572/ch01.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">Chapter 1. Introduction to Google Software Testing</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="/safari-books-archive/site/library/view/how-google-tests/9780132851572/ch03.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">Chapter 3. The Test Engineer</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div class="annotator-wrapper"><h2 id="ch02"><a id="page_15"></a>Chapter 2. The Software Engineer in Test</h2>
<p>Imagine for a moment the perfect development process. It would begin with test. Before even a single line of code is written, a developer would ponder what it will take to test it. He will write tests for boundary cases, for data values too large and too small, for values that would push loops beyond their limits, and for a myriad of other concerns. Some of these tests will be part of the functions she writes, self-testing code or unit tests. For these types of tests, the person who writes the code and understands it best is the one who is most qualified to test it.</p>
<p>Other tests require knowledge outside the actual codebase and must rely on external infrastructure. For example, a test that retrieves data from a remote data store (a database server or the cloud) either requires that database to exist or requires a simulated version of it be available for testing. Over the years, the industry has used any number of terms to describe such scaffolding including <em>test harnesses</em>, <em>test infrastructure</em>, <em>mocks,</em> and <em>fakes</em>. In a perfect development process, such scaffolding would be available for every interface a developer would ever encounter so that any aspect of any function you would ever want to write could be tested any time you wanted to test it (remember, we are imagining a perfect world!).</p>
<p>This is the first place where a perfect development process requires a tester. There is a different kind of thinking involved in writing feature code and writing test code. It becomes necessary to distinguish between a feature developer and a test developer. For feature code, the mindset is <em>creating</em> and considering users, use cases, and workflow. For test code, the mindset is about <em>breaking</em> and writing code that will draw out cases that disrupt the user and his workflow. Because we are in the fairytale land of the perfect development process, we might as well employ separate developers: one who writes features and one who enables them to be broken.</p>
<div class="sidebar1"><hr>
<p class="sidebarpara">There is a different kind of thinking involved in writing feature code and writing test code.</p>
<hr></div>
<p><a id="page_16"></a>Our utopian development process requires any number of feature developers and test developers collaborating to build a complicated product. True utopia should even allow for one developer per feature and any number of test developers buzzing around working on a central test infrastructure and assisting feature developers with their specific unit-testing issues that might otherwise distract them from the construction process that requires most of their concentration.</p>
<p>As feature developers write functional code and test developers write test code, a third concern rears its head: that of the user. Clearly in our perfect utopian testing world, this task should fall on a third class of engineer with the feature developers and test developers gainfully occupied elsewhere. Let’s call this newcomer a user developer. User-oriented tasks like use cases, user stories, user scenarios, exploratory testing, and so on are the order of business here. User developers concern themselves with how the features tie together and form an integrated whole. They work on systemwide issues and generally take the view of the user when asking whether the sum of the parts is actually something useful to a real community of end users.</p>
<p>This is our idea of software development utopia, three classes of developers collaborating on usable, reliable perfection—each of them specialized to handle something important and each of them interoperating and collaborating as equals.</p>
<p>Who wouldn’t want to work for a company that implemented software this way? You can certainly sign us up!</p>
<p>Unfortunately, none of us work for that company. Google, like all the other companies before it, has done its best to measure up and perhaps because of our position at the end of the queue of those who tried, we’ve learned from the mistakes of our forebears. Google has also benefitted from being at the inflection point of software moving from massive client-side binaries with multi-year release cycles to cloud-based services that are released every few weeks, days, or hours.<sup><a id="ch02fn_01"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn01" class="totri-footnote">1</a></sup> This confluence of happy circumstances has endowed us with some similarities to the utopian software development process.</p>
<p>Google SWEs are feature developers, responsible for building components that ship to customers. They write feature code and unit test code for those features.</p>
<p>Google SETs are test developers, responsible for assisting SWEs with the unit test portion of their work and also in writing larger test frameworks to assist SWEs in writing small and medium tests to assess broader quality concerns.</p>
<p>Google TEs are user developers, responsible for taking the users’ perspectives in all things that have to do with quality. From a development <a id="page_17"></a>perspective, they create automation for user scenarios and from a product perspective, they assess the overall coverage and effectiveness of the ensemble of testing activity performed by the other engineering roles. It is not utopia, but it is our best attempt at achieving it in a practical way where real-world concerns have a way of disrupting best intentions in the most unforeseen and unforgiving way.</p>
<div class="note1"><hr>
<p class="note">Note</p>
<p class="notepara">Google SWEs are feature developers. Google SETs are test developers. Google TEs are user developers.</p>
<hr></div>
<p>In this book, we are concerned primarily with the activity of the SET and TE roles and include the activity of the SWE as a subset of both of these roles because the SWE is heavily involved but usually under the direction of an engineer who actually has the word test in his or her title.</p>
<h3 id="ch02sec1lev1">The Life of an SET</h3>
<p>In the early days of any company, testers generally don’t exist.<sup><a id="ch02fn_02"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn02" class="totri-footnote">2</a></sup> Neither do PMs, planners, release engineers, system administrators, or any other role. Every employee performs all of these roles as one. We often like to imagine Larry and Sergey puzzling over user scenarios and unit tests in those early days! But as Google grew, the SET was the first role that combined the engineering flavor of a developer with the quality-minded role of a tester.<sup><a id="ch02fn_03"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn03" class="totri-footnote">3</a></sup></p>
<h4 id="ch02sec2lev1">Development and Test Workflow</h4>
<p>Before we dig into the workflow specific to SETs, it is helpful to understand the overall development context in which SETs work. SETs and SWEs form a tight partnership in the development of a new product or service and there is a great deal of overlap in their actual work. This is by design because Google believes it is important that testing is owned by the entire engineering team and not just those with the word test in their job title.</p>
<p>Shipping code is the primary shared artifact between engineers on a team. It is the organization of this code, its development, care, and feeding that becomes the focus of everyday effort. Most code at Google shares a single repository and common tool chain. These tools and repository feed <a id="page_18"></a>Google’s build and release process. All Google engineers, regardless of their role, become intimately familiar with this environment to the point that performing any tasks associated with checking in new code, submitting and executing tests, launching a build, and so on can be done without conscious thought by anyone on the team (assuming that person’s role demands it).</p>
<div class="sidebar1"><hr>
<p class="sidebarpara">Shipping code is the primary shared artifact between engineers on a team. It is the organization of this code, its development, care, and feeding that becomes the focus of everyday effort.</p>
<hr></div>
<p>This single repository makes a great deal of sense as engineers moving from project to project have little to relearn and so called “20 percent contributors”<sup><a id="ch02fn_04"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn04" class="totri-footnote">4</a></sup> can be productive from their first day on a project. It also means that any source code is available to any engineer who needs to see it. Web app developers can see any browser code they need to make their job easier without asking permission. They can view code written by more experienced engineers and see how others performed similar tasks. They can pick up code for reuse at the module or even the control structure or data structure level of detail. Google is one company and has one easily searchable (of course!) source repository.</p>
<p>This openness of the codebase, the harmony of the engineering toolset, and companywide sharing of resources has enabled the development of a rich set of shared code libraries and services. This shared code works reliably on Google’s production infrastructure, speeding projects to completion and ensuring few failures due to underlying shared libraries.</p>
<div class="sidebar1"><hr>
<p class="sidebarpara">This openness of the codebase, the harmony of the engineering toolset, and companywide sharing of resources has enabled the development of a rich set of shared code libraries and services.</p>
<hr></div>
<p><a id="page_19"></a>Code associated with the shared infrastructure has a special type of treatment by engineers, and those working on it follow a set of unwritten but common practices that speak to the importance of the code and the care that engineers take when modifying it.</p>
<p class="indenthangingB">• All engineers must reuse existing libraries, unless they have very good reason not to based on a project-specific need.</p>
<p class="indenthangingB">• All shared code is written first and foremost to be easily located and readable. It must be stored in the shared portion of the repository so it can be easily located. Because it is shared among various engineers, it must be easy to understand. All code is treated as though others will need to read or modify it in the future.</p>
<p class="indenthangingB">• Shared code must be as reusable and as self-contained as possible. Engineers get a lot of credit for writing a service that is picked up by multiple teams. Reuse is rewarded far more than complexity or cleverness.</p>
<p class="indenthangingB">• Dependencies must be surfaced and impossible to overlook. If a project depends on shared code, it should be difficult or impossible to modify that shared code without engineers on dependent projects being made aware of the changes.</p>
<p class="indenthangingB">• If an engineer comes up with a better way of doing something, he is tasked with refactoring all existing libraries and assisting dependent projects to migrate to the new libraries. Again, such benevolent community work is the subject of any number of available reward mechanisms.<sup><a id="ch02fn_05"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn05" class="totri-footnote">5</a></sup></p>
<p class="indenthangingB">• Google takes code reviews seriously, and, especially with common code, developers must have all their code reviewed by someone with a “readability” in the relevant programming language. A committee grants readabilities after a developer establishes a good track record for writing clean code which adheres to style guidelines. Readabilities exist for C++, Java, Python, and JavaScript: Google’s four primary languages.</p>
<p class="indenthangingB">• Code in the shared repository has a higher bar for testing (we discuss this more later).</p>
<p>Platform dependencies are dealt with by minimizing them. Every engineer has a desktop OS as identical as possible to Google’s production system. Linux distributions are carefully managed to keep dependencies at a minimum so that a developer doing local testing on his own machine will likely achieve the same results as if he were testing on the production system. From desktop to data center, the variations between CPU and <a id="page_20"></a>operating system are minimal.<sup><a id="ch02fn_06"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn06" class="totri-footnote">6</a></sup> If a bug occurs on a tester’s machine, chances are it will reproduce on a developer’s machine and in production.</p>
<p>All code that deals with platform dependencies is pushed into libraries at the lowest level of the stack. The same team that manages the Linux distributions also manages these platform libraries. Finally, for each programming language Google uses, there is exactly one compiler, which is well maintained and constantly tested against the one Linux distribution. None of this is magic, but the work involved in limiting the impact of multiple environments saves a great deal of testing downstream and reduces hard-to-debug environmental issues that distract from the development of new functionality. Keep it simple, keep it safe.</p>
<div class="note1"><hr>
<p class="note">Note</p>
<p class="notepara">Keeping it simple and uniform is a specific goal of the Google platform: a common Linux distribution for engineering workstations and production deployment machines; a centrally managed set of common, core libraries; a common source, build, and test infrastructure; a single compiler for each core programming language; language independent, common build specification; and a culture that respects and rewards the maintenance of these shared resources.</p>
<hr></div>
<p>The single platform, single repository theme continues with a unified build system, which simplifies working within the shared repository. A build specification language that is independent of a project’s specific programming language directs the build system. Whether a team uses C++, Python, or Java, they share the same “build files.”</p>
<p>A build is achieved by specifying a build target (which is either a library, binary, or test set) composed of some number of source files. Here’s the overall flow:</p>
<p class="indenthangingN">1. Write a class or set of functions for a service in one or more source files and make sure all the code compiles.</p>
<p class="indenthangingN">2. Identify a library build target for this new service.</p>
<p class="indenthangingN">3. Write a unit test that imports the library, mocks out its nontrivial dependencies, and executes the most interesting code paths with the most interesting inputs.</p>
<p class="indenthangingN">4. Create a test build target for the unit test.</p>
<p class="indenthangingN">5. Build and run the test target, making necessary changes until all the tests pass cleanly.</p>
<p class="indenthangingN"><a id="page_21"></a>6. Run all required static analysis tools that check for style guide compliance and a suite of common problems.</p>
<p class="indenthangingN">7. Send the resulting code out for code review (more details about the code review follow), make appropriate changes, and rerun all the unit tests.</p>
<p>The output of all this effort is a pair of build targets: the library build target representing the new service we wish to ship and a test build target that tests the service. Note that many developers at Google perform test-driven development, which means step 3 precedes steps 1 and 2.</p>
<p>Larger services are constructed by continuing to write code and link together progressively larger library build targets until the entire service is complete. At this point, a binary build target is created from the main source file that links against the service library. Now you have a Google product that consists of a well-tested standalone binary, a readable, reusable service library with a suite of supporting libraries that can be used to create other services, and a suite of unit tests that cover all the interesting aspects of each of these build targets.</p>
<p>A typical Google product is a composition of many services and the goal is to have a 1:1 ratio between a SWE and a service on any given product team. This means that each service can be constructed, built, and tested in parallel and then integrated together in a final build target once they are all ready. To enable dependent services to be built in parallel, the interfaces that each service exposes are agreed on early in the project. That way, developers take dependencies on agreed-upon interfaces rather than the specific libraries that implement them. Fake implementations of these interfaces are created early to unblock developers from writing their service-level tests.</p>
<p>SETs are involved in much of the test target builds and identify places where small tests need to be written. But it is in the integration of multiple build targets into a larger application build target where their work steps up and larger integration tests are necessary. On an individual library build target, mostly small tests (written by the SWE who owns that functionality with support from any SET on the project) are run. SETs get involved and write medium and large tests as the build target gets larger.</p>
<p>As the build target increases in size, small tests written against integrated functionality become part of the regression suite. They are always expected to pass and when they fail, bugs are raised against the tests and are treated no differently than bugs in features. Test is part of the functionality, and buggy tests are functional bugs and must be fixed. This ensures that new functionality does not break existing functionality and that any code modifications do not break any tests.</p>
<p>In all of this activity, the SETs are centrally involved. They assist developers in deciding what unit tests to write. They write many of the mocks and fakes. They write medium and large integration tests. It is this set of tasks the SET performs that we turn to now.</p>
<h4 id="ch02sec2lev2"><a id="page_22"></a>Who Are These SETs Anyway?</h4>
<p>SETs are the engineers involved in enabling testing at all levels of the Google development process we just described. SETs are Software Engineers in Test. First and foremost, SETs are <em>software engineers</em> and the role is touted as a 100 percent coding role in our recruiting literature and internal job promotion ladders. It’s an interesting hybrid approach to testing that enables us to get testers involved early in a way that’s not about touchy-feely “quality models” and “test plans” but as active participants in designing and creating the codebase. It creates an equal footing between feature developers and test developers that is productive and lends credibility to all types of testing, including manual and exploratory testing that occurs later in the process and is performed by a different set of engineers.</p>
<div class="note1"><hr>
<p class="note">Note</p>
<p class="notepara">Test is just another feature of the application, and SETs are the owner of the testing feature.</p>
<hr></div>
<p>SETs sit side by side with feature developers (literally, it is the goal to have SWEs and SETs co-located). It is fair to characterize test as just another feature of the application and SETs as the owner of the testing feature. SETs also participate in reviewing code written by SWEs and vice versa.</p>
<p>When SETs are interviewed, the “coding bar” is nearly identical to the SWE role with the added requirement that SETs know how to test the code they create. In other words, both SWEs and SETs answer coding questions. SETs are expected to nail a set of testing questions as well.</p>
<p>As you might imagine it is a difficult role to fill and it is entirely possible that the relatively low numbers of Google SETs isn’t because Google has created a magic formula for productivity, but more of a result of adapting our engineering practice around the reality that the SET skill set is hard to find. However, one of the nice side effects of the similarity of the SWE and SET roles is that both communities make excellent recruiting grounds for the other and conversions between the roles are something that Google tries its best to facilitate. Imagine a company full of developers who can test and testers who can code. We aren’t there yet and probably never will be, but there is a cross section of these communities, SWE-leaning SETs, and SET-leaning SWEs, who are some of our best engineers and make up some of our most effective product teams.</p>
<h4 id="ch02sec2lev3">The Early Phase of a Project</h4>
<p>There is no set rule at Google for when SETs engage in a project, as there are no set rules for establishing when projects become “real.” A common scenario for new project creation is that some informal 20 percent effort takes a <a id="page_23"></a>life of its own as an actual Google-branded product. Gmail and Chrome OS are both projects that started out as ideas that were not formally sanctioned by Google but overtime grew into shipping products with teams of developers and testers working on them. In fact, our friend Alberto Savoia (see his preface to this book) is fond of saying that “quality is not important until the software is important.”</p>
<p>There is a lot of innovation going on within loose-knit teams doing 20 percent work. Some of this work will end up nowhere, some will find its way into a larger project as a feature, and some may grow into an official Google product. None of them get testing resources as some inalienable right of their existence. Stacking a project potentially doomed to failure with a bunch of testers so they can build testing infrastructure is a waste of resources. If a project ends up being cancelled, what did that testing infrastructure accomplish?</p>
<p>Focusing on quality before a product concept is fully baked and determined to be feasible is an exercise in misplaced priorities. Many of the early prototypes that we have seen come from Google 20 percent efforts end up being redesigned to the point that little of the original code even exists by the time a version is ready for dogfood or beta. Clearly testing in this experimental context is a fool’s errand.</p>
<p>Of course, there is risk in the opposite direction too. If a product goes too long without testing involvement, it can be difficult to undo a series of design decisions that reduce testability to the point that automation is too hard and resulting test tools too brittle. There may be some rework that has to be done in the name of higher quality down the road. Such quality “debt” can slow products down for years.</p>
<p>Google doesn’t make specific attempts to get testers involved early in the lifecycle. In fact, SETs involved early are often there with their developer hat on as opposed to their testing hat. This is not an intentional omission, nor is it a statement that early quality involvement is not important. It is more an artifact of Google’s informal and innovation-driven project creation process. Google rarely creates projects as a big bang event where months of planning (which would include quality and test) are followed by a large development effort. Google projects are born much less formally.</p>
<p>Chrome OS serves as a case in point. It was a product all three authors of this book worked on for over a year. But before we joined formally, a few developers built a prototype, and much of it was scripts and fakes that allowed the concept of a browser-only app model to be demonstrated to Google brass for formal project approval. In this early prototyping phase, the concentration was on experimentation and proving that the concept was actually viable. A great deal of time testing or even designing for testability would have been moot given the project was still unofficial and all of the demonstration scripts would eventually be replaced by real C++ code. When the scripts fulfilled the demonstration purpose and the product was approved, the development director sought us out to provide testing resources.</p>
<p><a id="page_24"></a>This is a different kind of culture that exists at Google. No project gets testing resources as some right of its existence. The onus is on the development teams to solicit help from testers and convince them that their project is exciting and full of potential. As the Chrome OS development directors explained their project, progress, and ship schedule, we were able to place certain demands concerning SWE involvement in testing, expected unit testing coverage levels, and how the duties of the release process were going to be shared. We may not have been involved at project inception, but once the project became real, we had vast influence over how it was to be executed.</p>
<div class="sidebar1"><hr>
<p class="sidebarpara">No project gets testing resources as some right of its existence. The onus is on the development teams to solicit help from testers and convince them that their project is exciting and full of potential.</p>
<hr></div>
<h4 id="ch02sec2lev4">Team Structure</h4>
<p>SWEs often get caught up in the code they are writing and generally that code is a single feature or perhaps even smaller in scope than that. SWEs tend to make decisions optimized for this local and narrow view of a product. A good SET must take the exact opposite approach and assume not only a broad view of the entire product and consider all of its features but also understand that over a product’s lifetime, <em>many</em> SWEs will come and go and the product will outlive the people who created it.</p>
<p>A product like Gmail or Chrome is destined to live for many versions and will consume hundreds of developers’ individual work. If a SWE joins a product team working on version 3 and that product is well documented, testable, and has working stable test automation and processes that make it clear how to add new code into this mix, then that is a sign that the early SETs did their job correctly.</p>
<p>With all of the features added, versions launched, patches made, and good intentioned rewrites and renames that happen during the life of a project, it can be hard to identify when or if a project ever truly comes to an end. Every software project has a definite beginning, though. We refine our goals during that early phase. We plan. We try things out. We even attempt to document what we think we are going to do. We try to ensure that the decisions made early on are the right decisions for the long-term viability of the product.</p>
<p>The amount of planning, experimentation, and documentation we produce before we begin to implement a new software project is proportional to the strength of our convictions in the long-term viability and success of that project. We don’t want to begin with little in the way of planning only to find out later that planning would have been worthwhile. We also don’t <a id="page_25"></a>want to spend weeks in the early phase only to discover at its conclusion that the world around us has either changed or is not what it was originally thought to be. For these reasons, some structure around documentation and process during this early phase is wise. However, it is ultimately up to the engineers who create these projects to decide what and how much is enough.</p>
<p>Google product teams start with a tech lead and one or more founding members of various engineering roles. At Google, tech lead or TL is an informal title granted to the engineer or engineers responsible for setting the technical direction, coordinating activities, and acting as the main engineering representative of the project to other teams. He knows the answer to any question about the project or can point to someone who does. A project’s tech lead is usually a SWE or an engineer of another discipline working in a SWE capacity.</p>
<p>The tech lead and founding members of a project begin their work by drafting the project’s first design doc (described in the next section). As the document matures, it is leveraged as evidence of the need for additional engineers of various specializations. Many tech leads request an SET early on, despite their relative scarcity.</p>
<h4 id="ch02sec2lev5">Design Docs</h4>
<p>Every project at Google has a primary design doc. It is a living document, which means that it evolves alongside the project it describes. In its earliest form, a design doc describes the project’s objective, background, proposed team members, and proposed designs. During the early phase, the team works together to fill in the remaining relevant sections of the primary design doc. For sufficiently large projects, this might involve creating and linking to smaller design docs that describe the major subsystems. By the end of the early design phase, the project’s collection of design documents should be able to serve as a roadmap of all future work to be done. At this point, design docs might undergo one or more reviews by other tech leads in a project’s domain. Once a project’s design docs have received sufficient review, the early phase of the project draws to a close and the implementation phase officially begins.</p>
<p>As SETs, we are fortunate to join a project during its early phase. There is significant high-impact work to be done here. If we play our cards right, we can simplify the life of everyone on the project while accelerating the work of all those around us. Indeed, SETs have the one major advantage of being the engineer on the team <em>with the broadest view of the product</em>. A good SET can put this breadth of expertise to work for the more laser-focused developers and have impact far beyond the code they write. Generally broad patterns of code reuse and component interaction design are identified by SETs and not SWEs. The remainder of this section focuses on the high-value work an SET can do during the early phase of a project.</p>
<div class="note1"><hr>
<p class="note"><a id="page_26"></a>Note</p>
<p class="notepara">A SET’s role in the design phase is to simplify the life of everyone on the project while accelerating the work of all those around him.</p>
<hr></div>
<p>There is no substitute for an additional pair of eyes on a body of work. As SWEs fill in the various sections of their design docs, they should be diligent about getting peer feedback prior to sending their document to a wider audience for official review. A good SET is eager to review such documents and proactively volunteers his time to review documents written by the team and adds quality or reliability sections as necessary. Here are several reasons why:</p>
<p class="indenthangingB">• An SET needs to be familiar with the design of the system she tests (reading all of the design docs is part of this) so being a reviewer accomplishes both SET and SWE needs.</p>
<p class="indenthangingB">• Suggestions made early on are much more likely to make it into the document and into the codebase, increasing an SET’s overall impact.</p>
<p class="indenthangingB">• By being the first person to review all design documents (and thus seeing all their iterations), an SET’s knowledge of the project as a whole will rival that of the tech lead’s knowledge.</p>
<p class="indenthangingB">• It is a great chance to establish a working relationship with each of the engineers whose code and tests the SET will be working with when development begins.</p>
<p>Reviewing design documents should be done with purpose and not just be a general breeze through, as though you are reading a newspaper. A good SET is purposeful during his review. Here are some things we recommend:</p>
<p class="indenthangingB">• <strong>Completeness:</strong> Identify parts of the document that are incomplete or that require special knowledge not generally available on the team, particularly to new members of the team. Encourage the document’s author to write more details or link to other documentation that fill in these gaps.</p>
<p class="indenthangingB">• <strong>Correctness:</strong> Look for grammar, spelling, and punctuation mistakes; this is sloppy work that does not bode well for the code they will write later. Don’t set a precedent for sloppiness.</p>
<p class="indenthangingB">• <strong>Consistency:</strong> Ensure that wording matches diagrams. Ensure that the document does not contradict claims made in other documents.</p>
<p class="indenthangingB">• <strong>Design:</strong> Consider the design proposed by the document. Is it achievable given the resources available? What infrastructure does it propose to build upon? (Read the documentation of that infrastructure and learn its pitfalls.) Does the proposed design make use of that infrastructure in a supported way? Is the design too complex? Is it possible to simplify? Is it too simple? What more does the design need to address?</p>
<p class="indenthangingB"><a id="page_27"></a>• <strong>Interfaces and protocols:</strong> Does the document clearly identify the protocols it will use? Does it completely describe the interfaces and protocols that the product will expose? Do these interfaces and protocols accomplish what they are meant to accomplish? Are they standard across other Google products? Can you encourage the developer to go one step further and define his protocol buffers? (We discuss more about protocol buffers later.)</p>
<p class="indenthangingB">• <strong>Testing:</strong> How testable is the system or set of systems described by the document? Are new testing hooks required? If so, ensure those get added to the documentation. Can the design of the system be tweaked to make testing easier or use pre-existing test infrastructure? Estimate what must be done to test the system and work with the developer to have this information added to the design document.</p>
<div class="note1"><hr>
<p class="note">Note</p>
<p class="notepara">Reviewing design documents is purposeful and not like reading a newspaper. There are specific goals to pursue.</p>
<hr></div>
<p>When an SET discusses this review with the SWE who created the design document, a serious conversation about the amount of work required to test it and the way in which that work is shared among the roles happens. This is a great time to document the goals of developer unit testing along with the best practices team members will follow when delivering a well tested product. When this discussion happens in a collaborative way, you know you are off to a good start.</p>
<h4 id="ch02sec2lev6">Interfaces and Protocols</h4>
<p>Documenting interfaces and protocols at Google is easy for developers as it involves writing code! Google’s protocol buffer language<sup><a id="ch02fn_07"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn07" class="totri-footnote">7</a></sup> is a language-neutral, platform-neutral, extensible mechanism for serializing structured data—think XML, but smaller, faster, and easier. A developer defines how data is to be structured after it is in the protocol buffer language, and then uses generated source code to read and write the structured data from and to a variety of data streams in a variety of languages (Java, C++, or Python). Protocol buffer source is often the first code written for a new project. It is not uncommon to have design docs refer to protocol buffers as the specification of how things will work once the full system is implemented.</p>
<p>An SET reviews protocol buffer code thoroughly, because he will soon implement most of the interfaces and protocols described by that protocol buffer code. That’s right, it is an SET who typically implements most of the <a id="page_28"></a>interfaces and protocols in the system first, because the need for integration testing often arises before it is possible to construct all subsystems on which the entire system depends. To enable integration testing early on, the SET provides mocks and fakes of the necessary dependencies of each component. Such integration tests have to be written eventually, and they’re more valuable when they’re available as the code is still being developed. Further, the mocks and fakes would be required for integration testing at any stage, as it is much easier to inject failures and establish error conditions through mocks than it is to do so within a system’s production dependencies.</p>
<div class="sidebar1"><hr>
<p class="sidebarpara">To enable integration testing early on, the SET provides mocks and fakes of the necessary dependencies of each component.</p>
<hr></div>
<h4 id="ch02sec2lev7">Automation Planning</h4>
<p>A SET’s time is limited and spread thinly and it is a good idea to create a plan for automating testing of the system as early as possible and to be practical about it. Designs that seek to automate everything end-to-end all in one master test suite are generally a mistake. Certainly no SWE is impressed by such an all-encompassing endeavor and an SET is unlikely to get much assistance. If an SET is going to get help from SWEs, his automation plan must be sensible and impactful. The larger an automation effort is, the harder it is to maintain and the more brittle it becomes as the system evolves. It’s the smaller, more special purpose automation that creates useful infrastructure and that attracts the most SWEs to write tests.</p>
<p>Overinvesting in end-to-end automation often ties you to a product’s specific design and isn’t particularly useful until the entire product is built and in stable form. By then, it’s often too late to make design changes in the product, so whatever you learn in testing at that point is moot. Time that the SET could have invested in improving quality was instead spent on maintaining a brittle end-to-end test suite.</p>
<div class="sidebar1"><hr>
<p class="sidebarpara">Overinvesting in end-to-end automation often ties you to a product’s specific design.</p>
<hr></div>
<p>At Google, SETs take the following approach.</p>
<p>We first isolate the interfaces that we think are prone to errors and create mocks and fakes (as described in the previous section) so that we can control the interactions at those interfaces and ensure good test coverage.</p>
<p><a id="page_29"></a>The next step is to build a lightweight automation framework that allows the mocked system to be built and executed. That way, any SWE who writes code that uses one of the mocked interfaces can do a private build and run the test automation before they check their code changes into the main codebase, ensuring only well tested code gets into the codebase in the first place. This is one key area where automation excels: keeping bad code out of the ecosystem and ensuring the main codebase stays clean.</p>
<p>In addition to the automation (mocks, fakes, and frameworks) to be delivered by the SET, the plan should include how to surface information about build quality to all concerned parties. Google SETs include such reporting mechanisms and dashboards that collect test results and show progress as part of the test plan. In this way, an SET increases the chances of creating high-quality code by making the whole process easy and transparent.</p>
<h4 id="ch02sec2lev8">Testability</h4>
<p>SWEs and SETs work closely on product development. SWEs write the production code and tests for that code. SETs support this work by writing test frameworks that enable SWEs to write tests. SETs also take a share of maintenance work. Quality is a shared responsibility between these roles.</p>
<p>A SET’s first job is testability. They act as consultants recommending program structure and coding style that lends itself to better unit testing and in writing frameworks to enable developers to test for themselves. We discuss frameworks later; first, let’s talk about the coding process at Google.</p>
<p>To make SETs true partners in the ownership of the source code, Google centers its development process around code reviews. There is far more fanfare about reviewing code than there is about writing it.</p>
<p>Reviewing code is a fundamental aspect of being a developer and it is an activity that has full tool support and an encompassing culture around it that has borrowed somewhat from the open source community’s concept of “committer” where only people who have proven to be reliable developers can actually commit code to the source tree.</p>
<div class="sidebar1"><hr>
<p class="sidebarpara">Google centers its development process around code reviews. There is far more fanfare about reviewing code than there is about writing it.</p>
<hr></div>
<p>At Google everyone is a committer, but we use a concept called <em>readability</em> to distinguish between proven committers and new developers. Here’s how the whole process works:</p>
<p>Code is written and packaged as a unit that we call a <em>change list,</em> or CL for short. A CL is written and then submitted for review in a tool known internally as Mondrian (named after the Dutch painter whose work <a id="page_30"></a>inspired abstract art). Mondrian then routes the code to qualified SWEs or SETs for review and eventual signoff.<sup><a id="ch02fn_08"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn08" class="totri-footnote">8</a></sup></p>
<p>CLs can be blocks of new code, changes to existing code, bug fixes, and so on. They range from a few lines to a few hundred lines with larger CLs almost always broken into smaller CLs at the behest of reviewers. SWEs and SETs who are new to Google will eventually be awarded with a <em>readability</em> designation by their peers for writing consistently good CLs. Readabilities are language specific and given for C++, Java, Python, and JavaScript, the primary languages Google uses. They are credentials that designate an experienced, trustworthy developer and help ensure the entire codebase has the look and feel of having been written by a single developer.<sup><a id="ch02fn_09"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn09" class="totri-footnote">9</a></sup></p>
<p>There are a number of automated checks that occur before a CL is routed to a reviewer. These <em>pre-submit rules</em> cover simple things such as adherence to the Google coding style guide and more involved things such as ensuring that every existing test associated with the CL has been executed (the rule is that all tests must pass). The tests for a CL are almost always included in the CL itself—test code lives side by side with the functional code. After these checks are made, Mondrian notifies the reviewer via email with links to the appropriate CLs. The reviewer then completes the review and makes recommendations that are then handled by the SWE. The process is repeated until both the reviewers are happy and the pre-submit automation runs clean.</p>
<p>A submit queue’s primary goal in life is to keep the build “green,” meaning all tests pass. It is the last line of defense between a project’s continuous build system and the version control system. By building code and running tests in a clean environment, the submit queue catches environmental failures that might not be caught by a developer running tests on an individual workstation, but that might ultimately break the continuous build or, worse, make its way into the version control system in a broken state.</p>
<p>A submit queue also enables members of large teams to collaborate on the main branch of the source tree. This further eliminates the need to have scheduled code freezes while branch integrations and test passes take place. In this way, a submit queue enables developers on large teams to work as efficiently and independently as developers on small teams. The only real downside is that it makes the SET’s job harder because it increases the rate at which developers can write and submit code!</p>
<div class="sidebar1"><hr>
<p class="sidebar2"><a id="page_31"></a><strong>How Submit Queues and Continuous Builds Came Into Being</strong> <em>by Jeff Carollo</em></p>
<p class="sidebarpara">In the beginning, Google was small. Having a policy of writing and running unit tests before checking in changes seemed good enough. Every now and then, a test would break and people would spend time figuring out why and then fix the problem.</p>
<p class="sidebarpara">The company grew. To realize the economies of scale, high-quality libraries and infrastructure were written, maintained, and shared by all developers. These core libraries grew in number, size, and complexity over time. Unit tests were not enough; integration testing was now required for code that had significant interactions with other libraries and infrastructure. At some point, Google realized that many test failures were introduced by dependencies on other components. As tests were not being run until someone on a project wanted to check in a change to that project, these integration failures could exist for days before being noticed.</p>
<p class="sidebarpara">Along came the “Unit Test Dashboard.” This system treated every top-level directory in the companywide source tree as a “project.” This system also allowed anyone to define their own “project,” which associated a set of build and test targets with a set of maintainers. The system would run all tests for each project every day. The pass and fail rate for each test and project was recorded and reported through the dashboard. Failing tests would generate emails to the maintainers of a project every day, so tests did not stay broken for long. Still, things broke.</p>
<p class="sidebarpara">Teams wanted to be even more proactive about catching the breaking changes. Running every test every 24 hours was not enough. Individual teams began to write Continuous Build scripts, which would run on dedicated machines and continuously build and run the unit and integration tests of their team. Realizing that such a system could be made generic enough to support any team, Chris Lopez and Jay Corbett sat down together and wrote the “Chris/Jay Continuous Build,” which allowed any project to deploy its own Continuous Build system by simply registering a machine, filling in a configuration file, and running a script. This practice became popular quite rapidly, and soon most projects at Google had a Chris/Jay Continuous Build. Failing tests would generate emails to the person or persons most likely to be the cause of those tests failing within minutes of those changes being checked in! Additionally, the Chris/Jay Continuous Build would identify “Golden Change Lists,” checkpoints in the version control system at which all tests for a particular project built and passed. This enabled developers to sync their view of the source tree to a version not affected by recent check-ins and build breakages (quite useful for selecting a stable build for release purposes).</p>
<p class="sidebarpara">Teams still wanted to be more proactive about catching breaking changes. As the size and complexity of teams and projects grew, so too did the cost of having a broken build. Submit Queues were built out of necessity as protectors of Continuous Build systems. Early implementations required all CLs to wait in line to be tested and approved by the system serially before those changes could be submitted (hence, the “queue” suffix). When lots of long-running tests were necessary, a several-hour backlog between a CL being sent to the queue and that CL <a id="page_32"></a>actually being submitted into version control was common. Subsequent implementations allowed all pending CLs to run in parallel with one another, but isolated from each other’s changes. While this “improvement” did introduce race conditions, those races were rare, and they would be caught by the Continuous Build eventually. The time saved in being able to submit within minutes of entering the submit queue greatly outweighed the cost of having to resolve the occasional Continuous Build failure. Most large projects at Google adopted the use of Submit Queues. Most of these large projects also rotated team members into a position of “build cop,” whose job it was to respond quickly to any issues uncovered in the project’s Submit Queue and Continuous Build.</p>
<p class="sidebarpara">This set of systems (the Unit Test Dashboard, the Chris/Jay Continuous Build, and Submit Queues) had a long life at Google (several years). They offered tremendous benefit to teams in exchange for a small amount of set-up time and varying amounts of ongoing maintenance. At some point, it became both feasible and practical to implement all of these systems in an integrated way as shared infrastructure for all teams. The Test Automation Program, or TAP, did just that. As of this writing, TAP has taken the place of each of these systems and is in use by nearly all projects at Google outside of Chromium and Android (which are open source and utilize separate source trees and build environments from the server side of Google).</p>
<p class="sidebarpara">The benefits of having most teams on the same set of tools and infrastructure cannot be overstated. With a single, simple command, an engineer is able to build and run all binaries and tests that might be affected by a CL in parallel in the cloud, have code coverage collected, have all results stored and analyzed in the cloud, and have those results visualized at a new permanent web location. The output of that command to the terminal is “PASS” or “FAIL” along with a hyperlink to the details. If a developer chooses to run his tests this way, the results of that test pass, including the code coverage information, are stored in the cloud and made visible to code reviewers through the internal Google code review tool.</p>
<hr></div>
<h4 id="ch02sec2lev9">SET Workflow: An Example</h4>
<p>Now let’s put all this together in an example. Warning: this section is going to get technical and go into a bunch of low-level details. If you are interested only in the big picture, feel free to skip to the next section.</p>
<p>Imagine a simple web application that allows users to submit URLs to Google that would then be added to Google’s index. The HTML form accepts two fields: url and comment, and it generates an HTTP GET request to Google’s servers resembling the following:</p>
<p class="programlisting">GET /addurl?url=http://www.foo.com&amp;comment=Foo+comment HTTP/1.1</p>
<p>The server-side of this example web application is broken into at least two parts: the <code>AddUrlFrontend</code> (which accepts the raw HTTP request, <a id="page_33"></a>parses it, and validates it) and the <code>AddUrlService</code> backend. This backend service accepts requests from the <code>AddUrlFrontend</code>, checks them for errors, and further interacts with persistent storage backends such as Google’s Bigtable<sup><a id="ch02fn_10"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn10">10</a></sup> or the Google File System.<sup><a id="ch02fn_11"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn11">11</a></sup></p>
<p>The SWE writing this service begins by creating a directory for this project:</p>
<p class="programlisting">$ mkdir depot/addurl/</p>
<p>He or she then defines the protocol of the <code>AddUrlService</code> using the Google Protocol Buffer<sup><a id="ch02fn_12"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn12">12</a></sup> description language as follows:</p>
<p class="programlisting"><span class="em">File: depot/addurl/addurl.proto</span><br>
message AddUrlRequest {<br>
&nbsp;&nbsp;required string url = 1;&nbsp;&nbsp;// The URL entered by the user.<br>
&nbsp;&nbsp;optional string comment = 2;&nbsp;&nbsp;// Comments made by the user.<br>
}<br><br>
message AddUrlReply {<br>
&nbsp;&nbsp;// Error code, if an error occurred.<br>
&nbsp;&nbsp;optional int32 error_code = 1;<br>
&nbsp;&nbsp;// Error message, if an error occurred.<br>
&nbsp;&nbsp;optional string error_details = 2;<br>
}<br><br>
service AddUrlService {<br>
&nbsp;&nbsp;// Accepts a URL for submission to the index.<br>
&nbsp;&nbsp;rpc AddUrl(AddUrlRequest) returns (AddUrlReply) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;option deadline = 10.0;<br>
&nbsp;}<br>
}</p>
<p>The addurl.proto file defines three important items: the <code>AddUrlRequest</code> and <code>AddUrlReply</code> messages and the <code>AddUrlService</code> Remote Procedure Call (RPC) service.</p>
<p>We can tell by inspecting the definition of the <code>AddUrlRequest</code> message that a <code>url</code> field must be supplied by the caller and that a <code>comment</code> field can be optionally supplied.</p>
<p>We can similarly see by inspecting the definition of the <code>AddUrlReply</code> message that both the <code>error_code</code> and <code>error_details</code> fields can optionally be supplied by the service in its replies. We can safely assume that these fields are left empty in the common case where a URL is accepted successfully, minimizing the amount of data transferred. This is the convention at Google: Make the common case fast.</p>
<p>Inspection of the <code>AddUrlService</code> reveals that there is a single service method, <code>AddUrl</code>, that accepts an <code>AddUrlRequest</code> and returns an <code>AddUrlReply</code>. By default, calls to the <code>AddUrl</code> method time out after an elapsed time of 10 seconds, if the client did not receive a response in that time. Implementations of the <code>AddUrlService</code> interface might involve any <a id="page_34"></a>number of persistent storage backends, but that is of no concern to clients of this interface, so those details are not present in the addurl.proto file.</p>
<p>The ‘<code>= 1</code>’ notation on message fields has no bearing on the values of those fields. The notation exists to allow the protocol to evolve over time. For example, in the future, someone might want to add a <code>uri</code> field to the <code>AddUrlRequest</code> message in addition to the fields that were already there. To do this, they can make the following change:</p>
<p class="programlisting">message AddUrlRequest {<br>
&nbsp;&nbsp;required string url = 1;&nbsp;&nbsp;// The URL entered by the user.<br>
&nbsp;&nbsp;optional string comment = 2;&nbsp;&nbsp;// Comments made by the user.<br>
&nbsp;&nbsp;<span class="strong">optional string uri = 3;&nbsp;&nbsp;// The URI entered by the user.</span><br>
}</p>
<p>But that would be silly. Someone is more likely to want to rename the <code>url</code> field to <code>uri</code>. If they keep the number and type the same, then they maintain compatibility between the old and new versions:</p>
<p class="programlisting">message AddUrlRequest {<br>
&nbsp;&nbsp;<span class="strong">required string uri = 1;&nbsp;&nbsp;// The URI entered by the user.</span><br>
&nbsp;&nbsp;optional string comment = 2;&nbsp;&nbsp;// Comments made by the user.<br>
}</p>
<p>Having written addurl.proto, our developer proceeds to create a <code>proto_library</code> build rule, which generates C++ source files that define the items from addurl.proto and that compile into a static <code>addurl</code> C++ library. (With additional options, source for Java and Python language bindings are also possible.)</p>
<p class="programlisting"><span class="em">File: depot/addurl/BUILD</span><br>
proto_library(name="addurl",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srcs=["addurl.proto"])</p>
<p>The developer invokes the build system and fixes any issues uncovered by the build system in addurl.proto and in its build definitions in the BUILD file. The build system invokes the Protocol Buffer compiler, generating source code files addurl.pb.h and addurl.pb.cc, as well as generating a static <code>addurl</code> library that can be linked against.</p>
<p>The <code>AddUrlFrontend</code> can now be written by creating a class declaration of <code>AddUrlFrontend</code> in a new file, addurl_frontend.h. This code is largely boilerplate.</p>
<p class="programlisting"><span class="em">File: depot/addurl/addurl_frontend.h</span><br>
#ifndef ADDURL_ADDURL_FRONTEND_H_<br>
#define ADDURL_ADDURL_FRONTEND_H_<br><br>
// Forward-declaration of dependencies.<br>
class AddUrlService;<br>
class HTTPRequest;<br>
class HTTPReply;<br><br>
// Frontend for the AddUrl system.<br>
// Accepts HTTP requests from web clients,<br>
// and forwards well-formed requests to the backend.<br>
class AddUrlFrontend {<br>
&nbsp;public:<br>
&nbsp;&nbsp;// Constructor which enables injection of an<br>
&nbsp;&nbsp;// AddUrlService dependency.<br>
<a id="page_35"></a>&nbsp;&nbsp;explicit AddUrlFrontend(AddUrlService* add_url_service);<br>
&nbsp;&nbsp;~AddUrlFrontend();<br><br>
&nbsp;&nbsp;// Method invoked by our HTTP server when a request arrives<br>
&nbsp;&nbsp;// for the /addurl resource.<br>
&nbsp;&nbsp;void HandleAddUrlFrontendRequest(const HTTPRequest* http_request,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTPReply* http_reply);<br>
&nbsp;private:<br>
&nbsp;&nbsp;AddUrlService* add_url_service_;<br><br>
&nbsp;&nbsp;// Declare copy constructor and operator= private to prohibit<br>
&nbsp;&nbsp;// unintentional copying of instances of this class.<br>
&nbsp;&nbsp;AddUrlFrontend(const AddUrlFrontend&amp;);<br>
&nbsp;&nbsp;AddUrlFrontend&amp; operator=(const AddUrlFrontend&amp; rhs);<br>
};<br><br>
#endif&nbsp;&nbsp;// ADDURL_ADDURL_FRONTEND_H_</p>
<p>Continuing on to the definitions of the <code>AddUrlFrontend</code> class, the developer now creates addurl_frontend.cc. This is where the logic of the <code>AddUrlFrontend</code> class is coded. For the sake of brevity, portions of this file have been omitted.</p>
<p class="programlisting"><span class="em">File: depot/addurl/addurl_frontend.cc</span><br>
#include "addurl/addurl_frontend.h"<br><br>
#include "addurl/addurl.pb.h"<br>
#include "path/to/httpqueryparams.h"<br><br>
// Functions used by HandleAddUrlFrontendRequest() below, but<br>
// whose definitions are omitted for brevity.<br>
void ExtractHttpQueryParams(const HTTPRequest* http_request,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;HTTPQueryParams* query_params);<br>
void WriteHttp200Reply(HTTPReply* reply);<br>
void WriteHttpReplyWithErrorDetails(<br>
&nbsp;&nbsp;&nbsp;&nbsp;HTTPReply* http_reply, const AddUrlReply&amp; add_url_reply);<br><br>
// AddUrlFrontend constructor that injects the AddUrlService<br>
// dependency.<br>
AddUrlFrontend::AddUrlFrontend(AddUrlService* add_url_service)<br>
&nbsp;&nbsp;&nbsp;&nbsp;: add_url_service_(add_url_service) {<br>
}<br><br>
// AddUrlFrontend destructor - there's nothing to do here.<br>
AddUrlFrontend::~AddUrlFrontend() {<br>
}<br><br>
// HandleAddUrlFrontendRequest:<br>
// Handles requests to /addurl by parsing the request,<br>
// dispatching a backend request to an AddUrlService backend,<br>
// and transforming the backend reply into an appropriate<br>
// HTTP reply.<br>
//<br>
// Args:<br>
//&nbsp;&nbsp;http_request - The raw HTTP request received by the server.<br>
//&nbsp;&nbsp;http_reply - The raw HTTP reply to send in response.<br>
void AddUrlFrontend::HandleAddUrlFrontendRequest(<br>
&nbsp;&nbsp;&nbsp;&nbsp;const HTTPRequest* http_request, HTTPReply* http_reply) {<br>
&nbsp;&nbsp;// Extract the query parameters from the raw HTTP request.<br>
&nbsp;&nbsp;HTTPQueryParams query_params;<br>
&nbsp;&nbsp;ExtractHttpQueryParams(http_request, &amp;query_params);<br><br>
&nbsp;&nbsp;// Get the 'url' and 'comment' query components.<br>
&nbsp;&nbsp;// Default each to an empty string if they were not present<br>
&nbsp;&nbsp;// in http_request.<br>
&nbsp;&nbsp;string url =<br>
<a id="page_36"></a>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;query_params.GetQueryComponentDefault("url", "");<br>
&nbsp;&nbsp;string comment =<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;query_params.GetQueryComponentDefault("comment", "");<br><br>
&nbsp;&nbsp;// Prepare the request to the AddUrlService backend.<br>
&nbsp;&nbsp;AddUrlRequest add_url_request;<br>
&nbsp;&nbsp;AddUrlReply add_url_reply;<br>
&nbsp;&nbsp;add_url_request.set_url(url);<br>
&nbsp;&nbsp;if (!comment.empty()) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;add_url_request.set_comment(comment);<br>
&nbsp;&nbsp;}<br><br>
&nbsp;&nbsp;// Issue the request to the AddUrlService backend.<br>
&nbsp;&nbsp;RPC rpc;<br>
&nbsp;&nbsp;add_url_service_-&gt;AddUrl(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;rpc, &amp;add_url_request, &amp;add_url_reply);<br><br>
&nbsp;&nbsp;// Block until the reply is received from the<br>
&nbsp;&nbsp;// AddUrlService backend.<br>
&nbsp;&nbsp;rpc.Wait();<br><br>
&nbsp;&nbsp;// Handle errors, if any:<br>
&nbsp;&nbsp;if (add_url_reply.has_error_code()) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;WriteHttpReplyWithErrorDetails(http_reply, add_url_reply);<br>
&nbsp;&nbsp;} else {<br>
&nbsp;&nbsp;&nbsp;&nbsp;// No errors. Send HTTP 200 OK response to client.<br>
&nbsp;&nbsp;&nbsp;&nbsp;WriteHttp200Reply(http_reply);<br>
&nbsp;&nbsp;}<br>
}</p>
<p><code>HandleAddUrlFrontendRequest</code> is a busy member function. This is the nature of many web handlers. The developer can choose to simplify this function by extracting some of its functionality into helper functions. However, such refactoring before the build is stable, unit tests are in place, and unit tests are passing is unusual.</p>
<p>At this point, the developer modifies the existing build specification for the addurl project, adding an entry for the <code>addurl_frontend</code> library. This creates a static C++ library for <code>AddUrlFrontend</code> when built.</p>
<p class="programlisting"><span class="em">File: /depot/addurl/BUILD</span><br>
# From before:<br>
proto_library(name="addurl",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srcs=["addurl.proto"])<br><br>
# New:<br>
cc_library(name="addurl_frontend",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srcs=["addurl_frontend.cc"],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deps=[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"path/to/httpqueryparams",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"other_http_server_stuff",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;":addurl", # Link against the addurl library above.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;])</p>
<p>The developer starts his build tools again, fixing compiler and linker errors in addurl_frontend.h and addurl_frontend.cc until everything builds and links cleanly without warnings or errors. At this point, it’s time to write unit tests for <code>AddUrlFrontend</code>. These are written in a new file, addurl_frontend_test.cc. This test defines a fake of the <code>AddUrlService</code> backend and leverages the <code>AddUrlFrontend</code> constructor to inject this fake at test time. In this way, the developer is able to inject expectations and errors into the workflow of <code>AddUrlFrontend</code> without modification of the <code>AddUrlFrontend</code> code itself.</p>
<p class="programlisting"><a id="page_37"></a><span class="em">File: depot/addurl/addurl_frontend_test.cc</span><br>
#include "addurl/addurl.pb.h"<br>
#include "addurl/addurl_frontend.h"<br><br>
// See http://code.google.com/p/googletest/<br>
#include "path/to/googletest.h"<br><br>
// Defines a fake AddUrlService, which will be injected by<br>
// the AddUrlFrontendTest test fixture into AddUrlFrontend<br>
// instances under test.<br>
class FakeAddUrlService : public AddUrlService {<br>
&nbsp;public:<br>
&nbsp;&nbsp;FakeAddUrlService()<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: has_request_expectations_(false),<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;error_code_(0) {<br>
&nbsp;&nbsp;}<br><br>
&nbsp;// Allows tests to set expectations on requests.<br>
&nbsp;void set_expected_url(const string&amp; url) {<br>
&nbsp;&nbsp;&nbsp;expected_url_ = url;<br>
&nbsp;&nbsp;&nbsp;has_request_expectations_ = true;<br>
&nbsp;}<br>
&nbsp;void set_expected_comment(const string&amp; comment) {<br>
&nbsp;&nbsp;&nbsp;expected_comment_ = comment;<br>
&nbsp;&nbsp;&nbsp;has_request_expectations_ = true;<br>
&nbsp;}<br><br>
&nbsp;// Allows for injection of errors by tests.<br>
&nbsp;void set_error_code(int error_code) {<br>
&nbsp;&nbsp;&nbsp;error_code_ = error_code;<br>
&nbsp;}<br>
&nbsp;void set_error_details(const string&amp; error_details) {<br>
&nbsp;&nbsp;&nbsp;error_details_ = error_details;<br>
&nbsp;}<br><br>
&nbsp;// Overrides of the AddUrlService::AddUrl method generated from<br>
&nbsp;// service definition in addurl.proto by the Protocol Buffer<br>
&nbsp;// compiler.<br>
&nbsp;virtual void AddUrl(RPC* rpc,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const AddUrlRequest* request,<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;AddUrlReply* reply) {<br>
&nbsp;&nbsp;&nbsp;// Enforce expectations on request (if present).<br>
&nbsp;&nbsp;&nbsp;if (has_request_expectations_) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_EQ(expected_url_, request-&gt;url());<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EXPECT_EQ(expected_comment_, request-&gt;comment());<br>
&nbsp;&nbsp;&nbsp;}<br><br>
&nbsp;&nbsp;&nbsp;// Inject errors specified in the set_* methods above if present.<br>
&nbsp;&nbsp;&nbsp;if (error_code_ != 0 || !error_details_.empty()) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reply-&gt;set_error_code(error_code_);<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reply-&gt;set_error_details(error_details_);<br>
&nbsp;&nbsp;&nbsp;}<br>
&nbsp;}<br><br>
&nbsp;private:<br>
&nbsp;&nbsp;// Expected request information.<br>
&nbsp;&nbsp;// Clients set using set_expected_* methods.<br>
&nbsp;&nbsp;string expected_url_;<br>
&nbsp;&nbsp;string expected_comment_;<br>
&nbsp;&nbsp;bool has_request_expectations_;<br><br>
&nbsp;&nbsp;// Injected error information.<br>
&nbsp;&nbsp;// Clients set using set_* methods above.<br>
&nbsp;&nbsp;int error_code_;<br>
&nbsp;&nbsp;string error_details_;<br>
};<br><br>
// The test fixture for AddUrlFrontend. It is code shared by the<br>
// TEST_F test definitions below. For every test using this<br>
<a id="page_38"></a>// fixture, the fixture will create a FakeAddUrlService, an<br>
// AddUrlFrontend, and inject the FakeAddUrlService into that<br>
// AddUrlFrontend. Tests will have access to both of these<br>
// objects at runtime.<br>
class AddurlFrontendTest : public ::testing::Test {<br>
&nbsp;protected:<br>
&nbsp;&nbsp;// Runs before every test method is executed.<br>
&nbsp;&nbsp;virtual void SetUp() {<br>
&nbsp;&nbsp;&nbsp;&nbsp;// Create a FakeAddUrlService for injection.<br>
&nbsp;&nbsp;&nbsp;&nbsp;fake_add_url_service_.reset(new FakeAddUrlService);<br><br>
&nbsp;&nbsp;&nbsp;&nbsp;// Create an AddUrlFrontend and inject our FakeAddUrlService<br>
&nbsp;&nbsp;&nbsp;&nbsp;// into it.<br>
&nbsp;&nbsp;&nbsp;&nbsp;add_url_frontend_.reset(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;new AddUrlFrontend(fake_add_url_service_.get()));<br>
&nbsp;&nbsp;}<br><br>
&nbsp;&nbsp;scoped_ptr&lt;FakeAddUrlService&gt; fake_add_url_service_;<br>
&nbsp;&nbsp;scoped_ptr&lt;AddUrlFrontend&gt; add_url_frontend_;<br>
};<br><br>
// Test that AddurlFrontendTest::SetUp works.<br>
TEST_F(AddurlFrontendTest, FixtureTest) {<br>
&nbsp;&nbsp;// AddurlFrontendTest::SetUp was invoked by this point.<br>
}<br><br>
// Test that AddUrlFrontend parses URLs correctly from its<br>
// query parameters.<br>
TEST_F(AddurlFrontendTest, ParsesUrlCorrectly) {<br>
&nbsp;&nbsp;HTTPRequest http_request;<br>
&nbsp;&nbsp;HTTPReply http_reply;<br><br>
&nbsp;&nbsp;// Configure the request to go to the /addurl resource and<br>
&nbsp;&nbsp;// to contain a 'url' query parameter.<br>
&nbsp;&nbsp;http_request.set_text(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"GET /addurl?url=http://www.foo.com HTTP/1.1\r\n\r\n");<br><br>
&nbsp;&nbsp;// Tell the FakeAddUrlService to expect to receive a URL<br>
&nbsp;&nbsp;// of 'http://www.foo.com'.<br>
&nbsp;&nbsp;fake_add_url_service_-&gt;set_expected_url("http://www.foo.com");<br><br>
&nbsp;&nbsp;// Send the request to AddUrlFrontend, which should dispatch<br>
&nbsp;&nbsp;// a request to the FakeAddUrlService.<br>
&nbsp;&nbsp;add_url_frontend_-&gt;HandleAddUrlFrontendRequest(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;http_request, &amp;http_reply);<br><br>
&nbsp;&nbsp;// Validate the response.<br>
&nbsp;&nbsp;EXPECT_STREQ("200 OK", http_reply.text());<br>
}<br><br>
// Test that AddUrlFrontend parses comments correctly from its<br>
// query parameters.<br>
TEST_F(AddurlFrontendTest, ParsesCommentCorrectly) {<br>
&nbsp;&nbsp;HTTPRequest http_request;<br>
&nbsp;&nbsp;HTTPReply http_reply;<br><br>
&nbsp;&nbsp;// Configure the request to go to the /addurl resource and<br>
&nbsp;&nbsp;// to contain a 'url' query parameter and to also contain<br>
&nbsp;&nbsp;// a 'comment' query parameter that contains the<br>
&nbsp;&nbsp;// url-encoded query string 'Test comment'.<br>
&nbsp;&nbsp;http_request.set_text("GET /addurl?url=http://www.foo.com"<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"&amp;comment=Test+comment HTTP/1.1\r\n\r\n");<br><br>
&nbsp;&nbsp;// Tell the FakeAddUrlService to expect to receive a URL<br>
&nbsp;&nbsp;// of 'http://www.foo.com' again.<br>
&nbsp;&nbsp;fake_add_url_service_-&gt;set_expected_url("http://www.foo.com");<br><br>
&nbsp;&nbsp;// Tell the FakeAddUrlService to also expect to receive a<br>
&nbsp;&nbsp;// comment of 'Test comment' this time.<br>
&nbsp;&nbsp;fake_add_url_service_-&gt;set_expected_comment("Test comment");<br><br>
<a id="page_39"></a>&nbsp;&nbsp;// Send the request to AddUrlFrontend, which should dispatch<br>
&nbsp;&nbsp;// a request to the FakeAddUrlService.<br>
&nbsp;&nbsp;add_url_frontend_-&gt;HandleAddUrlFrontendRequest(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;http_request, &amp;http_reply);<br><br>
&nbsp;&nbsp;// Validate that the response received is a '200 OK' response.<br>
&nbsp;&nbsp;EXPECT_STREQ("200 OK", http_reply.text());<br>
}<br><br>
// Test that AddUrlFrontend sends proper error information when<br>
// the AddUrlService encounters a client error.<br>
TEST_F(AddurlFrontendTest, HandlesBackendClientErrors) {<br>
&nbsp;&nbsp;HTTPRequest http_request;<br>
&nbsp;&nbsp;HTTPReply http_reply;<br><br>
&nbsp;&nbsp;// Configure the request to go to the /addurl resource.<br>
&nbsp;&nbsp;http_request.set_text("GET /addurl HTTP/1.1\r\n\r\n");<br><br>
&nbsp;&nbsp;// Configure the FakeAddUrlService to inject a client error with<br>
&nbsp;&nbsp;// error_code 400 and error_details of 'Client Error'.<br>
&nbsp;&nbsp;fake_add_url_service_-&gt;set_error_code(400);<br>
&nbsp;&nbsp;fake_add_url_service_-&gt;set_error_details("Client Error");<br><br>
&nbsp;&nbsp;// Send the request to AddUrlFrontend, which should dispatch<br>
&nbsp;&nbsp;// a request to the FakeAddUrlService.<br>
&nbsp;&nbsp;add_url_frontend_-&gt;HandleAddUrlFrontendRequest(<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;http_request, &amp;http_reply);<br><br>
&nbsp;&nbsp;// Validate that the response contained a 400 client error.<br>
&nbsp;&nbsp;EXPECT_STREQ("400\r\nError Details: Client Error",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;http_reply.text());<br>
}</p>
<p>The developer would likely write many more tests than this, but this is enough to demonstrate the common patterns of defining a fake, injecting that fake into a system under test, and using that fake in tests to inject errors and validation logic into the workflow of a system under test. One notable test missing here is one that would mimic a network timeout between the <code>AddUrlFrontend</code> and the <code>FakeAddUrlService</code> backend. Such a test would reveal that our developer forgot to check for and handle the condition where a timeout occurred.</p>
<p>Agile testing veterans will point out that everything done by <code>FakeAddUrlService</code> was simple enough that a mock could have been used instead. These veterans would be correct. We implement these features via a fake purely for illustrative purposes.</p>
<p>Anyhow, our developer now wants to run these tests. To do so, he must first update his build definitions to include a new test rule that defines the <code>addurl_frontend_test</code> test binary.</p>
<p class="programlisting"><span class="em">File: depot/addurl/BUILD</span><br>
# From before:<br>
proto_library(name="addurl",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srcs=["addurl.proto"])<br><br>
# Also from before:<br>
cc_library(name="addurl_frontend",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srcs=["addurl_frontend.cc"],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deps=[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"path/to/httpqueryparams",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"other_http_server_stuff",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;":addurl", # Depends on the proto_library above.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;])<br><br>
<a id="page_40"></a># New:<br>
cc_test(name="addurl_frontend_test",<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;size="small", # See section on Test Sizes.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;srcs=["addurl_frontend_test.cc"],<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;deps=[<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;":addurl_frontend", # Depends on library above.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"path/to/googletest_main"])</p>
<p>Once again, the developer uses his build tools to compile and run the <code>addurl_frontend_test</code> binary, fixing any compiler and linker errors uncovered by the build tools and this time also fixing the tests, test fixtures, fakes, and/or <code>AddUrlFrontend</code> itself based on any test failures that occur. This process starts immediately after defining the previous <code>FixtureTest</code>, and is repeated as the remaining test cases are added one at a time. When all of the tests are in place and passing, the developer creates a CL that contains all of these files, fixes any small issues caught by presubmit checks, sends that CL out for review, and then moves on to the next task (likely writing a real <code>AddUrlService</code> backend) while waiting for review feedback.</p>
<p class="programlisting">$ create_cl BUILD \<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addurl.proto \<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addurl_frontend.h \<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addurl_frontend.cc \<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addurl_frontend_test.cc<br><br>
$ mail_cl -m reviewer@google.com</p>
<p>When review feedback arrives, the developer makes the appropriate changes (or works with the reviewer to agree on an alternative), potentially undergoes additional review, and then submits the CL to the version control system. From this point on, whenever someone makes changes to any of the code in these files, Google’s test automation systems know to run the <code>addurl_frontend_test</code> to verify that those changes did not break the existing tests. Additionally, anyone seeking to modify addurl_frontend.cc has <code>addurl_frontend_test</code> as a safety net to run while making their modifications.</p>
<h4 id="ch02sec2lev10">Test Execution</h4>
<p>Test automation goes beyond writing individual test programs. If we consider what it takes to be useful, we have to include compiling test programs, executing them, and analyzing, storing, and reporting the results of each execution as part of the automated testing challenge. Test automation is in effect an entire software development effort in its own right.</p>
<p>Having to worry about all these issues distracts engineers from concentrating on writing the right automation and making it useful for their projects. Test code is only useful in the context of being executable in a way that accelerates development and doesn’t slow it down. Thus, it has to be integrated into the actual development process in a way that makes it part of development and not separate from it. Functional code never exists in a vacuum. Neither should test code.</p>
<p>Thus, a common infrastructure that performs the compilation, execution, analysis, storage, and reporting of tests has evolved, reducing the <a id="page_41"></a>problem back to where we want it to be: Google engineers writing individual test programs and submitting them to this common infrastructure to handle the execution details and ensuring that the test code gets the same treatment as functional code.</p>
<p>After an SET writes a new test program, he creates a build specification of that test for the Google build infrastructure. A test build specification includes the name of the test, the source files from which it is built, its dependencies on any libraries or data, and finally a test size. Every test must specify its size as either small, medium, large, or enormous. After the code and build specifications for a test are in place, Google’s build tools and test execution infrastructure take care of the rest. From that moment forward, a single command initiates a build, runs the automation, and provides views for the results of that test.</p>
<p>Google’s test execution infrastructure places constraints on how tests are written. These constraints and how we manage them are described in the following section.</p>
<h4 id="ch02sec2lev11">Test Size Definitions</h4>
<p>As Google grew and new employees were hired, a confusing nomenclature of types of tests persisted: Unit tests, code-based tests, white box tests, integration tests, system tests, and end-to-end tests all add different levels of granularity, as shown in <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02fig01">Figure 2.1</a>. Early on, it was decided enough is enough, so we created a standard set of names.</p>
<div class="image"><a id="ch02fig01"></a><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02fig01.jpg" alt="image" width="736" height="569" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02fig01.jpg"></div>
<p class="caption"><strong>Figure 2.1 Google employs many different types of test execution.</strong></p>
<p><a id="page_42"></a><em>Small tests</em> verify the behavior of a single unit of code generally isolated from its environment. Examples include a single class or a small group of related functions. Small tests should have no external dependencies. Outside of Google, small tests are commonly known as “unit tests.”</p>
<p>Small tests have the narrowest scope of any of the test categories and focus on a function operating in isolation, as depicted in <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02fig02">Figure 2.2</a>. This limited scope enables small tests to provide comprehensive coverage of low-level code in a way that larger tests cannot.</p>
<div class="image"><a id="ch02fig02"></a><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02fig02.jpg" alt="image" width="300" height="363" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02fig02.jpg"></div>
<p class="caption"><strong>Figure 2.2 Illustration of the scope of a small test where often only a single function is involved.</strong></p>
<p>Within small tests, external services such as file systems, networks, and databases <em>must</em> be mocked or faked. Where appropriate, mocking of internal services within the same module as the class under test is also encouraged to further reduce any external dependencies.</p>
<p>Isolated scope and absence of external dependencies mean that small tests can be run quickly; therefore, they are executed frequently, leading to quicker discovery of bugs. The general idea is that as developers execute these tests and as they modify functional code, they also maintain the small tests for that code. Isolation can also enable shorter build and execution times for tests.</p>
<p><a id="page_43"></a><em>Medium tests</em> validate the interaction of one or more application modules, as depicted in <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02fig03">Figure 2.3</a>. Larger scopes and longer running times differentiate medium tests from small tests. Whereas small tests might attempt to exercise all of a single function’s code, medium tests are aimed at testing interaction across a limited subset of modules. Outside of Google, medium tests are often called “integration tests.”</p>
<div class="image"><a id="ch02fig03"></a><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02fig03.jpg" alt="image" width="350" height="442" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02fig03.jpg"></div>
<p class="caption"><strong>Figure 2.3 Medium tests include multiple modules and can include external data sources.</strong></p>
<p>The longer running times of medium tests require test execution infrastructure to manage them and they often do not execute as frequently as smaller tests. Medium tests are generally organized and executed by SETs.</p>
<div class="note1"><hr>
<p class="note">Note</p>
<p class="notepara">Small tests verify the behavior of a single unit of code. Medium tests validate the interaction of one or more units of code. Large tests verify that the system works as a whole.</p>
<hr></div>
<p>Mocking external services for medium tests is encouraged but not required, unless performance considerations mandate mocking. Lightweight fakes, such as in-memory databases, can be used to improve performance where true mocking might not be immediately practical.</p>
<p><a id="page_44"></a><em>Large</em> and <em>enormous tests</em> are commonly referred to as “system tests” or “end-to-end tests” outside of Google. Large tests operate on a high level and verify that the application as a whole works. These tests are expected to exercise any or all application subsystems from the UI down to backend data storage, as shown in <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02fig04">Figure 2.4</a>, and might make use of external resources such as databases, file systems, and network services.</p>
<div class="image"><a id="ch02fig04"></a><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02fig04.jpg" alt="image" width="350" height="459" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02fig04.jpg"></div>
<p class="caption"><strong>Figure 2.4 Large and enormous tests include modules that encompass end-to-end execution.</strong></p>
<h4 id="ch02sec2lev12">Use of Test Sizes in Shared Infrastructure</h4>
<p>Automation of test execution can be a difficult service to provide in a universal way. For a large engineering organization to share common test execution infrastructure, that infrastructure must support execution of a variety of testing jobs.</p>
<p><a id="page_45"></a>Some common jobs that share Google test execution infrastructure are</p>
<p class="indenthangingB">• A developer compiles and runs a small test and would like to get the results immediately.</p>
<p class="indenthangingB">• A developer would like to run all the small tests for a project and get the results quickly.</p>
<p class="indenthangingB">• A developer would like to compile and run only the tests in a project that are impacted by a pending change and get the results immediately.</p>
<p class="indenthangingB">• An engineer would like to collect code coverage for a project and view the results.</p>
<p class="indenthangingB">• A team would like to run all small tests for a project for every CL submitted and distribute the results for review within the team.</p>
<p class="indenthangingB">• A team would like to run all tests for a project after a CL is committed to the version control system.</p>
<p class="indenthangingB">• A team would like to collect code coverage results weekly and track progress over time.</p>
<p>There might be times when all of the previous jobs are submitted to Google’s test execution system simultaneously. Some of these tests might hog resources, bogging down shared machines for hours at a time. Others might take only milliseconds to run and could be run in parallel with hundreds of other tests on a single shared machine. When each test is labeled as small, medium, or large, it makes it easier to schedule the jobs because the scheduler has an idea of how long a job will take to run, thus it can optimize the job queue to good effect.</p>
<p>Google’s test execution system uses test sizes to distinguish fast jobs from slower ones. Test sizes guarantee an upper bound on each test’s execution time, as described in <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02tab01">Table 2.1</a>. Test sizes also imply the potential resource needs of a test, as described in <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02tab02">Table 2.2</a>. Google’s test execution system cancels execution and reports a failure for any test that exceeds the time or resource requirements associated with its test size. This forces engineers to provide appropriate test size labels. Accurate test sizing enables Google’s test execution system to make smart scheduling decisions.</p>
<p class="caption1"><a id="ch02tab01"></a><strong>Table 2.1 Goals and Limits of Test Execution Time by Test Size</strong></p>
<div class="image"><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02tab01.jpg" alt="image" width="750" height="157" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02tab01.jpg"></div>
<p class="caption1"><a id="page_46"></a><a id="ch02tab02"></a><strong>Table 2.2 Resource Usage by Test Size</strong></p>
<div class="image"><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02tab02.jpg" alt="image" width="700" height="257" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02tab02.jpg"></div>
<h4 id="ch02sec2lev13">Benefits of Test Sizes</h4>
<p>Each test size offers its own set of benefits. <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02fig05">Figure 2.5</a> summarizes these benefits. The benefits and weaknesses of each test size are listed for comparison.</p>
<div class="image"><a id="ch02fig05"></a><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02fig05.jpg" alt="image" width="400" height="227" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02fig05.jpg"></div>
<p class="caption"><strong>Figure 2.5 Limitations of various test sizes.</strong></p>
<h5 id="ch02sec3lev1">Large Tests</h5>
<p>The benefits and weaknesses of large tests include the following:</p>
<p class="indenthangingB">• Test what is ultimately most important: how the application works. Account for the behavior of external subsystems.</p>
<p class="indenthangingB">• They can be nondeterministic because of dependencies on external systems.</p>
<p class="indenthangingB">• Broad scope means that when tests fail, the cause might be difficult to find.</p>
<p class="indenthangingB">• The data setup for testing scenarios can be time-consuming.</p>
<p class="indenthangingB">• A high level of operation often makes it impractical to exercise specific corner cases. That’s what small tests are for.</p>
<h5 id="ch02sec3lev2"><a id="page_47"></a>Medium Tests</h5>
<p>The benefits and weaknesses of medium tests include the following:</p>
<p class="indenthangingB">• With looser mocking requirements and runtime limitations, provide development groups a stepping stone they can use to move from large tests toward small tests.</p>
<p class="indenthangingB">• They run relatively fast, so developers can run them frequently.</p>
<p class="indenthangingB">• They run in a standard developer environment, so developers can run them easily.</p>
<p class="indenthangingB">• Account for the behavior of external subsystems.</p>
<p class="indenthangingB">• They can be nondeterministic because of dependencies on external systems.</p>
<p class="indenthangingB">• They are not as fast as small tests.</p>
<h5 id="ch02sec3lev3">Small Tests</h5>
<p>The benefits and weaknesses of small tests include the following:</p>
<p class="indenthangingB">• Lead to cleaner code because methods must be relatively small and tightly focused to be easily tested; mocking requirements lead to well-defined interfaces between subsystems.</p>
<p class="indenthangingB">• Because they run quickly, they can catch bugs early and provide immediate feedback when code changes are made.</p>
<p class="indenthangingB">• They run reliably in all environments.</p>
<p class="indenthangingB">• They have a tighter scope, which allows for easier testing of edge cases and error conditions, such as null pointers.</p>
<p class="indenthangingB">• They have focused scope, which makes isolation of errors very easy.</p>
<p class="indenthangingB">• Don’t exercise integration between modules. That’s what the other test categories do.</p>
<p class="indenthangingB">• Mocking subsystems can sometimes be challenging.</p>
<p class="indenthangingB">• Mock or fake environments can get out of sync with reality.</p>
<p>Small tests lead to code quality, good exception handling, and good error reporting, whereas larger tests lead to overall product quality and data validation. No single test size in isolation can solve all of a project’s testing needs. For this reason, projects at Google are encouraged to maintain a healthy mixture of test sizes among their various test suites. It is considered just as wrong to perform all automation through a large end-to-end testing framework as it is to provide only small unit tests for a project.</p>
<div class="note1"><hr>
<p class="note">Note</p>
<p class="notepara">Small tests lead to code quality. Medium and large tests lead to product quality.</p>
<hr></div>
<p><a id="page_48"></a>Code coverage is a great tool for measuring whether a project’s tests have a healthy mixture of small, medium, and large tests. A project can create a coverage report running only its small tests and another report running only its medium and large tests. Each report should show an acceptable amount of coverage for the project in isolation. If medium and large tests produce only 20 percent code coverage in isolation, while small tests provide nearly 100 percent coverage, the project is likely lacking in evidence that the system works end-to-end. If the numbers were reversed, it would likely be hard to maintain or extend the project without spending a lot of time debugging. Google engineers are able to create and view these coverage reports on-the-fly using the same tools they use to build and run their tests by specifying an additional command-line flag. Coverage reports are stored in the cloud and can be viewed internally in any web browser by any engineer.</p>
<p>Google spans many types of projects, many with very different testing needs so the exact ratios of small-to-medium-to-large tests are left up to the teams—this is not prescribed. The general rule of thumb is to start with a rule of 70/20/10: 70 percent of tests should be small, 20 percent medium, and 10 percent large. If projects are user-facing, have a high degree of integration, or complex user interfaces, they should have more medium and large tests. Infrastructure or data-focused projects such as indexing or crawling have a very large number of small tests and far fewer medium or large tests.</p>
<p>Another internal tool we use for monitoring test coverage is Harvester. Harvester is a visualization tool that tracks all of a project’s CLs and graphs things such as the ratio of test code to new code in individual CLs; the sizes of changes; frequency of changes over time and by date; changes by developer, and others. Its purpose is to give a general sense of how a project’stesting changes over time.</p>
<h4 id="ch02sec2lev14">Test Runtime Requirements</h4>
<p>Whatever a test’s size, Google’s test execution system requires the following behavior. It is, after all, a shared environment:</p>
<p class="indenthangingB">• Each test must be independent from other tests so that tests can be executed in any order.</p>
<p class="indenthangingB">• Tests must not have any persistent side effects. They must leave their environment exactly in the state when it started.</p>
<p>These requirements are simple enough to understand, but they can be tricky to abide by. Even if the test itself does its best to comply, the software under test might offend through the saving of data files or setting environment and configuration information. Fortunately, Google’s test execution environment provides a number of features to make compliance straightforward.</p>
<p><a id="page_49"></a>For the independence requirement, engineers can specify a flag when they execute their tests to randomize the order of test execution. This feature eventually catches order-related dependencies. However, “any order” means that concurrency is also a possibility. The test execution system might choose to execute two tests on the same machine. If those two tests each require exclusive access to system resources, one of them might fail. For example:</p>
<p class="indenthangingB">• Two tests want to bind to the same port number to exclusively receive network traffic.</p>
<p class="indenthangingB">• Two tests want to create a directory at the same path.</p>
<p class="indenthangingB">• One test wants to create and populate a database table while another test wants to drop that same table.</p>
<p>These sorts of collisions can cause failures not only for the offending test, but also for other tests running on the test execution system, even if those other tests play by the rules. The system has a way of catching these tests and notifying the owners of the test. By setting a flag, a test can be marked to run exclusively on a specific machine. However, exclusivity is only a temporary fix. Most often, tests or the software being tested must be rewritten to drop dependencies on singular resources. The following remedies solve these problems:</p>
<p class="indenthangingB">• Have each test request an unused port number from the test execution system, and have the software under test dynamically bind to that port number.</p>
<p class="indenthangingB">• Have each test create all directories and files under a temporary unique directory that is created for and assigned to it by the test execution system just prior to test execution and injected into the process’s environment.</p>
<p class="indenthangingB">• Have each test start its own database instance in a private, isolated environment based on directories and ports assigned to them by the test execution system.</p>
<p>The maintainers of Google’s test execution system went so far as to document their test execution environment fairly exhaustively. Their document is known as Google’s “Test Encyclopedia” and is the final answer on what resources are available to tests at runtime. The “Test Encyclopedia” reads like an IEEE RFC, using well-defined meanings of “must” and “shall.” It explains in detail the roles and responsibilities of tests, test executors, host systems, libc runtimes, file systems, and so on.</p>
<p>Most Google engineers have likely not found the need to read the “Test Encyclopedia” and instead learn from others or by trial and error as their tests fail to run properly, or through feedback during code reviews. Unbeknownst to them, it is the details expressed in that document that allowed a single shared test execution environment to serve the test execution needs of every Google project. Nor are those engineers aware that the “Test Encyclopedia” is the main reason that the behaviors of tests running in the shared execution environment exactly match the behaviors of tests <a id="page_50"></a>running on their personal workstations. The gory details of great platforms are invisible to those who use them. Everything just works!</p>
<div class="sidebar1"><hr>
<p class="sidebar2"><strong>Testing at the Speed and Scale of Google</strong> <em>by Pooja Gupta, Mark Ivey, and John Penix</em></p>
<p class="sidebarpara">Continuous integration systems play a crucial role in keeping software working while it is being developed. The basic steps most continuous integration systems follow are:</p>
<p class="indenthangingN1">1. Get the latest copy of the code.</p>
<p class="indenthangingN1">2. Run all tests.</p>
<p class="indenthangingN1">3. Report results.</p>
<p class="indenthangingN1">4. Repeat 1–3.</p>
<p class="sidebarpara">This works great while the codebase is small; code flux is reasonable and tests are fast. As a codebase grows over time, the efficiency of such a system decreases. As more code is added, each clean run takes much longer and more changes get crammed into a single run. If something breaks, finding and backing out the bad change is a tedious and error-prone task for development teams.</p>
<p class="sidebarpara">Software development at Google happens quickly and at scale. The Google codebase receives over 20 changes per minute and 50 percent of the files change every month! Each product is developed and released from “head” relying on automated tests verifying the product behavior. Release frequency varies from multiple times per day to once every few weeks, depending on the product team.</p>
<p class="sidebarpara">With such a huge, fast-moving codebase, it is possible for teams to get stuck spending a lot of time just keeping their build “green.” A continuous integration system should help by providing the <em>exact</em> change at which a test started failing, instead of a range of suspect changes or doing a lengthy binary search for the offending change. To find the exact change that broke a test, we can run every test at every change, but that would be very expensive.</p>
<p class="sidebarpara">To solve this problem, we built a continuous integration system (see <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02fig06">Figure 2.6</a>) that uses dependency analysis to determine all the tests a change transitively affects and then runs only those tests for every change. The system is built on top of Google’s cloud computing infrastructure, enabling many builds to be executed concurrently and allowing the system to run affected tests as soon as a change is submitted.</p>
<div class="image"><a id="ch02fig06"></a><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02fig06.jpg" alt="image" width="650" height="664" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02fig06.jpg"></div>
<p class="caption"><strong>Figure 2.6 A typical continuous integration system.</strong></p>
<p class="sidebarpara">Here is an example where our system can provide faster and more precise feedback than a traditional continuous build. In this scenario, there are two tests and three changes that affect these tests. The gmail_server_tests are broken by the second change; however, a typical continuous integration system will only be able to tell that either change #2 or change #3 caused this test to fail. By using concurrent builds, we can launch tests without waiting for the current build-test cycle to finish. Dependency analysis limits the number of tests executed for each change, so that in this example, the total number of test executions is the same as before.</p>
<p class="sidebarpara"><a id="page_51"></a>Our system uses dependencies from the build system rules that describe how code is compiled and data files are assembled to build applications and tests. These build rules have clearly defined inputs and outputs that chain together to precisely describe what needs to happen during a build. Our system maintains an in-memory graph of these build dependencies (see <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02fig07">Figure 2.7</a>) and keeps it up to date with each change that gets checked in. This allows us to determine all tests that depend (directly or indirectly) on the code modified by a change, and hence, need to be re-run to know the current state of the build. Let’s walk through an example.</p>
<div class="image"><a id="page_52"></a><a id="ch02fig07"></a><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02fig07.jpg" alt="image" width="700" height="453" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02fig07.jpg"></div>
<p class="caption"><strong>Figure 2.7 Example of build dependencies.</strong></p>
<p class="sidebarpara">We see how two isolated code changes, at different depths of the dependency tree, are analyzed to determine affected tests, that is the minimal set of tests that needs to be run to ensure that both Gmail and Buzz projects are “green.”</p>
<h4 class="h4a"><a id="ch02sec2lev16"></a>Case 1: Change in Common Library</h4>
<p class="sidebarpara">For first scenario, consider a change that modifies files in common_collections_util, as shown in <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02fig08">Figure 2.8</a>.</p>
<div class="image"><a id="ch02fig08"></a><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02fig08.jpg" alt="image" width="700" height="285" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02fig08.jpg"></div>
<p class="caption"><strong>Figure 2.8 Change in common_collections_util.h.</strong></p>
<p class="sidebarpara"><a id="page_53"></a>When this change is submitted, we follow the dependency edges back up the graph, eventually finding all tests that depend on it. When the search is complete (after a fraction of a second), we have all the tests that need to be run and can determine the projects that need to have their statuses updated based on results from these tests (see <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02fig09">Figure 2.9</a>).</p>
<div class="image"><a id="ch02fig09"></a><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02fig09.jpg" alt="image" width="750" height="308" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02fig09.jpg"></div>
<p class="caption"><strong>Figure 2.9 Tests affected by change.</strong></p>
<h4 class="h4a">Case 2: Change in a Dependent Project</h4>
<p class="sidebarpara">For the second scenario, we look at a change that modifies files in youtube_client (see <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02fig10">Figure 2.10</a>).</p>
<div class="image"><a id="ch02fig10"></a><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02fig10.jpg" alt="image" width="750" height="304" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02fig10.jpg"></div>
<p class="caption"><strong>Figure 2.10 Change in youtube_client.</strong></p>
<p class="sidebarpara">We perform the same analysis to conclude that only the buzz_client_tests are affected and the status of Buzz project needs to be updated (see <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02fig11">Figure 2.11</a>).</p>
<div class="image"><a id="page_54"></a><a id="ch02fig11"></a><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02fig11.jpg" alt="image" width="750" height="336" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02fig11.jpg"></div>
<p class="caption"><strong>Figure 2.11 Buzz needs updating.</strong></p>
<p class="sidebarpara">This example illustrates how we optimize the number of tests run per change without sacrificing the accuracy of end results for a project. Running fewer tests per change allows us to run all <em>affected</em> tests for every change that gets checked in, making it easier for a developer to detect and deal with an offending change.</p>
<p class="sidebarpara">Use of smart tools and cloud computing infrastructure in the continuous integration system makes it fast and reliable. While we are constantly working on making improvements to this system, thousands of Google projects are already using it to launch and iterate quickly, making faster user-visible progress.</p>
<hr></div>
<h3 id="ch02sec1lev2">Test Certified</h3>
<p>Patrick Copeland’s preface to this book underscores the difficulty in getting developers to participate in testing. Hiring highly technical testers was only step one. We still needed to get developers involved. One of the key ways we did this was by a program called Test Certified. In retrospect, the program was instrumental in getting the developer-testing culture ingrained at Google.</p>
<p>Test Certified started out as a contest. Can we get developers to take testing seriously if we make it a prestigious matter? If developers follow certain practices and achieve specific results, can we say they are “certified” and create a badge system (see <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#ch02fig12">Figure 2.12</a>) that provides some bragging rights?</p>
<div class="image"><a id="page_55"></a><a id="ch02fig12"></a><img src="https://www.safaribooksonline.com/library/view/how-google-tests/9780132851572/graphics/02fig12.jpg" alt="image" width="500" height="79" data-mfp-src="/library/view/how-google-tests/9780132851572/graphics/02fig12.jpg"></div>
<p class="caption"><strong>Figure 2.12 Test Certified badges appear on project wiki pages.</strong></p>
<p>Well, that’s Test Certified: a system of testing challenges that if a team completes earns the team a “certified” designation. Level 0 is the starting level for all teams. After a team shows a mastery of basic code hygiene practices, it reaches level 1 and then progresses through the levels, which end at 5 to match some external models such as capability maturity model.<sup><a id="ch02fn_13"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn13">13</a></sup></p>
<div class="sidebar1"><hr>
<p class="sidebar">Summary of Test Certified Levels</p>
<p class="sidebarpara"><strong>Level 1</strong></p>
<p class="indenthanging">Set up test coverage bundles.</p>
<p class="indenthanging">Set up a continuous build.</p>
<p class="indenthanging">Classify your tests as Small, Medium, and Large.</p>
<p class="indenthanging">Identify nondeterministic tests.</p>
<p class="indenthanging">Create a smoke test suite.</p>
<p class="sidebarpara"><strong>Level 2</strong></p>
<p class="indenthanging">No releases with red tests.</p>
<p class="indenthanging">Require a smoke test suite to pass before a submit.</p>
<p class="indenthanging">Incremental coverage by all tests &gt;= 50%.</p>
<p class="indenthanging">Incremental coverage by small tests &gt;= 10%.</p>
<p class="indenthanging">At least one feature tested by an integration test.</p>
<p class="sidebarpara"><strong>Level 3</strong></p>
<p class="indenthanging">Require tests for all nontrivial changes.</p>
<p class="indenthanging">Incremental coverage by small tests &gt;= 50%.</p>
<p class="indenthanging">New significant features are tested by integration tests.</p>
<p class="sidebarpara"><a id="page_56"></a><strong>Level 4</strong></p>
<p class="indenthanging">Automate running of smoke tests before submitting new code.</p>
<p class="indenthanging">Smoke tests should take less than 30 minutes to run.</p>
<p class="indenthanging">No nondeterministic tests.</p>
<p class="indenthanging">Total test coverage should be at least 40%.</p>
<p class="indenthanging">Test coverage from small tests alone should be at least 25%.</p>
<p class="indenthanging">All significant features are tested by integration tests.</p>
<p class="sidebarpara"><strong>Level 5</strong></p>
<p class="indenthanging">Add a test for each nontrivial bug fix.</p>
<p class="indenthanging">Actively use available analysis tools.</p>
<p class="indenthanging">Total test coverage should be at least 60%.</p>
<p class="indenthanging">Test coverage from small tests alone should be at least 40%.</p>
<hr></div>
<p>The program was piloted slowly with a few teams of testing-minded developers who were keen to improve their practices. After the kinks were worked out of the program, a big contest to get certified was held as a companywide push and adoption was brisk.</p>
<p>It wasn’t as hard a sell as one might think. The benefit to development teams was substantial:</p>
<p class="indenthangingB">• They got lots of attention from good testers who signed up to be Test Certified Mentors. In a culture where testing resources were scarce, signing up for this program got a product team far more testers than it ordinarily would have merited.</p>
<p class="indenthangingB">• They received guidance from experts and learned how to write better small tests.</p>
<p class="indenthangingB">• They understood which teams were doing a better job of testing and thus who to learn from.</p>
<p class="indenthangingB">• They were able to brag to the other teams that they were higher on the Test Certified scale!</p>
<p>After the companywide push, most teams were climbing the ladder and they were all aware of it. Development Directors with teams moving up the ladder were given good review feedback from Engineering Productivity leads and teams who scoffed at it did so at their own peril. Again, in a company where testing resources are hard to come by, what team would want <a id="page_57"></a>to alienate Engineering Productivity? Still it wasn’t all flowers and puppies. But we’ll let the people who ran the program tell the whole story.</p>
<h4 id="ch02sec2lev15">An Interview with the Founders of the Test Certified Program</h4>
<p class="blockquote"><em>The authors sat down with four Googlers who were instrumental in starting the Test Certified program. Mark Striebeck is a development manager for Gmail. Neal Norwitz is an SWE working on tools for developer velocity, Tracy Bialik and Russ Rufer are SETs who as nonmanagers are among the highest-leveled SETs in the company; both are staff-level engineers.</em></p>
<p><strong>HGTS</strong>: What are the origins of the Test Certified program? What problems did the original TC team try to solve? Are those the same problems that the program tries to solve today?</p>
<p><strong>Tracy</strong>: We wanted to change Google’s developer culture to include testing as part of every feature developer’s responsibility. They shared their positive experiences with testing and encouraged teams to write tests. Some teams were interested, but didn’t know how to start. Others would put “improve testing” on their team objectives and key results (OKRs),<sup><a id="ch02fn_14"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn14">14</a></sup> which isn’t always actionable. It was like putting “lose weight” on your New Year’s resolutions. That’s a fine, lofty goal, but if that’s all you say, don’t be surprised if it never happens.</p>
<p>Test Certified provided small, clear, actionable steps that teams could take. The first level is getting the basics in place: setting up automation for running tests and gathering test coverage, noting any nondeterministic tests, and making a smoke test suite (if the full test suite was long-running). Each level becomes more difficult, requiring more test maturity. Level 2 targets policies and getting started on improving incremental coverage. Level 3 focuses on testing newly written code. Level 4 focuses on testing of legacy code, which typically requires at least some refactoring for testability. Level 5 demands better overall coverage, writing tests for all bug fixes and using available static and dynamic analysis tools.</p>
<p>Now, all Googlers know that testing is a feature developer’s responsibility. So that problem has been solved. But we still have the problem of teams needing to take action to improve their testing maturity and capability, so Test Certified continues to serve that need.</p>
<p><strong>HGTS</strong>: What was the early feedback the Test Certified team received from the SWEs?</p>
<p><strong>Neal</strong>: That it’s too hard. They thought our goals were too lofty and many teams were struggling with the basics. We needed to make the levels correspond to work that could be accomplished in their spare time. Also there were issues around Google’s tools at the time and some of the things we were asking for <a id="page_58"></a>were just too advanced. It was really hard for folks to get started, so we had to think about providing them with some softballs to start the process and convince them they were making progress.</p>
<p><strong>Mark:</strong> Yes, we had to make several iterations downward. We tried to meet them halfway by being more realistic and making the runway toward eventual takeoff a lot longer. We didn’t mind increasing the runway but we still wanted escape velocity at some point. That’s how we ended up with the first step being “set up a continuous build, have some green builds, know your coverage.” It was a freebie, but it established some discipline and helped them get from 0 to 1 and put them in a position to want more.</p>
<p><strong>HGTS</strong>: Who was eager to adopt?</p>
<p><strong>Neal</strong>: It started with most of the people in the Testing Grouplet. This grouplet was meeting regularly and was comprised of the people who were the most enthusiastic about testing. We then branched out to other folks we knew. I think there were a ton of eager folks and that was a nice surprise. We generated more enthusiasm with ToTT<sup><a id="ch02fn_15"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn15">15</a></sup> and other activities that made testing look more fun or sexy: fixits,<sup><a id="ch02fn_16"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn16">16</a></sup> VP mass emails, posters, talks at TGIF, and so on.</p>
<p><strong>Mark</strong>: As soon as we reached out to other teams (and we had a bunch of teams who were interested), they realized that this will a) require some serious work, and b) that they don’t have the expertise. That made the beginning really frustrating.</p>
<p><strong>HGTS</strong>: Who was reluctant to adopt?</p>
<p><strong>Neal</strong>: Most projects. As I mentioned, it was perceived as too hard. We needed to scale back our initial ambitions. There were pretty much two sets of projects: those with no tests and those with really crappy tests. We needed to make it seem so simple that they could do many of the required testing tasks in an afternoon (and they really could with our help).</p>
<p><strong>Mark</strong>: Also, this was still the time when the value of testing and test automation wasn’t fully appreciated at Google. Not like it is today, not by a long shot. By far, most teams had the attitude that these are cute ideas, but that they had more important things to do (a.k.a. writing production code).</p>
<p><strong>HGTS</strong>: What hurdles did the team have to overcome to get its initial set of adopters?</p>
<p><strong>Neal</strong>: Inertia. Bad tests. No tests. Time. Testing was seen as someone else’s problem, be it another developer or a testing team. Who’s got time to test when you are writing all that code?</p>
<p><a id="page_59"></a><strong>Mark</strong>: Finding teams that were: a) interested enough, b) didn’t have too much of a legacy codebase problem, and c) had someone on the team who would be the testing champion (and who knew enough about testing). These were the three hurdles and we jumped them one at a time, team by team.</p>
<p><strong>HGTS</strong>: What pushed the Test Certified program into the mainstream? Was growth viral or linear?</p>
<p><strong>Russ:</strong> First there was a pilot that included teams that were especially friendly to testing and teams that the initial Test Certified instigators had close contacts with. We chose our early adopters well, basically the ones who had the best chance of succeeding.</p>
<p>At the point when we announced the “global launch” of Test Certified in mid-2007, there were 15 pilot teams at various rungs of the ladder. Just before the launch, we plastered the walls of every building in Mountain View, New York, and a few other offices with “TC Mystery” posters. Each poster had images representing several of the pilot teams, based on internal project names like Rubix, Bounty, Mondrian, and Red Tape. The only text on the posters said, “The future is now” and “This is big, don’t be left behind” with a link. We got a ton of hits on the link from puzzle-loving Googlers who wanted to see what the mystery was or simply to confirm their guesses. We also leveraged ToTT to advertise the new program and direct those readers to places they could get more information. It was a blitz of information.</p>
<p>That information included why Test Certified was important for teams and what kind of help they could get. It stressed that teams got a Test Certified Mentor and an “in” to a larger community of test expertise. We also offered teams two gifts for participation. First, a glowing build-status orb to show the team when tests on their (often new) continuous build passed (green) or failed (red). The second gift was a nifty Star Wars Potato Head kit. The so-called Darth Tater kit included three progressively larger units, and we awarded these to teams as they climbed higher on the Test Certified ladder. Teams displaying their orbs and potato heads helped build more curiosity and word of mouth about the program.</p>
<p>Testing Grouplet members were the early mentors and spokesmen for the project. As more teams joined, they often had enthusiastic engineers who helped create a buzz around Test Certified and acted as mentors for other teams.</p>
<p>As we each tried to convince more teams to join the program, we shared the best arguments with one another. Some teams joined because you could convince them the ladder steps and mentor availability would help their team improve this important area. Some teams felt they could improve either way, but were convinced the “official” levels would help them get credit for the work they were doing. Other teams were already very mature in their testing approach, but could be convinced to join as a signal to the rest of the company that they felt proper testing was important.</p>
<p>Several months in, with somewhere around 50 teams, a few enterprising members of our Test Engineering organization signed up to be Test Certified Mentors, which was the beginning of a stronger partnership between engineers from product teams and engineers from Engineering Productivity.</p>
<p><a id="page_60"></a>It was all very viral, very grass roots with a lot of one-on-one conversations. We went specifically to sell some teams. Other teams came to us.</p>
<p>About a year in, with over 100 Test Certified teams, it felt like new adoption was slowing. Bella Kazwell, who led this volunteer effort at the time, masterminded the Test Certified Challenge. A point system was developed that included activities like writing new tests, signing new teams into Test Certified, and teams improving testing practices or gaining TC levels. There were individual awards, and sites across the globe were also pitted against one another to earn the highest score. Volunteers were energized, and in turn this energized more teams across the company, re-accelerating adoption and attracting more volunteer mentors.</p>
<p>Teams in Test Certified had always used the ladder rungs and criteria as crisp, measurable team goals. By late 2008, there were areas in which some managers began to use these to evaluate teams under their purview, and where Engineering Productivity used a team’s progress against the TC ladder to gauge how serious they were about improving testing, and so how valuable it would be to invest time from the limited pool of test experts with a given team. In certain limited areas, it became a management expectation or launch criteria for teams to reach a level on the ladder.</p>
<p>Today, in 2011, new volunteer mentors continue to join, and new teams continue to sign up, and TC has presence across the company.</p>
<p><strong>HGTS</strong>: What changes did the Test Certified program undergo in its first couple of years? Did ladder requirements change? Did the mentoring system change? What adjustments were successful in improving the experience for participants?</p>
<p><strong>Tracy</strong>: The biggest change was the number of levels and some of the ladder requirements. We originally had four levels. Going from level 0 to level 1 was deliberately easy. Many teams were finding it difficult to move from level 1 to level 2, especially teams with legacy code that wasn’t testable. These teams became discouraged and were inclined to give up on Test Certified. We added a new level between 1 and 2 that was an easier step to take. We debated calling the new level 1.5, but decided to insert the new level as 2 and renumber the higher levels.</p>
<p>We also found that some of the requirements were too prescriptive, suggesting a ratio of small to medium to large tests that didn’t apply to all teams. When we added the new level, we also updated the criteria to include some “incremental coverage” numbers and remove the test size ratios.</p>
<p>The mentoring system is still in place, but we now have many teams who “self-mentor.” Because the culture of testing is more pervasive now, we have many teams who don’t need much advice; they just want to track their progress. For those teams, we don’t assign a mentor, but do provide a mailing list for answering their questions and for another pair of eyes to validate their level transitions.</p>
<p><strong>Russ</strong>: It’s also worth noting that from the beginning, we knew the Test Certified criteria had to be reasonably applied. Testing isn’t a cookie cutter activity and, occasionally, teams don’t fit the mold we had in mind when selecting the <a id="page_61"></a>criteria, or a typical tool for tracking test coverage or some other metric won’t work properly for a team. Each criterion had a rationale behind it, and we’ve been open at various points to customizing the criteria for teams that meet the spirit of that prescribed rationale.</p>
<p><strong>HGTS</strong>: What does a team stand to gain from participating in the Test Certified program today? What are the costs associated with participating?</p>
<p><strong>Tracy</strong>: Bragging rights. Clear steps. Outside help. A cool glowing orb. But the real gain for teams is improved testing.</p>
<p>The costs are minimal, beyond the team focusing on improving their testing maturity. We have a custom tool that allows mentors to track the team’s progress, checking off as each step is achieved. The data is displayed on a page that includes all teams by level, with the ability to click through and see details about a specific team.</p>
<p><strong>HGTS</strong>: Are there any steps on the ladder that seem to give teams more trouble than others?</p>
<p><strong>Tracy</strong>: The most difficult step is “require tests for all nontrivial changes.” For a greenfield project written in a testable way, this is easy. For a legacy project that wasn’t originally written with testing in mind, this can be tough. This might require writing a big end-to-end test and trying to force the system through particular code paths to exercise the behavior and then figuring out how to witness the result in an automated way. The better, but sometimes longer-term approach is refactoring the code to be more testable. Some teams with code that wasn’t written with testability in mind also find it challenging to provide enough of their test coverage, specifically from small, narrowly focused unit tests versus larger tests covering clusters of classes, or end-to-end tests.</p>
<p><strong>HGTS</strong>: Efforts at Google tend to last weeks or quarters, but Test Certified has been around for nearly five years and shows no signs of stopping soon. What contributed to Test Certified passing the test of time? What challenges does Test Certified face going forward?</p>
<p><strong>Russ</strong>: It has staying power because it’s not just an activity some individuals took part in; it’s a cultural change at the company. Together with the Testing Grouplet, ToTT, supporting mailing lists, tech talks, and contributions to job ladders and coding style documents, regular testing has become an expectation of all engineers across the company. Whether a team participates in Test Certified or not, it is expected to have a well considered automated testing strategy, either on its own or in partnership with a smaller population of engineers who act as testing experts.</p>
<p>It continues because it’s proven to work. We have very few areas left with even a small fraction of testing done manually, or thrown over the wall. To that end, Test Certified has done its job and this is likely to be its legacy even if the “official” grass-roots program was to end some day.</p>
<p><strong>HGTS</strong>: What tips would you give to engineers at other companies who are considering starting similar efforts in their organizations?</p>
<p><strong>Tracy</strong>: Start with teams that are already friendly to testing. Grow a kernel of teams that gain value from your program. Don’t be shy about evangelizing and <a id="page_62"></a>asking others to do so as well. The mentoring aspect was a big part of Test Certified’s success. When you ask a team to try something new or to improve, it’s going to be a lot smoother if they have a contact point into the larger community to ask for help. An engineer or a team might be embarrassed to ask what might be a stupid question on a mailing list, but they’ll feel a lot more comfortable asking that question of a single, trusted TC mentor.</p>
<p>Also find ways to make it fun. Come up with a better name that doesn’t include “certified,” as that can evoke pointy-haired bureaucrats. Or, do what we did, go with a pointy-haired name like “certified” and use it as a foil to constantly remind your larger community that it’s a bad name because you’re not “that kind of program.” Define steps small enough that teams can see and show their progress. Don’t get bogged down trying to create the perfect system with a perfect set of measurements. Nothing will ever be perfect for everyone. Agreeing on something reasonable and moving forward is important when the alternative is being paralyzed. Be flexible where it makes sense to be, but hold the line where you shouldn’t bend.</p>
<p>This concludes the chapter on the life of an SET. The remainder of the material is optional reading about how Google interviews SETs and an interview with Googler Ted Mao who talks about some of the tools Google SETs use.</p>
<h3 id="ch02sec1lev3">Interviewing SETs</h3>
<p>Successful SETs are good at everything: strong enough programmers to write feature code, strong enough testers to test about anything, and able to manage their own work and tools. Good SETs see both the forest and the trees—they can look at a small function prototype or API and imagine all the ways the underlying code can be used and how it can be broken.</p>
<p>All code at Google is in a single source tree, which means that any code can be used by anyone at anytime—so it better be solid. SETs not only find the bugs that the feature developers missed, but they also look to make sure it is obvious to other engineers how to leverage that code or component, and worry about future-proofing the functionality. Google moves fast, so the code must be clean, consistent, and work long after the original developer has stopped thinking about it.</p>
<p>How do we interview for this skill set and mentality? It’s not easy, but we’ve found hundreds of engineers who fit the bill. We look for a hybrid: a developer with a strong interest and aptitude in testing. A common and effective way to spot great SETs is to give them the same programming questions as we do for all developers and look for how they approach quality and testing. SETs have twice the opportunity to give a wrong answer in an interview!</p>
<p>Simple questions often identify the best SETs. Too much time wasted on tricky coding problems or insisting on functional correctness takes away <a id="page_63"></a>from time you should use to understand how the candidate thinks about coding and quality. There will be a SWE or SET on an interview loop who poses algorithm problems; the better SET interviewers focus on how the candidate <em>thinks</em> about the solution, not so much the elegance of the solution itself.</p>
<div class="note1"><hr>
<p class="note">Note</p>
<p class="notepara">SET interviewers focus on how the candidate <em>thinks</em> about the solution, not so much the elegance of the solution itself.</p>
<hr></div>
<p>Here’s an example. Pretend it is your first day on the job and you are asked to implement the function <code>acount(void* s);</code> that returns a count of the number of As in a string.</p>
<p>A candidate who dives directly into writing the code is sending a strong message: There is only one thing to do and I am doing it. That one thing is code. The life of an SET does not follow such a serialized view of the world. We want to hear questions.</p>
<p>What is this function used for? Why are we building it? Does the function prototype even look correct? We look for signs the candidate is worried about correctness and how to validate the right behaviors. A problem deserves to be treated with more respect! Candidates who mindlessly jump into coding problems will do the same with testing problems. If we pose a problem to add test variations to modules, we don’t want them to start listing tests until we tell them to stop; we want the best tests first.</p>
<p>An SET’s time is limited. We want candidates to take a step back and find the most efficient way to solve the problem, and the previous function definition can use some improvement. A good SET looks at a poorly defined API and turns it into something beautiful while testing it.</p>
<p>Decent candidates spend a few minutes understanding the specification by asking questions and making statements such as:</p>
<p class="indenthangingB">• What is the encoding of the incoming string: ASCII, UTF-8, or another?</p>
<p class="indenthangingB">• The function name is weak, should it be CamelCased, more descriptive, or are there other standard naming practices to be followed here?</p>
<p class="indenthangingB">• What is the return type? (Maybe the interviewer forgot, so I’ll add an int to the front of the function prototype.)</p>
<p class="indenthangingB">• That void* is dangerous. We should give it an appropriate type, such as char*, so we can benefit from compile-time type checking.</p>
<p class="indenthangingB">• What counts as an A? Should it count lowercase As, too?</p>
<p class="indenthangingB">• Doesn’t this function already exist in a standard library? (For the purpose of the interview, pretend you are the first one implementing this functionality.)</p>
<p><a id="page_64"></a>Better candidates will do even more:</p>
<p class="indenthangingB">• <strong>Think about scale:</strong> Maybe the return type should be a 64-bit integer because Google often deals with large amounts of data.</p>
<p class="indenthangingB">• <strong>Think about re-use:</strong> Why does this function count only As? It is probably a good idea to parameterize this so that an arbitrary character can be counted instead of having a different function defined for each one.</p>
<p class="indenthangingB">• <strong>Think about safety:</strong> Are these pointers coming from trusted sources?</p>
<p>The best candidates will:</p>
<p class="indenthangingB">• <strong>Think about scale:</strong></p>
<p class="indenthangingB1">• Is this function to be run as part of a MapReduce<sup><a id="ch02fn_17"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn17">17</a></sup> on sharded<sup><a id="ch02fn_18"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn18">18</a></sup> data? Maybe that’s the most useful form of calling this function. Are there issues to worry about in this scenario? Consider the performance and correctness implications of running this function on every document on the entire Internet.</p>
<p class="indenthangingB1">• If this subroutine is called for every Google query and would be called only with safe pointers because the wrapper does this validation already; maybe avoiding a null check will save hundreds of millions of CPU cycles a day and reduce user-visible latency by some small amount. At least understand the possible implications of full textbook parameter validation.</p>
<p class="indenthangingB">• <strong>Think about optimizations based on invariants:</strong></p>
<p class="indenthangingB1">• Can we assume the data coming in is already sorted? If so, we might be able to exit quickly after we find the first B.</p>
<p class="indenthangingB1">• What is the texture of the input data? Is it most often all As, is it most often a mix of all characters, or is it only As and spaces? If so, there may be optimizations in our comparison operations. When dealing with large data, even small, sublinear changes can be significant for actual compute latencies when the code executes.</p>
<p class="indenthangingB">• <strong>Think about safety:</strong></p>
<p class="indenthangingB1">• On many systems, and if this is a security-sensitive section of code, consider testing for more than just nonnull pointers; 1 is an invalid pointer value on some systems.</p>
<p class="indenthangingB1">• Add a length parameter to help ensure the code doesn’t walk off the end of the string. Check the length parameter’s value for sanity. Null-terminated character strings are a hacker’s best friend.</p>
<p class="indenthangingB1"><a id="page_65"></a>• If there is a possibility the buffer can be modified by some other thread while this function executes, there may be thread safety issues.</p>
<p class="indenthangingB1">• Should we be doing this check in a try/catch? Or, if the calling code isn’t expecting exceptions, we should probably return error codes to the caller. If there are error codes, are those codes well defined and documented? This shows thinking about the context of the larger code-base and runtime, and this kind of thinking can avoid errors of confusion or omission down the road.</p>
<p>Ultimately, the best candidates come up with a new angle for these questions. All angles are interesting to consider, if they are considered intelligently.</p>
<div class="note1"><hr>
<p class="note">Note</p>
<p class="notepara">A good SET candidate should not have to be told to test the code she writes. It should be an automatic part of her thinking.</p>
<hr></div>
<p>The key in all this questioning of the spec and the inputs is that any engineer who has passed an introductory programming course can produce basic functional code for this question. These questions and thinking from the candidates differentiate the best candidates from the decent ones. We do make sure that the candidate feels comfortable enough socially and culturally to ask questions, and if not, we prod them a bit to ask, making sure their straight-to-the-code behavior isn’t just because they are in an interview situation. Googlers should question most everything without being annoying and by still getting the problem solved.</p>
<p>It would be boring to walk through the myriad of possible correct implementations and all the common mistakes as this isn’t a programming or interviewing book. But, let’s show a simple and obvious implementation for discussion’s sake. Note: Candidates can usually use the language they are most comfortable with such as Java or Python, though that usually elicits some questions to ensure they understand things such as garbage collection, type–safety, compilation, and runtime concerns.</p>
<p class="programlisting">int64 Acount(const char* s) {<br>
&nbsp;&nbsp;if (!s) return 0;<br>
&nbsp;&nbsp;int64 count = 0;<br>
&nbsp;&nbsp;while (*s++) {<br>
&nbsp;&nbsp;&nbsp;&nbsp;if (*s == 'a') count++;<br>
&nbsp;&nbsp;}<br>
&nbsp;&nbsp;return count;<br>
}</p>
<p>Candidates should be able to walk through their code, showing the evolution of pointer and counter values as the code executes with test inputs.</p>
<p>In general, decent SET candidates will do the following:</p>
<p class="indenthangingB1"><a id="page_66"></a>• Have little trouble with the basics of coding this solution. When doing so, they do not have trouble rewriting or fumbling over basic syntax issues or mixing up syntax or keywords from different languages.</p>
<p class="indenthangingB1">• Show no sign of misunderstanding pointers or allocating anything unnecessarily.</p>
<p class="indenthangingB1">• Perform some input validation upfront to avoid pesky crashes from dereferencing null pointers and such, or have a good explanation of why they are not doing such parameter validation when asked.</p>
<p class="indenthangingB1">• Understand the runtime or Big O<sup><a id="ch02fn_19"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn19">19</a></sup> of their code. Anything other than linear here shows some creativity, but can be concerning.</p>
<p class="indenthangingB1">• If there are minor issues in the code, they can correct them when pointed out.</p>
<p class="indenthangingB1">• Produce code that is clear and easily readable by others. If they are using bitwise operators or put everything on one line, this is not a good sign, even if the code functionally works.</p>
<p class="indenthangingB1">• Walk through their code with a single test input of A or null.</p>
<p>Better candidates will do even more.</p>
<p class="indenthangingB1">• Consider int64 for counters and return type for future compatibility and avoiding overflow when someone inevitably uses this function to count As in an insanely long string.</p>
<p class="indenthangingB1">• Write code to shard/distribute the counting computation. Some candidates unfamiliar with MapReduce can come up with some simple variants on their own to decrease latency with parallel computation for large strings.</p>
<p class="indenthangingB1">• Write in assumptions and invariants in notes or comments in the code.</p>
<p class="indenthangingB1">• Walk through their code with many different inputs and fix every bug that they find. SET candidates who don’t spot and fix bugs are a warning sign.</p>
<p class="indenthangingB1">• Test their function before being asked. Testing should be something they don’t have to be told to do.</p>
<p class="indenthangingB1">• Continue trying to optimize the solution until asked to stop. No one can be sure that their code is perfect after just a few minutes of coding and applying a few test inputs. Some tenacity over correctness should be evident.</p>
<p>Now, we want to see if the candidate can test his own code. Convoluted or tricky test code is likely the worst test code in the world and definitely worse than no code. When tests fail at Google, it needs to be clear what the <a id="page_67"></a>test is doing. If not, engineers might disable, mark as flaky, or ignore the failures—it happens, and it’s the fault of the SETs and SWEs who wrote and reviewed the code for letting this bad test code into the tree.</p>
<p>SETs should be able to approach testing in a black box manner, operating under the assumption that someone else implemented the function, or in a white box manner, knowing which test cases might be irrelevant given the specifics of their implementation.</p>
<p>In general, decent candidates will do the following:</p>
<p class="indenthangingB1">• Are methodical and systematic. Supplying test data according to some identifiable characteristic (such as string size) and not just random strings.</p>
<p class="indenthangingB1">• Focus on generating interesting test data. Consider how to run large tests and where to get real-world test data.</p>
<p class="indenthangingB">• Better candidates:</p>
<p class="indenthangingB1">• Want to spin up concurrent threads executing this function to look for cross talk, deadlock, and memory leaks.</p>
<p class="indenthangingB1">• Build long running tests, such as spin up tests in a <code>while(true)</code> loop, and ensure they continue to work over the long haul.</p>
<p class="indenthangingB1">• Remain interested in coming up with test cases and interesting approaches to test data generation, validation, and execution.</p>
<div class="sidebar1"><hr>
<p class="sidebar2"><strong>Example of a Great Candidate</strong> <em>by Jason Arbon</em></p>
<p class="sidebarpara">One recent candidate (who has since proven to be amazing on the job) was asked how he would do boundary testing for a version of this API with 64-bit integers. He realized quickly that it wouldn’t be physically possible because of time and space constraints, but for the sake of completeness and curiosity when thinking about this level of scale, thought about how to host at least very large amounts of data for such a test and considered using Google’s index of the Web as input data.</p>
<p class="sidebarpara">How did he validate the answer? He suggested using a parallel implementation and making sure the two produced the same result. He also thought of a statistical sampling approach: What is the expected frequency of A in web pages, and because we know the number of pages indexed, the number computed should be close. This is a Google-like way to think about testing. Even if we don’t build these monster tests, thinking about these large solutions usually leads to more interesting or efficient solutions for normal-scale work.</p>
<hr></div>
<p>Another thing we interview for is “Googliness,” or culture fit. Is the SET candidate technically curious during the interview? When presented with some new ideas, can the candidate incorporate these into her solution? How does she handle ambiguity? Is she familiar with academic approaches to quality such as theorem proving? Does she understand measures of quality or automation in other fields such as civil or aerospace engineering? <a id="page_68"></a>Is she defensive about bugs you might find in her implementation? Does she think big? Candidates don’t have to be all of these things, but the more, the merrier! And, finally, would we like to work with this person on a daily basis?</p>
<p>It is important to note that if someone interviewing for an SET position isn’t that strong of a coder, it does not mean that she will not be a successful TE. Some of the best TEs we’ve ever hired originally interviewed for the SET position.</p>
<p>An interesting note about SET hiring at Google is that we often lose great candidates because they run into a nontesting SWE or an overly focused TE on their interview loop. We want this diversity in the folks interviewing SET candidates, because they will work together on the job, and SETs are really hybrids, but this can sometimes result in unfavorable interview scores. We want to make sure the bad scores come from interviewers who truly appreciate all aspects of what it takes to be a great SET.</p>
<p>As Pat Copeland says in his forward, there has been and still is a lot of diversity of opinion on SET hiring. Should an SET just be doing feature work if he is good at coding? SWEs are also hard to hire. Should they just be focusing on pure testing problems if they are that good at testing? The truth, as it often is, lies somewhere in the middle.</p>
<p>Getting good SET hires is a lot of trouble but it’s worth it. A single rock star SET can make a huge impact on a team.</p>
<h3 id="ch02sec1lev4">An Interview with Tool Developer Ted Mao</h3>
<p class="blockquote"><em>Ted Mao is a developer at Google but he’s a developer who has been exclusively focused on building test tools. Specifically, he’s building test tools for web applications that scale to handle everything Google builds internally. As such, he’s a well-known person in SET circles because an SET without good tools will find it hard to be effective. Ted is probably more familiar with the common web test infrastructure at Google than anyone in the company.</em></p>
<p><strong>HGTS</strong>: When did you start at Google, and what excited you about working here?</p>
<p><strong>Ted</strong>: I joined Google in June 2004. Back then, I only had experience working at large companies like IBM and Microsoft, and Google was the hot startup to work for and they were attracting a lot of talented engineers. Google was attempting to solve many interesting, challenging problems, and I wanted to work on these problems alongside some of the best engineers in the world.</p>
<p><strong>HGTS</strong>: You are the inventor of Buganizer,<sup><a id="ch02fn_20"></a><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/footnotes.html#ch02fn20">20</a></sup> Google’s bug database. What were the core things you were trying to accomplish with Buganizer versus the older BugDB?</p>
<p><a id="page_69"></a><strong>Ted</strong>: BugsDB was impeding our development process rather than supporting it. To be honest, it was wasting a lot of valuable engineering time and this was a tax paid by every team that used it. The issues manifested themselves in many ways, including UI latency, awkward workflows, and the practice of using “special” strings in unstructured text fields. In the process of designing Buganizer, we made sure that our data model and UI reflected our users’ actual development processes and that the system would be amenable to future extension both in the core product and through integrations.</p>
<p><strong>HGTS</strong>: Well you nailed Buganizer. It’s truly the best bug database any of us have ever used. How did you start working on web-testing automation, did you see the need or were you asked to solve a problem with test execution?</p>
<p><strong>Ted</strong>: While working on Buganizer, AdWords, and other products at Google, I consistently found that the web-testing infrastructure we had available was insufficient for my needs. It was never quite as fast, scalable, robust, or useful as I needed it to be. When the tools team announced that they were looking for someone to lead an effort in this area, I jumped on the opportunity to solve this problem. This effort became known as the Matrix project and I was the tech lead for it.</p>
<p><strong>HGTS</strong>: How many test executions and teams does Matrix support today?</p>
<p><strong>Ted</strong>: It really depends on how you measure test executions and teams. For example, one metric we use is what we call a “browser session”—every new browser session for a particular browser is guaranteed to start in the same state, and thus, a test running in the browser will behave deterministically insomuch as the test, browser, and operating system are deterministic. Matrix is used by practically every web frontend team at Google and provisions more than a million new browser sessions per day.</p>
<p><strong>HGTS</strong>: How many people worked on these two projects: Buganizer and Matrix?</p>
<p><strong>Ted</strong>: During their peak development periods, Buganizer had about five engineers and Matrix had four engineers. It’s always somewhat sad for me to think of what we might have been able to accomplish with a larger, more sustained development team, but I think we did a great job given what we had to work with.</p>
<p><strong>HGTS</strong>: What were the toughest technical challenges you faced while building these tools?</p>
<p><strong>Ted</strong>: I think that the toughest and often the most interesting challenges for me have always come at design time—understanding a problem space, weighing different solutions and their tradeoffs, and then making good decisions. Implementation is usually straightforward from that point. These types of decisions have to be made throughout the life of a project, and together with implementation, they can make or break the product.</p>
<p><strong>HGTS</strong>: What general advice would you give to other software engineers in the world who are working on testing tools?</p>
<p><strong>Ted</strong>: Focus on your users, understand their needs, and solve their problems. Don’t forget about “invisible” features like usability and speed. Engineers are <a id="page_70"></a>uniquely capable of solving their own problems—enable them to leverage your tools in ways you didn’t foresee.</p>
<p><strong>HGTS</strong>: What do you see as the next big or interesting problem to be solved in the test tools and infrastructure space?</p>
<p><strong>Ted</strong>: One problem I’ve been thinking about lately is how our tools are getting more complex and powerful, but consequently, harder to understand and use. For example, with our current web-testing infrastructure at Google, an engineer can execute one command to run thousands of web tests, in parallel, against multiple browsers. On one hand, it’s great that we’re abstracting away the details of how it all works—where those tests are actually running, where the browsers are coming from, how the test environment is configured, and so on. However, if the test fails and the engineer has to debug it, those details can be essential. We already have a few initiatives in this area, but there’s a lot more we could and should be doing.</p>
<h3 id="ch02sec1lev5">An Interview with Web Driver Creator Simon Stewart</h3>
<p class="blockquote"><em>Simon Stewart is the creator of WebDriver and browser automation guru at Google. WebDriver is an open source web application testing tool popular inside and outside of Google and historically one of the hottest topics at GTAC, the Google Test Automation Conference. The authors sat down with him recently and got his thoughts on web app test automation and the future of WebDriver.</em></p>
<p><strong>HGTS</strong>: I don’t think many people understand the distinction between Selenium and WebDriver, can you clear it up?</p>
<p><strong>Simon</strong>: Selenium was a project started by Jason Huggins while he was at ThoughtWorks. Jason was writing a web application and was targeting IE which at the time was 90+ percent of the market. But he kept getting bug reports from users who had adopted FireFox and he had this problem where he would fix a bug for FF and break the app for IE. For him, Selenium was developed as a way to rev his app and then test to make sure it worked on both browsers.</p>
<p>I was building what became WebDriver a year or so later, but before Selenium was really stable, and was focused on more general web app testing. Not surprisingly, the two of us took different approaches to our implementations. Selenium was built on JavaScript running inside the browser, WebDriver was integrated into the browser itself using automation APIs. Each approach had its advantages and disadvantages. For example, Selenium supported new browsers, like Chrome, almost instantly, but couldn’t do file uploads or handle user interaction very well because it was JavaScript and limited to what was possible in the JS sandbox. Since WebDriver was built into the browser, it could sidestep these limitations, but adding new browsers was very painful. Once both of us started working for Google, we decided to integrate the two.</p>
<p><a id="page_71"></a><strong>HGTS</strong>: But I still hear people talking about both. Are they still two separate projects?</p>
<p><strong>Simon</strong>: Selenium is the name we use for the umbrella project for all browser automation tools. WebDriver happens to be one of those tools. The official name is “Selenium WebDriver.”</p>
<p><strong>HGTS</strong>: So how did Google get involved?</p>
<p><strong>Simon</strong>: Google hired some former ThoughtWorkers when Google opened the London office a few years back and those guys invited me to come give a tech talk on WebDriver. That talk didn’t inspire a lot of confidence on my part, some guy in the front row fell sound asleep and I had to compete with his snores for the audience. As luck would have it, the recording of the talk failed and there was enough interest that I was invited back to give a snore-free presentation at GTAC. I joined Google shortly thereafter. Now I know where the bodies are buried!</p>
<p><strong>HGTS</strong>: Yes, indeed, skeletons in every closet. Seriously though we’ve seen you talk before, it is hard to imagine anyone falling asleep on you. Was this anyone we know?</p>
<p><strong>Simon</strong>: No. He’s long gone from Google. Let’s just assume he had a late night beforehand!</p>
<p><strong>HGTS</strong>: Let that be a lesson to readers. Falling asleep on Simon Stewart is bad for your career! Now once you joined Google was WebDriver your full time job?</p>
<p><strong>Simon</strong>: No, it was my 20 percent project. My day job was working as a product SET but I still managed to move WebDriver forward and at this time some outside contributors were really doing good work. In the early stage of an open source project people pick it up because they need it and there are no other alternatives. It’s built-in incentive to contribute. Now many of the WebDriver users are told by others to use it and they approach it more as a consumer than as a contributor. But in the early days the grass roots WebDriver community really moved the tool forward.</p>
<p><strong>HGTS</strong>: Well we all know how the story turns out. WebDriver is very popular within Google. How did it start? Was there one project that piloted it? Any false starts?</p>
<p><strong>Simon</strong>: It began with Wave, a social networking product built in our Sydney office that has since gone away. The Wave engineers tried to use Selenium for their test infrastructure but it couldn’t cope. Wave was too complicated. The engineers were diligent enough to track WebDriver down and they started asking a lot of questions, good questions, and it became more than my 20 percent could handle. They reached out to my manager and we negotiated a month-long loan deal and I went down to Sydney to help them build out their test infrastructure.</p>
<p><strong>HGTS</strong>: I take it you were successful.</p>
<p><strong>Simon</strong>: Yes, the team was good about pitching in to help and we made it work. It drove a bunch of new requirements for WebDriver and it also served as an <a id="page_72"></a>example to other Google teams that WebDriver was a tool that could handle cutting edge web applications. From that point on, WebDriver never lacked for customers and it made sense for me to work on it full time.</p>
<p><strong>HGTS</strong>: The first customer is always the hardest. How did you handle both developing WebDriver and making it work for Wave?</p>
<p><strong>Simon</strong>: I used a process called DDD, defect-driven development. I would declare WebDriver flawless and when a customer found a bug I would fix it and once again declare it flawless. That way I fixed only the bugs that people actually cared about. It’s a process that is good for refining an existing product and making sure you are fixing the most important bugs and not spinning on bugs people don’t care about.</p>
<p><strong>HGTS</strong>: And are you still the only engineer on WebDriver?</p>
<p><strong>Simon</strong>: No, we have a team and are an official project internally at Google and very active in open source. With the ever increasing numbers of browsers, browser versions, and platforms, I tell people that we must be crazy, but we do the impossible every day. It’s something I think most sane engineers shy away from!</p>
<p><strong>HGTS</strong>: So post-Wave you had a lot of momentum. Is that where WebDriver pulled away from the older Selenium infrastructure in terms of users?</p>
<p><strong>Simon</strong>: I think so. A lot of the original Selenium engineers had moved onto other things and I had all this puppy energy for WebDriver coming off the Wave success. People I never met like Michael Tam from Germany had already started doing really significant work on WebDriver as well and I was careful to nurture those relationships. Michael was the first person I’d not met in person who got permission to submit code to the project’s source repository.</p>
<p>But I didn’t really track the spread of WebDriver all that closely. What was clear was that the closer teams were to me physically, the more likely they were to adopt WebDriver. I think Picasa Web Albums was actually the first team before Wave, and then afterwards Ads picked it up. There is still a silo effect of web automation used at Google. Chrome uses PyAuto, Search uses Puppet (which has an open source versions called Web Puppeteer), and Ads uses WebDriver, etc.</p>
<p><strong>HGTS</strong>: What about the future of WebDriver? What’s the direction your team is taking?</p>
<p><strong>Simon</strong>: Well the landscape is really getting crowded. Even a few years ago we were looking at a market with one dominate browser. Not anymore. Internet Explorer, FireFox, Chrome, Safari, Opera to name only a few and that’s only the desktop. The proliferation of random WebKit browsers for mobile devices is insane. And the commercial tools ignore them all but IE, which isn’t a sensible strategy post 2008! The next logical step for WebDriver is to standardize it so we can guarantee different web app implementations across browsers. Of course it will help to have the browser makers involved so we can ensure compliance with the WebDriver API.</p>
<p><strong>HGTS</strong>: Sounds like a standards committee issue. Any progress there?</p>
<p><a id="page_73"></a><strong>Simon</strong>: Yes. Unfortunately it means I have to write English instead of code but there is a spec in front of W3C now and that’s a place that all browser vendors get involved.</p>
<p><strong>HGTS</strong>: So what is your wish for the future? How will browser automation tools work in the future?</p>
<p><strong>Simon</strong>: My hope is that they disappear into the background. That automation APIs are an expectation for every browser and that people stop worrying about the infrastructure and they just use it. I want people thinking about new features in their web apps, not how to automate them. WebDriver will be successful when people forget it is even there.</p>
<div class="annotator-outer annotator-viewer viewer annotator-hide">
  <ul class="annotator-widget annotator-listing"></ul>
</div><div class="annotator-modal-wrapper annotator-editor-modal annotator-editor annotator-hide">
	<div class="annotator-outer editor">
		<h2 class="title">Highlight</h2>
		<form class="annotator-widget">
			<ul class="annotator-listing">
			<li class="annotator-item"><textarea id="annotator-field-0" placeholder="Add a note using markdown (optional)" class="js-editor" maxlength="750"></textarea></li></ul>
			<div class="annotator-controls">
				<a class="link-to-markdown" href="https://daringfireball.net/projects/markdown/basics" target="_blank">?</a>
				<ul>
					<li class="delete annotator-hide"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#delete" class="annotator-delete-note button positive">Delete Note</a></li>
					<li class="save"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#save" class="annotator-save annotator-focus button positive">Save Note</a></li>
					<li class="cancel"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#cancel" class="annotator-cancel button">Cancel</a></li>
				</ul>
			</div>
		</form>
	</div>
</div><div class="annotator-modal-wrapper annotator-delete-confirm-modal" style="display: none;">
  <div class="annotator-outer">
    <h2 class="title">Highlight</h2>
      <a class="js-close-delete-confirm annotator-cancel close" href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#close">Close</a>
      <div class="annotator-widget">
         <div class="delete-confirm">
            Are you sure you want to permanently delete this note?
         </div>
         <div class="annotator-controls">
            <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#cancel" class="annotator-cancel button js-cancel-delete-confirm">No, I changed my mind</a>
            <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#delete" class="annotator-delete button positive js-delete-confirm">Yes, delete it</a>
         </div>
       </div>
   </div>
</div><div class="annotator-adder" style="display: none;">
	<ul class="adders ">
		
		<li class="copy"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#">Copy</a></li>
		
		<li class="add-highlight"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#">Add Highlight</a></li>
		<li class="add-note"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#">
			
				Add Note
			
		</a></li>
	</ul>
</div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="/safari-books-archive/site/library/view/how-google-tests/9780132851572/ch01.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">Chapter 1. Introduction to Google Software Testing</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="/safari-books-archive/site/library/view/how-google-tests/9780132851572/ch03.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">Chapter 3. The Test Engineer</div>
        </a>
    
  
  </div>


      
    </section>
    <div class="reading-controls-bottom">
      <ul class="interface-controls js-bitlist">
        <li class="queue-control">
            <button type="button" class="rec-fav ss-queue js-queue js-current-chapter-queue" data-queue-endpoint="/api/v1/book/9780132851572/chapter/ch02.html" data-for-analytics="9780132851572:ch02.html">
      <span>Add to Queue</span>
  </button>
        </li>
      </ul>
    </div>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  





    
    



        
      </div>
      



  <footer class="pagefoot t-pagefoot">
    <a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#" class="icon-up"><div class="visuallyhidden">Back to top</div></a>
    <ul class="js-footer-nav">
      
        <li><a class="t-recommendations-footer" href="https://www.safaribooksonline.com/r/">Recommended</a></li>
      
      <li><a class="t-queue-footer" href="https://www.safaribooksonline.com/s/">Queue</a></li>
      
        <li><a class="t-recent-footer" href="https://www.safaribooksonline.com/history/">History</a></li>
        <li><a class="t-topics-footer" href="https://www.safaribooksonline.com/topics?q=*&amp;limit=21">Topics</a></li>
      
      
        <li><a class="t-tutorials-footer" href="https://www.safaribooksonline.com/tutorials/">Tutorials</a></li>
      
      <li><a class="t-settings-footer js-settings" href="https://www.safaribooksonline.com/u/">Settings</a></li>
      <li><a href="https://www.safaribooksonline.com/blog/">Blog</a></li>
      <li class="full-support"><a href="https://www.safaribooksonline.com/public/support">Support</a></li>
      <li><a href="https://community.safaribooksonline.com/">Feedback</a></li>
      <li><a href="https://www.safaribooksonline.com/apps/">Get the App</a></li>
      <li><a href="https://www.safaribooksonline.com/accounts/logout/">Sign Out</a></li>
    </ul>
    <span class="copyright">© 2016 <a href="https://www.safaribooksonline.com/" target="_blank">Safari</a>.</span>
    <a href="https://www.safaribooksonline.com/terms/">Terms of Service</a> /
    <a href="https://www.safaribooksonline.com/privacy/">Privacy Policy</a>
  </footer>




    

    
    
  

<div class="annotator-notice"></div><div class="font-flyout"><div class="font-controls-panel">
	<div class="nightmodes">
		<ul>
			<li class="day"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#" id="day-mode" title="Day Mode">
				<i class="fa fa-sun-o"></i>
				<span>Day Mode</span></a></li>
			<li class="cloudy"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#" id="cloudy-mode" title="Cloudy Mode">
				<i class="fa fa-cloud"></i>
				<span>Cloud Mode</span>
			</a></li>
			<li class="night"><a href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#" id="night-mode" title="Night Mode">
				<i class="fa fa-moon-o"></i>
				<span>Night Mode</span>
			</a></li>
		</ul>
	</div>

	<div class="font-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-font left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-font-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-font right"></i>
		</div>
	</div>

	<div class="column-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-compress left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-column-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-expand right"></i>
		</div>
	</div>

	<a id="reset" class="button" href="https://www.safaribooksonline.com//library/view/how-google-tests/9780132851572/ch02.html#">Reset</a>
</div>
</div></body><span class="gr__tooltip"><span class="gr__tooltip-content"></span><i class="gr__tooltip-logo"></i><span class="gr__triangle"></span></span></html>