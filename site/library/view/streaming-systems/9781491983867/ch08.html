<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/streaming-systems/9781491983867/ch08.html"
data-csrf-cookie="csrfsafari"
data-highlight-privacy=""


  data-user-id="3905629"
  data-user-uuid="f04af719-1c84-4fc3-9be3-1f1b4622ab99"
  data-username="safaribooksonline122"
  data-account-type="Trial"
  
  data-activated-trial-date="12/09/2018"


  data-archive="9781491983867"
  data-publishers="O&#39;Reilly Media, Inc."



  data-htmlfile-name="ch08.html"
  data-epub-title="Streaming Systems" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class="js flexbox flexboxlegacy no-touch websqldatabase indexeddb history csscolumns csstransforms localstorage sessionstorage applicationcache svg inlinesvg zoom gr__safaribooksonline_com" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#" itemscope="" itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/" data-offline-url="/" data-url="/library/view/streaming-systems/9781491983867/ch08.html" data-csrf-cookie="csrfsafari" data-highlight-privacy="" data-user-id="3905629" data-user-uuid="f04af719-1c84-4fc3-9be3-1f1b4622ab99" data-username="safaribooksonline122" data-account-type="Trial" data-activated-trial-date="12/09/2018" data-archive="9781491983867" data-publishers="O'Reilly Media, Inc." data-htmlfile-name="ch08.html" data-epub-title="Streaming Systems" data-debug="0" data-testing="0" style=""><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="author" content="Safari Books Online"><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9781491983867"><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"><meta property="twitter:account_id" content="4503599627559754"><link rel="apple-touch-icon" href="https://www.safaribooksonline.com/static/images/apple-touch-icon.0c29511d2d72.png"><link rel="shortcut icon" href="https://www.safaribooksonline.com/favicon.ico" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic" rel="stylesheet" type="text/css"><title>8. Streaming SQL - Streaming Systems</title><link rel="stylesheet" href="https://www.safaribooksonline.com/static/CACHE/css/5e586a47a3b7.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://www.safaribooksonline.com/static/css/annotator.e3b0c44298fc.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book">
    @charset "utf-8";#sbo-rt-content html,#sbo-rt-content div,#sbo-rt-content div,#sbo-rt-content span,#sbo-rt-content applet,#sbo-rt-content object,#sbo-rt-content iframe,#sbo-rt-content h1,#sbo-rt-content h2,#sbo-rt-content h3,#sbo-rt-content h4,#sbo-rt-content h5,#sbo-rt-content h6,#sbo-rt-content p,#sbo-rt-content blockquote,#sbo-rt-content pre,#sbo-rt-content a,#sbo-rt-content abbr,#sbo-rt-content acronym,#sbo-rt-content address,#sbo-rt-content big,#sbo-rt-content cite,#sbo-rt-content code,#sbo-rt-content del,#sbo-rt-content dfn,#sbo-rt-content em,#sbo-rt-content img,#sbo-rt-content ins,#sbo-rt-content kbd,#sbo-rt-content q,#sbo-rt-content s,#sbo-rt-content samp,#sbo-rt-content small,#sbo-rt-content strike,#sbo-rt-content strong,#sbo-rt-content sub,#sbo-rt-content sup,#sbo-rt-content tt,#sbo-rt-content var,#sbo-rt-content b,#sbo-rt-content u,#sbo-rt-content i,#sbo-rt-content center,#sbo-rt-content dl,#sbo-rt-content dt,#sbo-rt-content dd,#sbo-rt-content ol,#sbo-rt-content ul,#sbo-rt-content li,#sbo-rt-content fieldset,#sbo-rt-content form,#sbo-rt-content label,#sbo-rt-content legend,#sbo-rt-content table,#sbo-rt-content caption,#sbo-rt-content tdiv,#sbo-rt-content tfoot,#sbo-rt-content thead,#sbo-rt-content tr,#sbo-rt-content th,#sbo-rt-content td,#sbo-rt-content article,#sbo-rt-content aside,#sbo-rt-content canvas,#sbo-rt-content details,#sbo-rt-content embed,#sbo-rt-content figure,#sbo-rt-content figcaption,#sbo-rt-content footer,#sbo-rt-content header,#sbo-rt-content hgroup,#sbo-rt-content menu,#sbo-rt-content nav,#sbo-rt-content output,#sbo-rt-content ruby,#sbo-rt-content section,#sbo-rt-content summary,#sbo-rt-content time,#sbo-rt-content mark,#sbo-rt-content audio,#sbo-rt-content video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}#sbo-rt-content article,#sbo-rt-content aside,#sbo-rt-content details,#sbo-rt-content figcaption,#sbo-rt-content figure,#sbo-rt-content footer,#sbo-rt-content header,#sbo-rt-content hgroup,#sbo-rt-content menu,#sbo-rt-content nav,#sbo-rt-content section{display:block}#sbo-rt-content div{line-height:1}#sbo-rt-content ol,#sbo-rt-content ul{list-style:none}#sbo-rt-content blockquote,#sbo-rt-content q{quotes:none}#sbo-rt-content blockquote:before,#sbo-rt-content blockquote:after,#sbo-rt-content q:before,#sbo-rt-content q:after{content:none}#sbo-rt-content table{border-collapse:collapse;border-spacing:0}@page{margin:5px !important}#sbo-rt-content p{margin:10px 0 0;line-height:125%;text-align:left}#sbo-rt-content p.byline{text-align:left;margin:-33px auto 35px;font-style:italic;font-weight:bold}#sbo-rt-content div.preface p+p.byline{margin:1em 0 0 !important}#sbo-rt-content div.preface p.byline+p.byline{margin:0 !important}#sbo-rt-content div.sect1>p.byline{margin:-.25em 0 1em}#sbo-rt-content div.sect1>p.byline+p.byline{margin-top:-1em}#sbo-rt-content em{font-style:italic;font-family:inherit}#sbo-rt-content em strong,#sbo-rt-content strong em{font-weight:bold;font-style:italic;font-family:inherit}#sbo-rt-content strong,#sbo-rt-content span.bold{font-weight:bold}#sbo-rt-content em.replaceable{font-style:italic}#sbo-rt-content strong.userinput{font-weight:bold;font-style:normal}#sbo-rt-content span.bolditalic{font-weight:bold;font-style:italic}#sbo-rt-content a.ulink,#sbo-rt-content a.xref,#sbo-rt-content a.email,#sbo-rt-content a.link,#sbo-rt-content a{text-decoration:none;color:#8e0012}#sbo-rt-content span.lineannotation{font-style:italic;color:#a62a2a;font-family:serif}#sbo-rt-content span.underline{text-decoration:underline}#sbo-rt-content span.strikethrough{text-decoration:line-through}#sbo-rt-content span.smallcaps{font-variant:small-caps}#sbo-rt-content span.cursor{background:#000;color:#fff}#sbo-rt-content span.smaller{font-size:75%}#sbo-rt-content .boxedtext,#sbo-rt-content .keycap{border-style:solid;border-width:1px;border-color:#000;padding:1px}#sbo-rt-content span.gray50{color:#7F7F7F;}#sbo-rt-content h1,#sbo-rt-content div.toc-title,#sbo-rt-content h2,#sbo-rt-content h3,#sbo-rt-content h4,#sbo-rt-content h5{-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none;font-weight:bold;text-align:left;page-break-after:avoid !important;font-family:sans-serif,"DejaVuSans"}#sbo-rt-content div.toc-title{font-size:1.5em;margin-top:20px !important;margin-bottom:30px !important}#sbo-rt-content section[data-type="sect1"] h1{font-size:1.3em;color:#8e0012;margin:40px 0 8px 0}#sbo-rt-content section[data-type="sect2"] h2{font-size:1.1em;margin:30px 0 8px 0 !important}#sbo-rt-content section[data-type="sect3"] h3{font-size:1em;color:#555;margin:20px 0 8px 0 !important}#sbo-rt-content section[data-type="sect4"] h4{font-size:1em;font-weight:normal;font-style:italic;margin:15px 0 6px 0 !important}#sbo-rt-content section[data-type="chapter"]>div>h1,#sbo-rt-content section[data-type="preface"]>div>h1,#sbo-rt-content section[data-type="appendix"]>div>h1,#sbo-rt-content section[data-type="glossary"]>div>h1,#sbo-rt-content section[data-type="bibliography"]>div>h1,#sbo-rt-content section[data-type="index"]>div>h1{font-size:2em;line-height:1;margin-bottom:50px;color:#000;padding-bottom:10px;border-bottom:1px solid #000}#sbo-rt-content span.label,#sbo-rt-content span.keep-together{font-size:inherit;font-weight:inherit}#sbo-rt-content div[data-type="part"] h1{font-size:2em;text-align:center;margin-top:0 !important;margin-bottom:50px;padding:50px 0 10px 0;border-bottom:1px solid #000}#sbo-rt-content img.width-ninety{width:90%}#sbo-rt-content img{max-width:95%;margin:0 auto;padding:0}#sbo-rt-content div.figure{background-color:transparent;text-align:center !important;margin:15px 0 15px 0 !important;page-break-inside:avoid}#sbo-rt-content figure{margin:15px 0 15px 0 !important;page-break-inside:avoid}#sbo-rt-content div.figure h6,#sbo-rt-content figure h6,#sbo-rt-content figure figcaption{font-size:.9rem !important;text-align:center;font-weight:normal !important;font-style:italic;font-family:serif !important;text-transform:none !important;letter-spacing:normal !important;color:#000 !important;padding-top:10px !important;page-break-before:avoid}#sbo-rt-content div.informalfigure{text-align:center !important;padding:5px 0 !important}#sbo-rt-content div.sidebar{margin:15px 0 10px 0 !important;border:1px solid #DCDCDC;background-color:#F7F7F7;padding:15px !important;page-break-inside:avoid}#sbo-rt-content aside[data-type="sidebar"]{margin:15px 0 10px 0 !important;page-break-inside:avoid}#sbo-rt-content div.sidebar-title,#sbo-rt-content aside[data-type="sidebar"] h5{font-weight:bold;font-size:1em;font-family:sans-serif;text-transform:uppercase;letter-spacing:1px;text-align:center;margin:4px 0 6px 0 !important;page-break-inside:avoid}#sbo-rt-content div.sidebar ol,#sbo-rt-content div.sidebar ul,#sbo-rt-content aside[data-type="sidebar"] ol,#sbo-rt-content aside[data-type="sidebar"] ul{margin-left:1.25em !important}#sbo-rt-content div.sidebar div.figure p.title,#sbo-rt-content aside[data-type="sidebar"] figcaption,#sbo-rt-content div.sidebar div.informalfigure div.caption{font-size:90%;text-align:center;font-weight:normal;font-style:italic;font-family:serif !important;color:#000;padding:5px !important;page-break-before:avoid;page-break-after:avoid}#sbo-rt-content div.sidebar div.tip,#sbo-rt-content div.sidebar div[data-type="tip"],#sbo-rt-content div.sidebar div.note,#sbo-rt-content div.sidebar div[data-type="note"],#sbo-rt-content div.sidebar div.warning,#sbo-rt-content div.sidebar div[data-type="warning"],#sbo-rt-content div.sidebar div[data-type="caution"],#sbo-rt-content div.sidebar div[data-type="important"]{margin:20px auto 20px auto !important;font-size:90%;width:85%}#sbo-rt-content aside[data-type="sidebar"] p.byline{font-size:90%;font-weight:bold;font-style:italic;text-align:center;text-indent:0;margin:5px auto 6px;page-break-after:avoid}#sbo-rt-content pre{white-space:pre-wrap;font-family:"Ubuntu Mono",monospace;margin:25px 0 25px 20px;font-size:85%;display:block;-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none;overflow-wrap:break-word}#sbo-rt-content div.note pre.programlisting,#sbo-rt-content div.tip pre.programlisting,#sbo-rt-content div.warning pre.programlisting,#sbo-rt-content div.caution pre.programlisting,#sbo-rt-content div.important pre.programlisting{margin-bottom:0}#sbo-rt-content code{font-family:"Ubuntu Mono",monospace;-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none;overflow-wrap:break-word}#sbo-rt-content code strong em,#sbo-rt-content code em strong,#sbo-rt-content pre em strong,#sbo-rt-content pre strong em,#sbo-rt-content strong code em code,#sbo-rt-content em code strong code,#sbo-rt-content span.bolditalic code{font-weight:bold;font-style:italic;font-family:"Ubuntu Mono BoldItal",monospace}#sbo-rt-content code em,#sbo-rt-content em code,#sbo-rt-content pre em,#sbo-rt-content em.replaceable{font-family:"Ubuntu Mono Ital",monospace;font-style:italic}#sbo-rt-content code strong,#sbo-rt-content strong code,#sbo-rt-content pre strong,#sbo-rt-content strong.userinput{font-family:"Ubuntu Mono Bold",monospace;font-weight:bold}#sbo-rt-content div[data-type="example"]{margin:10px 0 15px 0 !important}#sbo-rt-content div[data-type="example"] h1,#sbo-rt-content div[data-type="example"] h2,#sbo-rt-content div[data-type="example"] h3,#sbo-rt-content div[data-type="example"] h4,#sbo-rt-content div[data-type="example"] h5,#sbo-rt-content div[data-type="example"] h6{font-style:italic;font-weight:normal;text-align:left !important;text-transform:none !important;font-family:serif !important;margin:10px 0 5px 0 !important;border-bottom:1px solid #000}#sbo-rt-content li pre.example{padding:10px 0 !important}#sbo-rt-content div[data-type="example"] pre[data-type="programlisting"],#sbo-rt-content div[data-type="example"] pre[data-type="screen"]{margin:0}#sbo-rt-content section[data-type="titlepage"]>div>h1{font-size:2em;margin:50px 0 10px 0 !important;line-height:1;text-align:center}#sbo-rt-content section[data-type="titlepage"] h2,#sbo-rt-content section[data-type="titlepage"] p.subtitle,#sbo-rt-content section[data-type="titlepage"] p[data-type="subtitle"]{font-size:1.3em;font-weight:normal;text-align:center;margin-top:.5em;color:#555}#sbo-rt-content section[data-type="titlepage"]>div>h2[data-type="author"],#sbo-rt-content section[data-type="titlepage"] p.author{font-size:1.3em;font-family:serif !important;font-weight:bold;margin:50px 0 !important;text-align:center}#sbo-rt-content section[data-type="titlepage"] p.edition{text-align:center;text-transform:uppercase;margin-top:2em}#sbo-rt-content section[data-type="titlepage"]{text-align:center}#sbo-rt-content section[data-type="titlepage"]:after{content:url(css_assets/titlepage_footer_ebook.png);margin:0 auto;max-width:80%}#sbo-rt-content div.book div.titlepage div.publishername{margin-top:60%;margin-bottom:20px;text-align:center;font-size:1.25em}#sbo-rt-content div.book div.titlepage div.locations p{margin:0;text-align:center}#sbo-rt-content div.book div.titlepage div.locations p.cities{font-size:80%;text-align:center;margin-top:5px}#sbo-rt-content section.preface[title="Dedication"]>div.titlepage h2.title{text-align:center;text-transform:uppercase;font-size:1.5em;margin-top:50px;margin-bottom:50px}#sbo-rt-content ul.stafflist{margin:15px 0 15px 20px !important}#sbo-rt-content ul.stafflist li{list-style-type:none;padding:5px 0}#sbo-rt-content ul.printings li{list-style-type:none}#sbo-rt-content section.preface[title="Dedication"] p{font-style:italic;text-align:center}#sbo-rt-content div.colophon h1.title{font-size:1.3em;margin:0 !important;font-family:serif !important;font-weight:normal}#sbo-rt-content div.colophon h2.subtitle{margin:0 !important;color:#000;font-family:serif !important;font-size:1em;font-weight:normal}#sbo-rt-content div.colophon div.author h3.author{font-size:1.1em;font-family:serif !important;margin:10px 0 0 !important;font-weight:normal}#sbo-rt-content div.colophon div.editor h4,#sbo-rt-content div.colophon div.editor h3.editor{color:#000;font-size:.8em;margin:15px 0 0 !important;font-family:serif !important;font-weight:normal}#sbo-rt-content div.colophon div.editor h3.editor{font-size:.8em;margin:0 !important;font-family:serif !important;font-weight:normal}#sbo-rt-content div.colophon div.publisher{margin-top:10px}#sbo-rt-content div.colophon div.publisher p,#sbo-rt-content div.colophon div.publisher span.publishername{margin:0;font-size:.8em}#sbo-rt-content div.legalnotice p,#sbo-rt-content div.timestamp p{font-size:.8em}#sbo-rt-content div.timestamp p{margin-top:10px}#sbo-rt-content div.colophon[title="About the Author"] h1.title,#sbo-rt-content div.colophon[title="Colophon"] h1.title{font-size:1.5em;margin:0 !important;font-family:sans-serif !important}#sbo-rt-content section.chapter div.titlepage div.author{margin:10px 0 10px 0}#sbo-rt-content section.chapter div.titlepage div.author div.affiliation{font-style:italic}#sbo-rt-content div.attribution{margin:5px 0 0 50px !important}#sbo-rt-content h3.author span.orgname{display:none}#sbo-rt-content div.epigraph{margin:10px 0 10px 20px !important;page-break-inside:avoid;font-size:90%}#sbo-rt-content div.epigraph p{font-style:italic}#sbo-rt-content blockquote,#sbo-rt-content div.blockquote{margin:10px !important;page-break-inside:avoid;font-size:95%}#sbo-rt-content blockquote p,#sbo-rt-content div.blockquote p{font-style:italic;margin:.75em 0 0 !important}#sbo-rt-content blockquote div.attribution,#sbo-rt-content blockquote p[data-type="attribution"]{margin:5px 0 10px 30px !important;text-align:right;width:80%}#sbo-rt-content blockquote div.attribution p,#sbo-rt-content blockquote p[data-type="attribution"]{font-style:normal;margin-top:5px}#sbo-rt-content blockquote div.attribution p:before,#sbo-rt-content blockquote p[data-type="attribution"]:before{font-style:normal;content:"—";-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none}#sbo-rt-content p.right{text-align:right;margin:0}#sbo-rt-content div[data-type="footnotes"]{border-top:1px solid black;margin-top:1.5em}#sbo-rt-content sub,#sbo-rt-content sup{font-size:75%;line-height:0;position:relative}#sbo-rt-content sup{top:-.5em}#sbo-rt-content sub{bottom:-.25em}#sbo-rt-content div.refentry p.refname{font-size:1em;font-family:sans-serif,"DejaVuSans";font-weight:bold;margin-bottom:5px;overflow:auto;width:100%}#sbo-rt-content div.refentry{width:100%;display:block;margin-top:2em}#sbo-rt-content div.refsynopsisdiv{display:block;clear:both}#sbo-rt-content div.refentry header{page-break-inside:avoid !important;display:block;break-inside:avoid !important;padding-top:0;border-bottom:1px solid #000}#sbo-rt-content div.refsect1 h6{font-size:.9em;font-family:sans-serif,"DejaVuSans";font-weight:bold}#sbo-rt-content div.refsect1{margin-top:3em}#sbo-rt-content dt{padding-top:10px !important;padding-bottom:0 !important}#sbo-rt-content dd{margin-left:1.5em !important;margin-bottom:.25em}#sbo-rt-content dd ol,#sbo-rt-content dd ul{padding-left:1em}#sbo-rt-content dd li{margin-top:0;margin-bottom:0}#sbo-rt-content dd,#sbo-rt-content li{text-align:left}#sbo-rt-content ul,#sbo-rt-content ul>li,#sbo-rt-content ol ul,#sbo-rt-content ol ul>li,#sbo-rt-content ul ol ul,#sbo-rt-content ul ol ul>li{list-style-type:disc}#sbo-rt-content ul ul,#sbo-rt-content ul ul>li{list-style-type:square}#sbo-rt-content ul ul ul,#sbo-rt-content ul ul ul>li{list-style-type:circle}#sbo-rt-content ol,#sbo-rt-content ol>li,#sbo-rt-content ol ul ol,#sbo-rt-content ol ul ol>li,#sbo-rt-content ul ol,#sbo-rt-content ul ol>li{list-style-type:decimal}#sbo-rt-content ol ol,#sbo-rt-content ol ol>li{list-style-type:lower-alpha}#sbo-rt-content ol ol ol,#sbo-rt-content ol ol ol>li{list-style-type:lower-roman}#sbo-rt-content ol,#sbo-rt-content ul{list-style-position:outside;margin:15px 0 15px 1.25em;padding-left:2.25em}#sbo-rt-content ol li,#sbo-rt-content ul li{margin:.5em 0 .65em;line-height:125%}#sbo-rt-content div.orderedlistalpha{list-style-type:upper-alpha}#sbo-rt-content table.simplelist,#sbo-rt-content ul.simplelist{margin:15px 0 15px 20px !important}#sbo-rt-content ul.simplelist li{list-style-type:none;padding:5px 0}#sbo-rt-content table.simplelist td{border:none}#sbo-rt-content table.simplelist tr{border-bottom:none}#sbo-rt-content table.simplelist tr:nth-of-type(even){background-color:transparent}#sbo-rt-content dl.calloutlist p:first-child{margin-top:-25px !important}#sbo-rt-content dl.calloutlist dd{padding-left:0;margin-top:-25px}#sbo-rt-content dl.calloutlist img,#sbo-rt-content a.co img{padding:0}#sbo-rt-content div.toc ol{margin-top:8px !important;margin-bottom:8px !important;margin-left:0 !important;padding-left:0 !important}#sbo-rt-content div.toc ol ol{margin-left:30px !important;padding-left:0 !important}#sbo-rt-content div.toc ol li{list-style-type:none}#sbo-rt-content div.toc a{color:#8e0012}#sbo-rt-content div.toc ol a{font-size:1em;font-weight:bold}#sbo-rt-content div.toc ol>li>ol a{font-weight:bold;font-size:1em}#sbo-rt-content div.toc ol>li>ol>li>ol a{text-decoration:none;font-weight:normal;font-size:1em}#sbo-rt-content div.tip,#sbo-rt-content div[data-type="tip"],#sbo-rt-content div.note,#sbo-rt-content div[data-type="note"],#sbo-rt-content div.warning,#sbo-rt-content div[data-type="warning"],#sbo-rt-content div[data-type="caution"],#sbo-rt-content div[data-type="important"]{margin:30px !important;font-size:90%;padding:10px 8px 20px 8px !important;page-break-inside:avoid}#sbo-rt-content div.tip ol,#sbo-rt-content div.tip ul,#sbo-rt-content div[data-type="tip"] ol,#sbo-rt-content div[data-type="tip"] ul,#sbo-rt-content div.note ol,#sbo-rt-content div.note ul,#sbo-rt-content div[data-type="note"] ol,#sbo-rt-content div[data-type="note"] ul,#sbo-rt-content div.warning ol,#sbo-rt-content div.warning ul,#sbo-rt-content div[data-type="warning"] ol,#sbo-rt-content div[data-type="warning"] ul,#sbo-rt-content div[data-type="caution"] ol,#sbo-rt-content div[data-type="caution"] ul,#sbo-rt-content div[data-type="important"] ol,#sbo-rt-content div[data-type="important"] ul{margin-left:1.5em !important}#sbo-rt-content div.tip,#sbo-rt-content div[data-type="tip"],#sbo-rt-content div.note,#sbo-rt-content div[data-type="note"]{border:1px solid #BEBEBE;background-color:transparent}#sbo-rt-content div.warning,#sbo-rt-content div[data-type="warning"],#sbo-rt-content div[data-type="caution"],#sbo-rt-content div[data-type="important"]{border:1px solid #BC8F8F}#sbo-rt-content div.tip h3,#sbo-rt-content div[data-type="tip"] h6,#sbo-rt-content div[data-type="tip"] h1,#sbo-rt-content div.note h3,#sbo-rt-content div[data-type="note"] h6,#sbo-rt-content div[data-type="note"] h1,#sbo-rt-content div.warning h3,#sbo-rt-content div[data-type="warning"] h6,#sbo-rt-content div[data-type="warning"] h1,#sbo-rt-content div[data-type="caution"] h6,#sbo-rt-content div[data-type="caution"] h1,#sbo-rt-content div[data-type="important"] h1,#sbo-rt-content div[data-type="important"] h6{font-weight:bold;font-size:110%;font-family:sans-serif !important;text-transform:uppercase;letter-spacing:1px;text-align:center;margin:4px 0 6px !important}#sbo-rt-content div[data-type="tip"] figure h6,#sbo-rt-content div[data-type="note"] figure h6,#sbo-rt-content div[data-type="warning"] figure h6,#sbo-rt-content div[data-type="caution"] figure h6,#sbo-rt-content div[data-type="important"] figure h6{font-family:serif !important}#sbo-rt-content div.tip h3,#sbo-rt-content div[data-type="tip"] h6,#sbo-rt-content div.note h3,#sbo-rt-content div[data-type="note"] h6,#sbo-rt-content div[data-type="tip"] h1,#sbo-rt-content div[data-type="note"] h1{color:#737373}#sbo-rt-content div.warning h3,#sbo-rt-content div[data-type="warning"] h6,#sbo-rt-content div[data-type="caution"] h6,#sbo-rt-content div[data-type="important"] h6,#sbo-rt-content div[data-type="warning"] h1,#sbo-rt-content div[data-type="caution"] h1,#sbo-rt-content div[data-type="important"] h1{color:#C67171}#sbo-rt-content div.sect1[title="Safari® Books Online"] div.note,#sbo-rt-content div.safarienabled{background-color:transparent;margin:8px 0 0 !important;border:0 solid #BEBEBE;font-size:100%;padding:0 !important;page-break-inside:avoid}#sbo-rt-content div.sect1[title="Safari® Books Online"] div.note h3,#sbo-rt-content div.safarienabled h6{display:none}#sbo-rt-content div.table,#sbo-rt-content table{margin:15px 0 30px 0 !important;max-width:95%;border:none !important;background:none;display:table !important}#sbo-rt-content div.table,#sbo-rt-content div.informaltable,#sbo-rt-content table{page-break-inside:avoid}#sbo-rt-content tr,#sbo-rt-content tr td{border-bottom:1px solid #c3c3c3}#sbo-rt-content thead td,#sbo-rt-content thead th{border-bottom:#9d9d9d 1px solid !important;border-top:#9d9d9d 1px solid !important}#sbo-rt-content tr:nth-of-type(even){background-color:#f1f6fc}#sbo-rt-content thead{font-family:sans-serif;font-weight:bold}#sbo-rt-content td,#sbo-rt-content th{display:table-cell;padding:.3em;text-align:left;vertical-align:middle;font-size:80%}#sbo-rt-content div.informaltable table{margin:10px auto !important}#sbo-rt-content div.informaltable table tr{border-bottom:none}#sbo-rt-content div.informaltable table tr:nth-of-type(even){background-color:transparent}#sbo-rt-content div.informaltable td,#sbo-rt-content div.informaltable th{border:#9d9d9d 1px solid}#sbo-rt-content div.table-title,#sbo-rt-content table caption{font-weight:normal;font-style:italic;font-family:serif;font-size:1em;margin:10px 0 10px 0 !important;padding:0;page-break-after:avoid;text-align:left !important}#sbo-rt-content table code{font-size:smaller}#sbo-rt-content div.equation,#sbo-rt-content div[data-type="equation"]{margin:10px 0 15px 0 !important}#sbo-rt-content div.equation-title,#sbo-rt-content div[data-type="equation"] h5{font-style:italic;font-weight:normal;font-family:serif !important;font-size:90%;margin:20px 0 10px 0 !important;page-break-after:avoid}#sbo-rt-content div.equation-contents{margin-left:20px}#sbo-rt-content div[data-type="equation"] math{font-size:calc(.35em + 1vw)}#sbo-rt-content span.inlinemediaobject{height:.85em;display:inline-block;margin-bottom:.2em}#sbo-rt-content span.inlinemediaobject img{margin:0;height:.85em}#sbo-rt-content div.informalequation{margin:20px 0 20px 20px;width:75%}#sbo-rt-content div.informalequation img{width:75%}#sbo-rt-content div.index{text-indent:0}#sbo-rt-content div.index h3{padding:.25em;margin-top:1em !important;background-color:#F0F0F0}#sbo-rt-content div.index li{line-height:130%;list-style-type:none}#sbo-rt-content div.index a.indexterm{color:#8e0012 !important}#sbo-rt-content div.index ul{margin-left:0 !important;padding-left:0 !important}#sbo-rt-content div.index ul ul{margin-left:1em !important;margin-top:0 !important}#sbo-rt-content code.boolean,#sbo-rt-content .navy{color:rgb(0,0,128);}#sbo-rt-content code.character,#sbo-rt-content .olive{color:rgb(128,128,0);}#sbo-rt-content code.comment,#sbo-rt-content .blue{color:rgb(0,0,255);}#sbo-rt-content code.conditional,#sbo-rt-content .limegreen{color:rgb(50,205,50);}#sbo-rt-content code.constant,#sbo-rt-content .darkorange{color:rgb(255,140,0);}#sbo-rt-content code.debug,#sbo-rt-content .darkred{color:rgb(139,0,0);}#sbo-rt-content code.define,#sbo-rt-content .darkgoldenrod,#sbo-rt-content .gold{color:rgb(184,134,11);}#sbo-rt-content code.delimiter,#sbo-rt-content .dimgray{color:rgb(105,105,105);}#sbo-rt-content code.error,#sbo-rt-content .red{color:rgb(255,0,0);}#sbo-rt-content code.exception,#sbo-rt-content .salmon{color:rgb(250,128,11);}#sbo-rt-content code.float,#sbo-rt-content .steelblue{color:rgb(70,130,180);}#sbo-rt-content pre code.function,#sbo-rt-content .green{color:rgb(0,128,0);}#sbo-rt-content code.identifier,#sbo-rt-content .royalblue{color:rgb(65,105,225);}#sbo-rt-content code.ignore,#sbo-rt-content .gray{color:rgb(128,128,128);}#sbo-rt-content code.include,#sbo-rt-content .purple{color:rgb(128,0,128);}#sbo-rt-content code.keyword,#sbo-rt-content .sienna{color:rgb(160,82,45);}#sbo-rt-content code.label,#sbo-rt-content .deeppink{color:rgb(255,20,147);}#sbo-rt-content code.macro,#sbo-rt-content .orangered{color:rgb(255,69,0);}#sbo-rt-content code.number,#sbo-rt-content .brown{color:rgb(165,42,42);}#sbo-rt-content code.operator,#sbo-rt-content .black{color:#000;}#sbo-rt-content code.preCondit,#sbo-rt-content .teal{color:rgb(0,128,128);}#sbo-rt-content code.preProc,#sbo-rt-content .fuschia{color:rgb(255,0,255);}#sbo-rt-content code.repeat,#sbo-rt-content .indigo{color:rgb(75,0,130);}#sbo-rt-content code.special,#sbo-rt-content .saddlebrown{color:rgb(139,69,19);}#sbo-rt-content code.specialchar,#sbo-rt-content .magenta{color:rgb(255,0,255);}#sbo-rt-content code.specialcomment,#sbo-rt-content .seagreen{color:rgb(46,139,87);}#sbo-rt-content code.statement,#sbo-rt-content .forestgreen{color:rgb(34,139,34);}#sbo-rt-content code.storageclass,#sbo-rt-content .plum{color:rgb(221,160,221);}#sbo-rt-content code.string,#sbo-rt-content .darkred{color:rgb(139,0,0);}#sbo-rt-content code.structure,#sbo-rt-content .chocolate{color:rgb(210,106,30);}#sbo-rt-content code.tag,#sbo-rt-content .darkcyan{color:rgb(0,139,139);}#sbo-rt-content code.todo,#sbo-rt-content .black{color:#000;}#sbo-rt-content code.type,#sbo-rt-content .mediumslateblue{color:rgb(123,104,238);}#sbo-rt-content code.typedef,#sbo-rt-content .darkgreen{color:rgb(0,100,0);}#sbo-rt-content code.underlined{text-decoration:underline;}#sbo-rt-content pre code.hll{background-color:#ffc}#sbo-rt-content pre code.c{color:#09F;font-style:italic}#sbo-rt-content pre code.err{color:#A00}#sbo-rt-content pre code.k{color:#069;font-weight:bold}#sbo-rt-content pre code.o{color:#555}#sbo-rt-content pre code.cm{color:#35586C;font-style:italic}#sbo-rt-content pre code.cp{color:#099}#sbo-rt-content pre code.c1{color:#35586C;font-style:italic}#sbo-rt-content pre code.cs{color:#35586C;font-weight:bold;font-style:italic}#sbo-rt-content pre code.gd{background-color:#FCC}#sbo-rt-content pre code.ge{font-style:italic}#sbo-rt-content pre code.gr{color:#F00}#sbo-rt-content pre code.gh{color:#030;font-weight:bold}#sbo-rt-content pre code.gi{background-color:#CFC}#sbo-rt-content pre code.go{color:#000}#sbo-rt-content pre code.gp{color:#009;font-weight:bold}#sbo-rt-content pre code.gs{font-weight:bold}#sbo-rt-content pre code.gu{color:#030;font-weight:bold}#sbo-rt-content pre code.gt{color:#9C6}#sbo-rt-content pre code.kc{color:#069;font-weight:bold}#sbo-rt-content pre code.kd{color:#069;font-weight:bold}#sbo-rt-content pre code.kn{color:#069;font-weight:bold}#sbo-rt-content pre code.kp{color:#069}#sbo-rt-content pre code.kr{color:#069;font-weight:bold}#sbo-rt-content pre code.kt{color:#078;font-weight:bold}#sbo-rt-content pre code.m{color:#F60}#sbo-rt-content pre code.s{color:#C30}#sbo-rt-content pre code.na{color:#309}#sbo-rt-content pre code.nb{color:#366}#sbo-rt-content pre code.nc{color:#0A8;font-weight:bold}#sbo-rt-content pre code.no{color:#360}#sbo-rt-content pre code.nd{color:#99F}#sbo-rt-content pre code.ni{color:#999;font-weight:bold}#sbo-rt-content pre code.ne{color:#C00;font-weight:bold}#sbo-rt-content pre code.nf{color:#C0F}#sbo-rt-content pre code.nl{color:#99F}#sbo-rt-content pre code.nn{color:#0CF;font-weight:bold}#sbo-rt-content pre code.nt{color:#309;font-weight:bold}#sbo-rt-content pre code.nv{color:#033}#sbo-rt-content pre code.ow{color:#000;font-weight:bold}#sbo-rt-content pre code.w{color:#bbb}#sbo-rt-content pre code.mf{color:#F60}#sbo-rt-content pre code.mh{color:#F60}#sbo-rt-content pre code.mi{color:#F60}#sbo-rt-content pre code.mo{color:#F60}#sbo-rt-content pre code.sb{color:#C30}#sbo-rt-content pre code.sc{color:#C30}#sbo-rt-content pre code.sd{color:#C30;font-style:italic}#sbo-rt-content pre code.s2{color:#C30}#sbo-rt-content pre code.se{color:#C30;font-weight:bold}#sbo-rt-content pre code.sh{color:#C30}#sbo-rt-content pre code.si{color:#A00}#sbo-rt-content pre code.sx{color:#C30}#sbo-rt-content pre code.sr{color:#3AA}#sbo-rt-content pre code.s1{color:#C30}#sbo-rt-content pre code.ss{color:#A60}#sbo-rt-content pre code.bp{color:#366}#sbo-rt-content pre code.vc{color:#033}#sbo-rt-content pre code.vg{color:#033}#sbo-rt-content pre code.vi{color:#033}#sbo-rt-content pre code.il{color:#F60}#sbo-rt-content pre code.g{color:#050}#sbo-rt-content pre code.l{color:#C60}#sbo-rt-content pre code.l{color:#F90}#sbo-rt-content pre code.n{color:#008}#sbo-rt-content pre code.nx{color:#008}#sbo-rt-content pre code.py{color:#96F}#sbo-rt-content pre code.p{color:#000}#sbo-rt-content pre code.x{color:#F06}#sbo-rt-content div.blockquote_sampler_toc{width:95%;margin:5px 5px 5px 10px !important}#sbo-rt-content div{font-family:serif;text-align:left}#sbo-rt-content .gray-background,#sbo-rt-content .reverse-video{background:#2E2E2E;color:#FFF}#sbo-rt-content .light-gray-background{background:#A0A0A0}#sbo-rt-content .preserve-whitespace{white-space:pre-wrap}#sbo-rt-content span.gray{color:#4C4C4C}#sbo-rt-content .what_lt{color:#c90;}#sbo-rt-content .where_lt{color:#26c}#sbo-rt-content .when_lt{color:#6a5;}#sbo-rt-content .how_lt{color:#c00}#sbo-rt-content .what_dk{color:#ffd040}#sbo-rt-content .where_dk{color:#6af}#sbo-rt-content .when_dk{color:#8ac86f}#sbo-rt-content .how_dk{color:#d77}#sbo-rt-content .grey_bg{background-color:#ff0}#sbo-rt-content .yellow_bg{background-color:#ff0}#sbo-rt-content .green_bg{background-color:#00FF7F}#sbo-rt-content .red_bg{background-color:#FFA07A}#sbo-rt-content .blue_bg{background-color:#87CEEB}#sbo-rt-content .code_blue{color:#00f}#sbo-rt-content .code_grey{color:#777}#sbo-rt-content .code_orange{color:#d83}#sbo-rt-content .code_purple{color:#87c}#sbo-rt-content .code_lightgrey{color:#C0C0C0}#sbo-rt-content .strikethrough{text-decoration:line-through}#sbo-rt-content .table_white{color:white}#sbo-rt-content .table_black{color:black}#sbo-rt-content .table_red{color:#d77}#sbo-rt-content .table_green{color:#8ac86f}#sbo-rt-content .table_blue{color:#00f}#sbo-rt-content .table_mediumgrey{background-color:#404040}#sbo-rt-content .table_lightgrey{background-color:#606060}#sbo-rt-content .table_darkgrey{background-color:#202020}
    </style><link rel="canonical" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html"><meta name="description" content=" Chapter 8. Streaming SQL Let’s talk SQL. In this chapter, we’re going to start somewhere in the middle with the punchline, jump back in time a bit to ... "><meta property="og:title" content="8. Streaming SQL"><meta itemprop="isPartOf" content="/library/view/streaming-systems/9781491983867/"><meta itemprop="name" content="8. Streaming SQL"><meta property="og:url" itemprop="url" content="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/ch08.html"><meta property="og:site_name" content="Safari"><meta property="og:image" itemprop="thumbnailUrl" content="https://www.safaribooksonline.com/library/cover/9781491983867/"><meta property="og:description" itemprop="description" content=" Chapter 8. Streaming SQL Let’s talk SQL. In this chapter, we’re going to start somewhere in the middle with the punchline, jump back in time a bit to ... "><meta itemprop="inLanguage" content="en"><meta itemprop="publisher" content="O'Reilly Media, Inc."><meta property="og:type" content="book"><meta property="og:book:isbn" itemprop="isbn" content="9781491983874"><meta property="og:book:author" itemprop="author" content="Reuven Lax"><meta property="og:book:author" itemprop="author" content="Slava Chernyak"><meta property="og:book:author" itemprop="author" content="Tyler Akidau"><meta property="og:book:tag" itemprop="about" content="Databases"><meta property="og:book:tag" itemprop="about" content="Engineering"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@safari"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><style id="annotator-dynamic-style">.annotator-adder, .annotator-outer, .annotator-notice {
  z-index: 100019;
}
.annotator-filter {
  z-index: 100009;
}</style></head>


<body class="reading sidenav nav-collapsed  scalefonts subscribe-panel library" data-gr-c-s-loaded="true">

    
  
  
  



    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        





<a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#container" class="skip">Skip to content</a><header class="topbar t-topbar" style="display:None"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li class="t-logo"><a href="https://www.safaribooksonline.com/home/" class="l0 None safari-home nav-icn js-keyboard-nav-home"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>Safari Home Icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M4 9.9L4 9.9 4 18 16 18 16 9.9 10 4 4 9.9ZM2.6 8.1L2.6 8.1 8.7 1.9 10 0.5 11.3 1.9 17.4 8.1 18 8.7 18 9.5 18 18.1 18 20 16.1 20 3.9 20 2 20 2 18.1 2 9.5 2 8.7 2.6 8.1Z"></path><rect x="10" y="12" width="3" height="7"></rect><rect transform="translate(18.121320, 10.121320) rotate(-315.000000) translate(-18.121320, -10.121320) " x="16.1" y="9.1" width="4" height="2"></rect><rect transform="translate(2.121320, 10.121320) scale(-1, 1) rotate(-315.000000) translate(-2.121320, -10.121320) " x="0.1" y="9.1" width="4" height="2"></rect></g></svg><span>Safari Home</span></a></li><li><a href="https://www.safaribooksonline.com/r/" class="t-recommendations-nav l0 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>recommendations icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M50 25C50 18.2 44.9 12.5 38.3 11.7 37.5 5.1 31.8 0 25 0 18.2 0 12.5 5.1 11.7 11.7 5.1 12.5 0 18.2 0 25 0 31.8 5.1 37.5 11.7 38.3 12.5 44.9 18.2 50 25 50 31.8 50 37.5 44.9 38.3 38.3 44.9 37.5 50 31.8 50 25ZM25 3.1C29.7 3.1 33.6 6.9 34.4 11.8 30.4 12.4 26.9 15.1 25 18.8 23.1 15.1 19.6 12.4 15.6 11.8 16.4 6.9 20.3 3.1 25 3.1ZM34.4 15.6C33.6 19.3 30.7 22.2 27.1 22.9 27.8 19.2 30.7 16.3 34.4 15.6ZM22.9 22.9C19.2 22.2 16.3 19.3 15.6 15.6 19.3 16.3 22.2 19.2 22.9 22.9ZM3.1 25C3.1 20.3 6.9 16.4 11.8 15.6 12.4 19.6 15.1 23.1 18.8 25 15.1 26.9 12.4 30.4 11.8 34.4 6.9 33.6 3.1 29.7 3.1 25ZM22.9 27.1C22.2 30.7 19.3 33.6 15.6 34.4 16.3 30.7 19.2 27.8 22.9 27.1ZM25 46.9C20.3 46.9 16.4 43.1 15.6 38.2 19.6 37.6 23.1 34.9 25 31.3 26.9 34.9 30.4 37.6 34.4 38.2 33.6 43.1 29.7 46.9 25 46.9ZM27.1 27.1C30.7 27.8 33.6 30.7 34.4 34.4 30.7 33.6 27.8 30.7 27.1 27.1ZM38.2 34.4C37.6 30.4 34.9 26.9 31.3 25 34.9 23.1 37.6 19.6 38.2 15.6 43.1 16.4 46.9 20.3 46.9 25 46.9 29.7 43.1 33.6 38.2 34.4Z"></path></g></svg><span>Recommended</span></a></li><li><a href="https://www.safaribooksonline.com/playlists/" class="t-queue-nav l0 nav-icn None"><!--?xml version="1.0" encoding="UTF-8"?--><svg width="21px" height="17px" viewBox="0 0 21 17" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><!-- Generator: Sketch 46.2 (44496) - http://www.bohemiancoding.com/sketch --><title>icon_Playlist_sml</title><desc>Created with Sketch.</desc><defs></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="icon_Playlist_sml" fill-rule="nonzero" fill="#000000"><g id="playlist-icon"><g id="Group-6"><rect id="Rectangle-path" x="5" y="0" width="16" height="3" rx="0.5"></rect><circle id="Oval" cx="1.5" cy="1.5" r="1.5"></circle></g><g id="Group-5" transform="translate(0.000000, 7.000000)"><circle id="Oval" cx="1.5" cy="1.5" r="1.5"></circle><rect id="Rectangle-path" x="5" y="0" width="16" height="3" rx="0.5"></rect></g><g id="Group-5-Copy" transform="translate(0.000000, 14.000000)"><circle id="Oval" cx="1.5" cy="1.5" r="1.5"></circle><rect id="Rectangle-path" x="5" y="0" width="16" height="3" rx="0.5"></rect></g></g></g></g></svg><span>
               Playlists
            </span></a></li><li class="search"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z"></path></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"></path></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li><a href="https://www.safaribooksonline.com/history/" class="t-recent-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>recent items icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 0C11.2 0 0 11.2 0 25 0 38.8 11.2 50 25 50 38.8 50 50 38.8 50 25 50 11.2 38.8 0 25 0ZM6.3 25C6.3 14.6 14.6 6.3 25 6.3 35.4 6.3 43.8 14.6 43.8 25 43.8 35.4 35.4 43.8 25 43.8 14.6 43.8 6.3 35.4 6.3 25ZM31.8 31.5C32.5 30.5 32.4 29.2 31.6 28.3L27.1 23.8 27.1 12.8C27.1 11.5 26.2 10.4 25 10.4 23.9 10.4 22.9 11.5 22.9 12.8L22.9 25.7 28.8 31.7C29.2 32.1 29.7 32.3 30.2 32.3 30.8 32.3 31.3 32 31.8 31.5Z"></path></g></svg><span>History</span></a></li><li><a href="https://www.safaribooksonline.com/topics" class="t-topics-link l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 55" width="20" height="20" version="1.1" fill="#4A3C31"><desc>topics icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 55L50 41.262 50 13.762 25 0 0 13.762 0 41.262 25 55ZM8.333 37.032L8.333 17.968 25 8.462 41.667 17.968 41.667 37.032 25 46.538 8.333 37.032Z"></path></g></svg><span>Topics</span></a></li><li><a href="https://www.safaribooksonline.com/tutorials/" class="l1 nav-icn t-tutorials-nav js-toggle-menu-item None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>tutorials icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M15.8 18.2C15.8 18.2 15.9 18.2 16 18.2 16.1 18.2 16.2 18.2 16.4 18.2 16.5 18.2 16.7 18.1 16.9 18 17 17.9 17.1 17.8 17.2 17.7 17.3 17.6 17.4 17.5 17.4 17.4 17.5 17.2 17.6 16.9 17.6 16.7 17.6 16.6 17.6 16.5 17.6 16.4 17.5 16.2 17.5 16.1 17.4 15.9 17.3 15.8 17.2 15.6 17 15.5 16.8 15.3 16.6 15.3 16.4 15.2 16.2 15.2 16 15.2 15.8 15.2 15.7 15.2 15.5 15.3 15.3 15.4 15.2 15.4 15.1 15.5 15 15.7 14.9 15.8 14.8 15.9 14.7 16 14.7 16.1 14.6 16.3 14.6 16.4 14.6 16.5 14.6 16.6 14.6 16.6 14.6 16.7 14.6 16.9 14.6 17 14.6 17.1 14.7 17.3 14.7 17.4 14.8 17.6 15 17.7 15.1 17.9 15.2 18 15.3 18 15.5 18.1 15.5 18.1 15.6 18.2 15.7 18.2 15.7 18.2 15.7 18.2 15.8 18.2L15.8 18.2ZM9.4 11.5C9.5 11.5 9.5 11.5 9.6 11.5 9.7 11.5 9.9 11.5 10 11.5 10.2 11.5 10.3 11.4 10.5 11.3 10.6 11.2 10.8 11.1 10.9 11 10.9 10.9 11 10.8 11.1 10.7 11.2 10.5 11.2 10.2 11.2 10 11.2 9.9 11.2 9.8 11.2 9.7 11.2 9.5 11.1 9.4 11 9.2 10.9 9.1 10.8 8.9 10.6 8.8 10.5 8.7 10.3 8.6 10 8.5 9.9 8.5 9.7 8.5 9.5 8.5 9.3 8.5 9.1 8.6 9 8.7 8.8 8.7 8.7 8.8 8.6 9 8.5 9.1 8.4 9.2 8.4 9.3 8.2 9.5 8.2 9.8 8.2 10 8.2 10.1 8.2 10.2 8.2 10.3 8.2 10.5 8.3 10.6 8.4 10.7 8.5 10.9 8.6 11.1 8.7 11.2 8.9 11.3 9 11.4 9.1 11.4 9.2 11.4 9.3 11.5 9.3 11.5 9.3 11.5 9.4 11.5 9.4 11.5L9.4 11.5ZM3 4.8C3.1 4.8 3.1 4.8 3.2 4.8 3.4 4.8 3.5 4.8 3.7 4.8 3.8 4.8 4 4.7 4.1 4.6 4.3 4.5 4.4 4.4 4.5 4.3 4.6 4.2 4.6 4.1 4.7 4 4.8 3.8 4.8 3.5 4.8 3.3 4.8 3.1 4.8 3 4.8 2.9 4.7 2.8 4.7 2.6 4.6 2.5 4.5 2.3 4.4 2.2 4.2 2.1 4 1.9 3.8 1.9 3.6 1.8 3.5 1.8 3.3 1.8 3.1 1.8 2.9 1.8 2.7 1.9 2.6 2 2.4 2.1 2.3 2.2 2.2 2.3 2.1 2.4 2 2.5 2 2.6 1.8 2.8 1.8 3 1.8 3.3 1.8 3.4 1.8 3.5 1.8 3.6 1.8 3.8 1.9 3.9 2 4 2.1 4.2 2.2 4.4 2.4 4.5 2.5 4.6 2.6 4.7 2.7 4.7 2.8 4.7 2.9 4.8 2.9 4.8 3 4.8 3 4.8 3 4.8L3 4.8ZM13.1 15.2C13.2 15.1 13.2 15.1 13.2 15.1 13.3 14.9 13.4 14.7 13.6 14.5 13.8 14.2 14.1 14 14.4 13.8 14.7 13.6 15.1 13.5 15.5 13.4 15.9 13.4 16.3 13.4 16.7 13.5 17.2 13.5 17.6 13.7 17.9 13.9 18.2 14.1 18.5 14.4 18.7 14.7 18.9 15 19.1 15.3 19.2 15.6 19.3 15.9 19.4 16.1 19.4 16.4 19.4 17 19.3 17.5 19.1 18.1 19 18.3 18.9 18.5 18.7 18.7 18.5 19 18.3 19.2 18 19.4 17.7 19.6 17.3 19.8 16.9 19.9 16.6 20 16.3 20 16 20 15.8 20 15.6 20 15.4 19.9 15.4 19.9 15.4 19.9 15.4 19.9 15.2 19.9 15 19.8 14.9 19.8 14.8 19.7 14.7 19.7 14.6 19.7 14.4 19.6 14.3 19.5 14.1 19.3 13.7 19.1 13.4 18.7 13.2 18.4 13.1 18.1 12.9 17.8 12.9 17.5 12.8 17.3 12.8 17.1 12.8 16.9L3.5 14.9C3.3 14.9 3.1 14.8 3 14.8 2.7 14.7 2.4 14.5 2.1 14.3 1.7 14 1.4 13.7 1.2 13.3 1 13 0.9 12.6 0.8 12.3 0.7 12 0.7 11.7 0.7 11.4 0.7 11 0.8 10.5 1 10.1 1.1 9.8 1.3 9.5 1.6 9.2 1.8 8.9 2.1 8.7 2.4 8.5 2.8 8.3 3.2 8.1 3.6 8.1 3.9 8 4.2 8 4.5 8 4.6 8 4.8 8 4.9 8.1L6.8 8.5C6.8 8.4 6.8 8.4 6.8 8.4 6.9 8.2 7.1 8 7.2 7.8 7.5 7.5 7.7 7.3 8 7.1 8.4 6.9 8.7 6.8 9.1 6.7 9.5 6.7 10 6.7 10.4 6.8 10.8 6.8 11.2 7 11.5 7.2 11.8 7.5 12.1 7.7 12.4 8 12.6 8.3 12.7 8.6 12.8 8.9 12.9 9.2 13 9.4 13 9.7 13 9.7 13 9.8 13 9.8 13.6 9.9 14.2 10.1 14.9 10.2 15 10.2 15 10.2 15.1 10.2 15.3 10.2 15.4 10.2 15.6 10.2 15.8 10.1 16 10 16.2 9.9 16.4 9.8 16.5 9.6 16.6 9.5 16.8 9.2 16.9 8.8 16.9 8.5 16.9 8.3 16.9 8.2 16.8 8 16.8 7.8 16.7 7.7 16.6 7.5 16.5 7.3 16.3 7.2 16.2 7.1 16 7 15.9 6.9 15.8 6.9 15.7 6.9 15.6 6.8 15.5 6.8L6.2 4.8C6.2 5 6 5.2 5.9 5.3 5.7 5.6 5.5 5.8 5.3 6 4.9 6.2 4.5 6.4 4.1 6.5 3.8 6.6 3.5 6.6 3.2 6.6 3 6.6 2.8 6.6 2.7 6.6 2.6 6.6 2.6 6.5 2.6 6.5 2.5 6.5 2.3 6.5 2.1 6.4 1.8 6.3 1.6 6.1 1.3 6 1 5.7 0.7 5.4 0.5 5 0.3 4.7 0.2 4.4 0.1 4.1 0 3.8 0 3.6 0 3.3 0 2.8 0.1 2.2 0.4 1.7 0.5 1.5 0.7 1.3 0.8 1.1 1.1 0.8 1.3 0.6 1.6 0.5 2 0.3 2.3 0.1 2.7 0.1 3.1 0 3.6 0 4 0.1 4.4 0.2 4.8 0.3 5.1 0.5 5.5 0.8 5.7 1 6 1.3 6.2 1.6 6.3 1.9 6.4 2.3 6.5 2.5 6.6 2.7 6.6 3 6.6 3 6.6 3.1 6.6 3.1 9.7 3.8 12.8 4.4 15.9 5.1 16.1 5.1 16.2 5.2 16.4 5.2 16.7 5.3 16.9 5.5 17.2 5.6 17.5 5.9 17.8 6.2 18.1 6.5 18.3 6.8 18.4 7.2 18.6 7.5 18.6 7.9 18.7 8.2 18.7 8.6 18.7 9 18.6 9.4 18.4 9.8 18.3 10.1 18.2 10.3 18 10.6 17.8 10.9 17.5 11.1 17.3 11.3 16.9 11.6 16.5 11.8 16 11.9 15.7 12 15.3 12 15 12 14.8 12 14.7 12 14.5 11.9 13.9 11.8 13.3 11.7 12.6 11.5 12.5 11.7 12.4 11.9 12.3 12 12.1 12.3 11.9 12.5 11.7 12.7 11.3 12.9 10.9 13.1 10.5 13.2 10.2 13.3 9.9 13.3 9.6 13.3 9.4 13.3 9.2 13.3 9 13.2 9 13.2 9 13.2 9 13.2 8.8 13.2 8.7 13.2 8.5 13.1 8.2 13 8 12.8 7.7 12.6 7.4 12.4 7.1 12 6.8 11.7 6.7 11.4 6.6 11.1 6.5 10.8 6.4 10.6 6.4 10.4 6.4 10.2 5.8 10.1 5.2 9.9 4.5 9.8 4.4 9.8 4.4 9.8 4.3 9.8 4.1 9.8 4 9.8 3.8 9.8 3.6 9.9 3.4 10 3.2 10.1 3 10.2 2.9 10.4 2.8 10.5 2.6 10.8 2.5 11.1 2.5 11.5 2.5 11.6 2.5 11.8 2.6 12 2.6 12.1 2.7 12.3 2.8 12.5 2.9 12.6 3.1 12.8 3.2 12.9 3.3 13 3.5 13.1 3.6 13.1 3.7 13.1 3.8 13.2 3.9 13.2L13.1 15.2 13.1 15.2Z"></path></g></svg><span>Tutorials</span></a></li><li class="nav-offers flyout-parent"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#" class="l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>offers icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M35.9 20.6L27 15.5C26.1 15 24.7 15 23.7 15.5L14.9 20.6C13.9 21.1 13.2 22.4 13.2 23.4L13.2 41.4C13.2 42.4 13.9 43.7 14.9 44.2L23.3 49C24.2 49.5 25.6 49.5 26.6 49L35.9 43.6C36.8 43.1 37.6 41.8 37.6 40.8L37.6 23.4C37.6 22.4 36.8 21.1 35.9 20.6L35.9 20.6ZM40 8.2C39.1 7.6 37.6 7.6 36.7 8.2L30.2 11.9C29.3 12.4 29.3 13.2 30.2 13.8L39.1 18.8C40 19.4 40.7 20.6 40.7 21.7L40.7 39C40.7 40.1 41.4 40.5 42.4 40L48.2 36.6C49.1 36.1 49.8 34.9 49.8 33.8L49.8 15.6C49.8 14.6 49.1 13.3 48.2 12.8L40 8.2 40 8.2ZM27 10.1L33.6 6.4C34.5 5.9 34.5 5 33.6 4.5L26.6 0.5C25.6 0 24.2 0 23.3 0.5L16.7 4.2C15.8 4.7 15.8 5.6 16.7 6.1L23.7 10.1C24.7 10.6 26.1 10.6 27 10.1ZM10.1 21.7C10.1 20.6 10.8 19.4 11.7 18.8L20.6 13.8C21.5 13.2 21.5 12.4 20.6 11.9L13.6 7.9C12.7 7.4 11.2 7.4 10.3 7.9L1.6 12.8C0.7 13.3 0 14.6 0 15.6L0 33.8C0 34.9 0.7 36.1 1.6 36.6L8.4 40.5C9.3 41 10.1 40.6 10.1 39.6L10.1 21.7 10.1 21.7Z"></path></g></svg><span>Offers &amp; Deals</span></a><ul class="flyout"><li><a href="https://get.oreilly.com/email-signup.html" target="_blank" class="l2 nav-icn"><span>Newsletters</span></a></li></ul></li><li class="nav-highlights"><a href="https://www.safaribooksonline.com/u/f04af719-1c84-4fc3-9be3-1f1b4622ab99/" class="t-highlights-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 35" width="20" height="20" version="1.1" fill="#4A3C31"><desc>highlights icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M13.325 18.071L8.036 18.071C8.036 11.335 12.36 7.146 22.5 5.594L22.5 0C6.37 1.113 0 10.632 0 22.113 0 29.406 3.477 35 10.403 35 15.545 35 19.578 31.485 19.578 26.184 19.578 21.556 17.211 18.891 13.325 18.071L13.325 18.071ZM40.825 18.071L35.565 18.071C35.565 11.335 39.86 7.146 50 5.594L50 0C33.899 1.113 27.5 10.632 27.5 22.113 27.5 29.406 30.977 35 37.932 35 43.045 35 47.078 31.485 47.078 26.184 47.078 21.556 44.74 18.891 40.825 18.071L40.825 18.071Z"></path></g></svg><span>Highlights</span></a></li><li><a href="https://www.safaribooksonline.com/u/preferences/" class="t-settings-nav l1 js-settings nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"></path></g></svg><span>Settings</span></a></li><li><a href="https://www.oreilly.com/online-learning/support/" class="l1 no-icon">Support</a></li><li><a href="https://www.safaribooksonline.com/accounts/logout/" class="l1 no-icon">Sign Out</a></li></ul><ul class="profile"><li><a href="https://www.safaribooksonline.com/u/preferences/" class="l2 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"></path></g></svg><span>Settings</span></a><span class="l2 t-nag-notification" id="nav-nag"><strong class="trial-green">10</strong> days left in your trial.
  
  

  
    
      

<a class="" href="https://www.safaribooksonline.com/subscribe/">Subscribe</a>.


    
  

  

</span></li><li><a href="https://www.oreilly.com/online-learning/support/" class="l2">Support</a></li><li><a href="https://www.safaribooksonline.com/accounts/logout/" class="l2">Sign Out</a></li></ul></div></li></ul></nav></header>


      </div>
      <div id="container" class="application" style="height: auto;">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Streaming Systems
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#" title="Search in archive" class="js-search-controls search-controls"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><div class="js-content-uri" data-content-uri="/api/v1/book/9781491983867/chapter/ch08.html"><div class="js-collections-dropdown collections-dropdown menu-bit-cards"><div data-reactroot="" class="menu-dropdown-wrapper js-menu-dropdown-wrapper align-right"><img class="hidden" src="https://www.safaribooksonline.com/static/images/ajax-transp.gif" alt="loading spinner"><div class="menu-control"><div class="control "><div class="js-playlists-menu"><button class="js-playlist-icon"><svg class="icon-add-to-playlist-sml" viewBox="0 0 16 14" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g fill-rule="nonzero" fill="#000000"><g transform="translate(-1.000000, 0.000000)"><rect x="5" y="0" width="12" height="2"></rect><title>Playlists</title><path d="M4.5,14 C6.43299662,14 8,12.4329966 8,10.5 C8,8.56700338 6.43299662,7 4.5,7 C2.56700338,7 1,8.56700338 1,10.5 C1,12.4329966 2.56700338,14 4.5,14 Z M2.5,10 L4,10 L4,8.5 L5,8.5 L5,10 L6.5,10 L6.5,11 L5,11 L5,12.5 L4,12.5 L4,11 L2.5,11 L2.5,10 Z"></path><circle cx="2" cy="5" r="1"></circle><circle cx="1.94117647" cy="1" r="1"></circle><rect x="5" y="4" width="12" height="2"></rect><rect x="9" y="8" width="8" height="2"></rect><rect x="9" y="12" width="8" height="2"></rect></g></g></g></svg><div class="js-playlist-addto-label">Add&nbsp;To</div></button></div></div></div></div></div></div></li><li class="js-font-control-panel font-control-activator"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a class="twitter share-button t-twitter" target="_blank" aria-label="Share this section on Twitter" title="Share this section on Twitter" href="https://twitter.com/share?url=https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/ch08.html&amp;text=Streaming%20Systems&amp;via=safari"><span>Twitter</span></a></li><li><a class="facebook share-button t-facebook" target="_blank" aria-label="Share this section on Facebook" title="Share this section on Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/ch08.html"><span>Facebook</span></a></li><li><a class="googleplus share-button t-googleplus" target="_blank" aria-label="Share this secton on Google Plus" title="Share this secton on Google Plus" href="https://plus.google.com/share?url=https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/ch08.html"><span>Google Plus</span></a></li><li><a class="email share-button t-email" aria-label="Share this section via email" title="Share this section via email" href="mailto:?subject=Safari:%208.%20Streaming%20SQL&amp;body=https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/ch08.html%0D%0Afrom%20Streaming%20Systems%0D%0A"><span>Email</span></a></li></ul></li>
      </ul>
    </div>

    <section role="document">
        
        



 <!--[if lt IE 9]>
  
<![endif]-->



  


        
	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch07.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">7. The Practicalities of Persistent State</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch09.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">9. Streaming Joins</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content" style="transform: none;"><div class="annotator-wrapper"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Streaming SQL"><div class="chapter" id="streaming_sql">
<h1><span class="label">Chapter 8. </span>Streaming SQL</h1>

<p>Let’s talk SQL. In this chapter, we’re going to start<a contenteditable="false" data-primary="streaming SQL" data-type="indexterm" id="ix_SQL"></a> somewhere in the middle with the punchline, jump back in time a bit to establish additional context, and finally jump back to the future to wrap everything up with a nice bow. Imagine Quentin Tarantino held a degree in computer science and was super pumped to tell the world about the finer points of streaming SQL, and so he offered to ghostwrite this chapter with me; it’s sorta like that. Minus the violence.</p>

<section data-type="sect1" data-pdf-bookmark="What Is Streaming SQL?"><div class="sect1" id="idm140176510236048">
<h1>What Is Streaming SQL?</h1>

<p>I would argue that the answer to this question has eluded our industry for decades. In all fairness, <a contenteditable="false" data-primary="streaming SQL" data-secondary="complete definition of" data-type="indexterm" id="idm140176510234368"></a>the database community has understood maybe 99% of the answer for quite a while now. But I have yet to see a truly cogent and comprehensive definition of streaming SQL that encompasses the full breadth of robust streaming semantics. That’s what we’ll try to come up with here, although it would be hubris to assume we’re 100% of the way there now. Maybe 99.1%? Baby steps.</p>

<p>Regardless, I want to point out up front that most of what we’ll discuss in this chapter is still purely hypothetical as of the time of writing. This chapter and the one that follows (covering streaming joins) both describe an idealistic vision for what streaming SQL could be. Some pieces are already implemented in systems like Apache Calcite, Apache Flink, and Apache Beam.<a contenteditable="false" data-primary="Apache Beam" data-secondary="streaming SQL in" data-type="indexterm" id="idm140176510231648"></a><a contenteditable="false" data-primary="Apache Flink" data-type="indexterm" id="idm140176510230272"></a><a contenteditable="false" data-primary="Apache Calcite" data-type="indexterm" id="idm140176510229168"></a> Many others aren’t implemented anywhere. Along the way, I’ll try to call out a few of the things that do exist in concrete form, but given what a moving target that is, your best bet is to simply consult the documentation for your specific system of interest.<a contenteditable="false" data-primary="Calcite" data-see="Apache Calcite" data-type="indexterm" id="idm140176510227648"></a></p>

<p>On that note, it’s also worth highlighting that the vision for streaming SQL presented here is the result of a collaborative discussion between the Calcite, Flink, and <span class="keep-together">Beam communities</span>. Julian Hyde, the lead developer on Calcite, has <a href="http://bit.ly/2JTzR4V">long pitched</a> his vision for what streaming SQL might look like. In 2016, members of the Flink community integrated Calcite SQL support into Flink itself, and began adding streaming-specific features such as windowing constructs to the Calcite SQL dialect. Then, in 2017, all three communities began a <a href="http://s.apache.org/streaming-sql-spec">discussion</a> to try to come to agreement on what language extensions and semantics for robust stream processing in Calcite SQL should look like. This chapter attempts to distill the ideas from that discussion down into a clear and cohesive narrative about integrating streaming concepts into SQL, regardless of whether it’s Calcite or some other dialect.</p>

<section data-type="sect2" data-pdf-bookmark="Relational Algebra"><div class="sect2" id="idm140176510222784">
<h2>Relational Algebra</h2>

<p>When talking about what streaming means for SQL, it’s important to keep in mind the theoretical foundation of SQL: relational algebra. <a contenteditable="false" data-primary="relational algebra" data-type="indexterm" id="idm140176510221056"></a><a contenteditable="false" data-primary="streaming SQL" data-secondary="relational algebra as theoretical foundation of SQL" data-type="indexterm" id="idm140176510219952"></a>Relational algebra is simply a mathematical way of describing relationships between data that consist of named, typed tuples. At the heart of relational algebra is the relation itself, which is a set of these tuples.<a contenteditable="false" data-primary="relations (in databases)" data-type="indexterm" id="idm140176510218240"></a> In classic database terms, a relation is something akin to a table, be it a physical database table, the result of a SQL query, a view (materialized or otherwise), and so on; it’s a set of rows containing named and typed columns of data.</p>

<p>One of<a contenteditable="false" data-primary="closure property (relational algebra)" data-type="indexterm" id="idm140176510216320"></a> the more critical <a contenteditable="false" data-primary="operators (relational algebra)" data-secondary="applying to valid relations" data-type="indexterm" id="idm140176510215040"></a>aspects of relational algebra is its closure property: applying any operator from the relational algebra to any valid relation<sup><a data-type="noteref" id="idm140176510213328-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510213328" class="totri-footnote">1</a></sup> always yields another relation. In other words, relations are the common currency of relational algebra, and all operators consume them as input and produce them as output.</p>

<p>Historically, many attempts to support streaming in SQL have fallen short of satisfying the closure property. They treat streams separately from classic relations, providing new operators to convert between the two, and restricting the operations that can be applied to one or the other. This significantly raises the bar of adoption for any such streaming SQL system: would-be users must learn the new operators and understand the places where they’re applicable, where they aren’t, and similarly relearn the rules of applicability in this new world for any old operators. What’s worse, most of these systems still fall short of providing the full suite of streaming semantics that we would want, such as support for robust out-of-order processing and strong temporal join support (the latter of which we cover in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch09.html#streaming_joins">Chapter&nbsp;9</a>). As a result, I would argue that it’s basically impossible to name any existing streaming SQL implementation that has achieved truly broad adoption. The additional cognitive overhead and restricted capabilities of such streaming SQL systems have ensured that they remain a niche enterprise.</p>

<p>To change that, to truly bring streaming SQL to the forefront, what we need is a way for streaming to become a first-class citizen within the relational algebra itself, such that the entire standard relational algebra can apply naturally in both streaming and nonstreaming use cases. That isn’t to say that streams and tables should be treated as exactly the same thing; they most definitely are not the same, and recognizing that fact lends clarity to understanding and power to navigating the stream/table relationship, as we’ll see shortly. But the core algebra should apply cleanly and naturally to both worlds, with minimal extensions beyond the standard relational algebra only in the cases where absolutely necessary.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Time-Varying Relations"><div class="sect2" id="idm140176510207824">
<h2>Time-Varying Relations</h2>

<p>To cut to the chase, the punchline I referred to at the beginning of the chapter is this: the key to naturally<a contenteditable="false" data-primary="streaming SQL" data-secondary="time-varying relations" data-type="indexterm" id="ix_SQLtimvar"></a> integrating streaming into SQL is to extend relations,<a contenteditable="false" data-primary="time-varying relations" data-type="indexterm" id="ix_tmvar"></a> the core data objects of relational algebra, to represent a set of data <em>over time</em> rather than a set of data at a <em>specific point</em> in time. More succinctly, instead of <em>point-in-time</em> relations, we need <em>time-varying relations</em>.<sup><a data-type="noteref" id="idm140176510200704-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510200704" class="totri-footnote">2</a></sup></p>

<p>But what are time-varying relations? Let’s first define them in terms of classic relational algebra, after which we’ll also consider their relationship to stream and table theory.<a contenteditable="false" data-primary="relational algebra" data-secondary="defining time-varying relations in terms of" data-type="indexterm" id="ix_relalgTVR"></a><a contenteditable="false" data-primary="time-varying relations" data-secondary="defining in terms of relational algebra" data-type="indexterm" id="ix_TVRdefrelalg"></a></p>

<p>In terms of relational algebra, a time-varying relation is really just the evolution of a classic relation over time. To understand what I mean by that, imagine a raw dataset consisting of user events. Over time, as users generate new events, the dataset continues to grow and evolve. If you observe that set at a specific point in time, that’s a classic relation. But if you observe the holistic evolution of the set <em>over time</em>, that’s a time-varying relation.</p>

<p>Put differently, if classic relations are like two-dimensional tables consisting of named, typed columns in the x-axis and rows of records in the y-axis, time-varying relations are like three-dimensional tables with x- and y-axes as before, but an additional z-axis capturing different versions of the two-dimensional table over time. As the relation changes, new snapshots of the relation are added in the z dimension.</p>

<p>Let’s look at an example. Imagine our raw dataset is users and scores; for example, per-user scores from a mobile game as in most of the other examples throughout the book. And suppose that our example dataset here ultimately ends up looking like this when observed at a specific point in time, in this case 12:07:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:07&gt;</span> SELECT * FROM UserScores;</em></strong>
-------------------------
| Name  | Score | Time  |
-------------------------
| Julie | 7     | 12:01 |
| Frank | 3     | 12:03 |
| Julie | 1     | 12:03 |
| Julie | 4     | 12:07 |
-------------------------
</pre>

<p>In other words, it recorded the arrivals of four scores over time: Julie’s score of 7 at 12:01, both Frank’s score of 3 and Julie’s second score of 1 at 12:03, and, finally, Julie’s third score of 4 at 12:07 (note that the <code>Time</code> column here contains processing-time timestamps representing the <em>arrival time</em> of the records within the system; we get into event-time timestamps a little later on). Assuming these were the only data to ever arrive for this relation, it would look like the preceding table any time we observed it after 12:07. But if instead we had observed the relation at 12:01, it would have looked like the following, because only Julie’s first score would have arrived by that point:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:01&gt;</span> SELECT * FROM UserScores;</em></strong>
-------------------------
| Name  | Score | Time  |
-------------------------
| Julie | 7     | 12:01 |
-------------------------
</pre>

<p>If we had then observed it again at 12:03, Frank’s score and Julie’s second score would have also arrived, so the relation would have evolved to look like this:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:03&gt;</span> SELECT * FROM UserScores;</em></strong>
-------------------------
| Name  | Score | Time  |
-------------------------
| Julie | 7     | 12:01 |
| Frank | 3     | 12:03 |
| Julie | 1     | 12:03 |
-------------------------
</pre>

<p>From this example we can begin to get a sense for what the <em>time-varying</em> relation for this dataset must look like: it would capture the entire evolution of the relation over time. Thus, if we observed the time-varying relation (or TVR) at or after 12:07, it would thus look like the following (note the use of a hypothetical <code><span class="code_grey">TVR</span></code> keyword to signal that we want the query to return the full time-varying relation, not the standard point-in-time snapshot of a classic relation):</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:07&gt;</span> SELECT <span class="code_grey">TVR</span> * FROM UserScores;</em></strong>
---------------------------------------------------------
|       [-inf, 12:01)       |       [12:01, 12:03)      |
| ------------------------- | ------------------------- |
| | Name  | Score | Time  | | | Name  | Score | Time  | |
| ------------------------- | ------------------------- |
| |       |       |       | | | Julie | 7     | 12:01 | |
| |       |       |       | | |       |       |       | |
| |       |       |       | | |       |       |       | |
| |       |       |       | | |       |       |       | |
| ------------------------- | ------------------------- |
---------------------------------------------------------
|       [12:03, 12:07)      |       [12:07, now)        |
| ------------------------- | ------------------------- |
| | Name  | Score | Time  | | | Name  | Score | Time  | |
| ------------------------- | ------------------------- |
| | Julie | 7     | 12:01 | | | Julie | 7     | 12:01 | |
| | Frank | 3     | 12:03 | | | Frank | 3     | 12:03 | |
| | Julie | 1     | 12:03 | | | Julie | 1     | 12:03 | |
| |       |       |       | | | Julie | 4     | 12:07 | |
| ------------------------- | ------------------------- |
---------------------------------------------------------
</pre>

<p>Because the printed/digital page remains constrained to two dimensions, I’ve taken the liberty of flattening the third dimension into a grid of two-dimensional relations. But you can see how the time-varying relation essentially consists of a sequence of classic relations (ordered left to right, top to bottom), each capturing the full state of the relation for a specific range of time (all of which, by definition, are contiguous).</p>

<p>What’s important about defining time-varying relations this way is that they really are, for all intents and purposes, just a sequence of classic relations that each exist independently within their own disjointed (but adjacent) time ranges, with each range capturing a period of time during which the relation did not change. This is important, because it means that the application of a relational operator to a time-varying relation is equivalent to individually applying that operator to each classic relation in the corresponding sequence. And taken one step further, the result of individually applying a relational operator <a contenteditable="false" data-primary="operators (relational algebra)" data-secondary="applied to time-varying relations" data-type="indexterm" id="idm140176510176976"></a>to a sequence of relations, each associated with a time interval, will always yield a corresponding sequence of relations with the same time intervals. In other words, the result is a corresponding time-varying relation. This definition gives us two very important properties:</p>

<ul>
	<li>
	<p>The <em>full set of operators</em> from classic relational algebra <em>remain valid</em> when applied to time-varying relations, and furthermore continue to behave exactly as you’d expect.</p>
	</li>
	<li>
	<p>The <em>closure property</em> of relational algebra <em>remains intact</em> when applied to time-varying relations.<a contenteditable="false" data-primary="closure property (relational algebra)" data-secondary="remaining intact when applied to time-varying relations" data-type="indexterm" id="idm140176510171312"></a></p>
	</li>
</ul>

<p>Or more succinctly, <em>all the rules of classic relational algebra continue to hold when applied to time-varying relations</em>. This is huge, because it means that our substitution of time-varying relations for classic relations hasn’t altered the parameters of the game in any way. Everything continues to work the way it did back in classic relational land, just on sequences of classic relations instead of singletons. Going back to our examples, consider two more time-varying relations over our raw dataset, both observed at some time after 12:07. First a simple<a contenteditable="false" data-primary="filtering relation (WHERE clause), time-varying relation applied to" data-type="indexterm" id="idm140176510168144"></a> filtering relation using a <code>WHERE</code> clause:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:07&gt;</span> SELECT <span class="code_grey">TVR</span> * FROM UserScores WHERE Name = "Julie";</em></strong>
---------------------------------------------------------
|       [-inf, 12:01)       |       [12:01, 12:03)      |
| ------------------------- | ------------------------- |
| | Name  | Score | Time  | | | Name  | Score | Time  | |
| ------------------------- | ------------------------- |
| |       |       |       | | | Julie | 7     | 12:01 | |
| |       |       |       | | |       |       |       | |
| |       |       |       | | |       |       |       | |
| ------------------------- | ------------------------- |
---------------------------------------------------------
|       [12:03, 12:07)      |       [12:07, now)        |
| ------------------------- | ------------------------- |
| | Name  | Score | Time  | | | Name  | Score | Time  | |
| ------------------------- | ------------------------- |
| | Julie | 7     | 12:01 | | | Julie | 7     | 12:01 | |
| | Julie | 1     | 12:03 | | | Julie | 1     | 12:03 | |
| |       |       |       | | | Julie | 4     | 12:07 | |
| ------------------------- | ------------------------- |
---------------------------------------------------------
</pre>

<p>As you would expect, this relation looks a lot like the preceding one, but with Frank’s scores filtered out. Even though the time-varying relation captures the added dimension of time necessary to record the evolution of this dataset over time, the query behaves exactly as you would expect, given your understanding of SQL.</p>

<p>For something a little more complex, <a contenteditable="false" data-primary="grouping relation, time-varying relation applied to" data-type="indexterm" id="idm140176510161616"></a>let’s consider a grouping relation in which we’re summing up all the per-user scores to generate a total overall score for each user:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:07&gt;</span> SELECT <span class="code_grey">TVR</span> Name, SUM(Score) as Total, MAX(Time) as Time 
       FROM UserScores GROUP BY Name;</em></strong>
---------------------------------------------------------
|       [-inf, 12:01)       |       [12:01, 12:03)      |
| ------------------------- | ------------------------- |
| | Name  | Total | Time  | | | Name  | Total | Time  | |
| ------------------------- | ------------------------- |
| |       |       |       | | | Julie | 7     | 12:01 | |
| |       |       |       | | |       |       |       | |
| ------------------------- | ------------------------- |
---------------------------------------------------------
|       [12:03, 12:07)      |       [12:07, now)        |
| ------------------------- | ------------------------- |
| | Name  | Total | Time  | | | Name  | Total | Time  | |
| ------------------------- | ------------------------- |
| | Julie | 8     | 12:03 | | | Julie | 12    | 12:07 | |
| | Frank | 3     | 12:03 | | | Frank | 3     | 12:03 | |
| ------------------------- | ------------------------- |
---------------------------------------------------------
</pre>

<p>Again, the time-varying version of this query behaves exactly as you would expect, with each classic relation in the sequence simply containing the sum of the scores for each user. And indeed, no matter how complicated a query we might choose, the results are always identical to applying that query independently to the commensurate classic relations composing the input time-varying relation. I cannot stress enough how important this is!</p>

<p>All right, that’s all well and good, but time-varying relations themselves are more of a theoretical construct than a practical, physical manifestation of data; it’s pretty easy to see how they could grow to be quite huge and unwieldy for large datasets that change frequently. To see how they actually tie into real-world stream processing, let’s now <a contenteditable="false" data-primary="relational algebra" data-secondary="defining time-varying relations in terms of" data-startref="ix_relalgTVR" data-type="indexterm" id="idm140176510155008"></a>explore the relationship between time-varying relations and stream and table theory.<a contenteditable="false" data-primary="time-varying relations" data-secondary="defining in terms of relational algebra" data-startref="ix_TVRdefrelalg" data-type="indexterm" id="idm140176510153200"></a><a contenteditable="false" data-primary="time-varying relations" data-startref="ix_tmvar" data-type="indexterm" id="idm140176510151488"></a><a contenteditable="false" data-primary="streaming SQL" data-secondary="time-varying relations" data-startref="ix_SQLtimvar" data-type="indexterm" id="idm140176510150112"></a></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Streams and Tables"><div class="sect2" id="idm140176510206880">
<h2>Streams and Tables</h2>

<p>For this comparison, let’s consider again our<a contenteditable="false" data-primary="streams and tables" data-secondary="time-varying relations in" data-type="indexterm" id="ix_strmtblTVR"></a> grouped time-varying <a contenteditable="false" data-primary="time-varying relations" data-secondary="relationship with stream and table theory" data-type="indexterm" id="ix_TVRstrmtbl"></a>relation that we looked at earlier:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:07&gt;</span> SELECT <span class="code_grey">TVR</span> Name, SUM(Score) as Total, MAX(Time) as Time
       FROM UserScores GROUP BY Name;</em></strong>
---------------------------------------------------------
|       [-inf, 12:01)       |       [12:01, 12:03)      |
| ------------------------- | ------------------------- |
| | Name  | Total | Time  | | | Name  | Total | Time  | |
| ------------------------- | ------------------------- |
| |       |       |       | | | Julie | 7     | 12:01 | |
| |       |       |       | | |       |       |       | |
| ------------------------- | ------------------------- |
---------------------------------------------------------
|       [12:03, 12:07)      |       [12:07, now)        |
| ------------------------- | ------------------------- |
| | Name  | Total | Time  | | | Name  | Total | Time  | |
| ------------------------- | ------------------------- |
| | Julie | 8     | 12:03 | | | Julie | 12    | 12:07 | |
| | Frank | 3     | 12:03 | | | Frank | 3     | 12:03 | |
| ------------------------- | ------------------------- |
---------------------------------------------------------
</pre>

<p>We understand that this sequence captures the full history of the relation over time. Given our understanding of tables and streams from <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#streams_and_tables">Chapter&nbsp;6</a>, it’s not too difficult to understand how time-varying relations relate to stream and table theory.</p>

<p>Tables are quite straightforward: because a time-varying relation is essentially a sequence of classic relations (each capturing a snapshot of the relation at a specific point in time), and classic relations are analogous to tables, observing a time-varying relation as a table simply yields the point-in-time relation snapshot for the time of observation.</p>

<p>For example, if we were to observe the previous grouped time-varying relation as a table at 12:01, we’d get the following (note the use of another hypothetical keyword, <span class="code_orange"><code>TABLE</code></span>, to explicitly<a contenteditable="false" data-primary="TABLE keyword (hypothetical, in SQL)" data-type="indexterm" id="idm140176510135504"></a> call out our desire for the query to return a table):</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:01&gt;</span> SELECT <span class="code_orange">TABLE</span> Name, SUM(Score) as Total, MAX(Time) as Time</em></strong>
<strong><em>       FROM UserScores GROUP BY Name;</em></strong>
-------------------------
| Name  | Total | Time  |
-------------------------
| Julie | 7     | 12:01 |
-------------------------
</pre>

<p>And observing at 12:07 would yield the expected:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:07&gt;</span> SELECT <span class="code_orange">TABLE</span> Name, SUM(Score) as Total, MAX(Time) as Time</em></strong>
<strong><em>       FROM UserScores GROUP BY Name;</em></strong>
-------------------------
| Name  | Total | Time  |
-------------------------
| Julie | 12    | 12:07 |
| Frank | 3     | 12:03 |
-------------------------
</pre>

<p>What’s particularly interesting here is that there’s actually support for the idea of time-varying relations within SQL, even as it exists today. <a contenteditable="false" data-primary="SQL" data-secondary="support for time-varying relations in" data-type="indexterm" id="idm140176510126416"></a>The SQL 2011 standard provides “temporal tables,” which store a versioned history of the table over time (in essence, time-varying relations) as well an <code>AS OF SYSTEM TIME</code> construct that allows <a contenteditable="false" data-primary="AS OF SYSTEM TIME construct (SQL)" data-type="indexterm" id="idm140176510124288"></a>you to explicitly <a contenteditable="false" data-primary="temporal tables (SQL)" data-type="indexterm" id="idm140176510123008"></a>query and receive a snapshot of the temporal table/time-varying relation at whatever point in time you specified. For example, even if we performed our query at 12:07, we could still see what the relation looked like back at 12:03:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:07&gt;</span> SELECT <span class="code_orange">TABLE</span> Name, SUM(Score) as Total, MAX(Time) as Time</em></strong>
<strong><em>       FROM UserScores GROUP BY Name AS OF SYSTEM TIME ‘12:03’;</em></strong>
-------------------------
| Name  | Total | Time  |
-------------------------
| Julie | 8     | 12:03 |
| Frank | 3     | 12:03 |
-------------------------
</pre>

<p>So there’s some amount of precedent for time-varying relations in SQL already. But I digress. The main point here is that tables capture a snapshot of the time-varying relation at a specific point in time.<a contenteditable="false" data-primary="tables" data-secondary="time-varying relations in" data-type="indexterm" id="idm140176510117536"></a> Most real-world table implementations simply track real time as we observe it; others maintain some additional historical information, which in the limit is equivalent to a full-fidelity time-varying relation capturing the entire history of a relation over time.</p>

<p>Streams are slightly different beasts.<a contenteditable="false" data-primary="streams" data-secondary="time-varying relations in" data-type="indexterm" id="idm140176510115360"></a> We learned in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#streams_and_tables">Chapter&nbsp;6</a> that they too capture the evolution of a table over time. But they do so somewhat differently than the time-varying relations we’ve looked at so far. Instead of holistically capturing snapshots of the entire relation each time it changes, they capture the <em>sequence of changes</em> that result in those snapshots within a time-varying relation. The subtle difference here becomes more evident with an example.</p>

<p>As a refresher, recall again our baseline example <code><span class="code_grey">TVR</span></code> query:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:07&gt;</span> SELECT <span class="code_grey">TVR</span> Name, SUM(Score) as Total, MAX(Time) as Time
       FROM UserScores GROUP BY Name;</em></strong>
---------------------------------------------------------
|       [-inf, 12:01)       |       [12:01, 12:03)      |
| ------------------------- | ------------------------- |
| | Name  | Total | Time  | | | Name  | Total | Time  | |
| ------------------------- | ------------------------- |
| |       |       |       | | | Julie | 7     | 12:01 | |
| |       |       |       | | |       |       |       | |
| ------------------------- | ------------------------- |
---------------------------------------------------------
|       [12:03, 12:07)      |       [12:07, now)        |
| ------------------------- | ------------------------- |
| | Name  | Total | Time  | | | Name  | Total | Time  | |
| ------------------------- | ------------------------- |
| | Julie | 8     | 12:03 | | | Julie | 12    | 12:07 | |
| | Frank | 3     | 12:03 | | | Frank | 3     | 12:03 | |
| ------------------------- | ------------------------- |
---------------------------------------------------------
</pre>

<p>Let’s now observe our time-varying relation as a stream as it exists at a few distinct points in time. At each step of the way, we’ll compare the original table rendering of the TVR at that point in time with the evolution of the stream up to that point. To see what stream renderings of our time-varying relation look like, we’ll need to introduce two new hypothetical keywords:</p>

<ul>
	<li>
	<p>A <span class="code_purple"><code>STREAM</code></span> keyword, similar to the <span class="code_orange"><code>TABLE</code></span> keyword<a contenteditable="false" data-primary="STREAM keyword (hypothetical, in SQL)" data-type="indexterm" id="idm140176510103360"></a> I’ve already introduced, that indicates we want our query to return an event-by-event stream capturing the evolution of the time-varying relation over time. You can think of this as applying a per-record trigger to the relation over time.</p>
	</li>
	<li>
	<p>A special <code>Sys.Undo</code><sup><a data-type="noteref" id="idm140176510100624-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510100624" class="totri-footnote">3</a></sup> column that can be referenced from a <span class="code_purple"><code>STREAM</code></span> query, for the <a contenteditable="false" data-primary="Sys.Undo column (hypothetical, in SQL)" data-type="indexterm" id="idm140176510097728"></a>sake of identifying rows that are retractions. More on this in a moment.<a contenteditable="false" data-primary="STREAM queries (hypothetical, in SQL)" data-secondary="Sys.Undo column referenced from" data-type="indexterm" id="idm140176510096432"></a></p>
	</li>
</ul>

<p class="pagebreak-before">Thus, starting out from 12:01, we’d have the following:</p>

<pre data-type="programlisting"><strong><em>                                          <span class="code_blue">12:01&gt;</span> SELECT <span class="code_purple">STREAM</span> Name, </em></strong>
<strong><em><span class="code_blue">12:01&gt;</span> SELECT <span class="code_orange">TABLE</span> Name,                          SUM(Score) as Total,</em></strong>
<strong><em>         SUM(Score) as Total,                      MAX(Time) as Time,</em></strong>
<strong><em>         MAX(Time) as Time                         Sys.Undo as Undo</em></strong>
<strong><em>       FROM UserScores GROUP BY Name;            FROM UserScores GROUP BY Name;</em></strong>
-------------------------                 --------------------------------
| Name  | Total | Time  |                 | Name  | Total | Time  | Undo |
-------------------------                 --------------------------------
| Julie | 7     | 12:01 |                 | Julie | 7     | 12:01 |      |
-------------------------                 ........ [12:01, 12:01] ........
</pre>

<p>The table and stream renderings look almost identical at this point. Mod the <code>Undo</code> column (discussed in more detail in the next example), there’s only one difference: whereas the table version is complete as of 12:01 (signified by the final line of dashes closing off the bottom end of the relation), the stream version remains incomplete, as signified by the final ellipsis-like line of periods marking both the open tail of the relation (where additional data might be forthcoming in the future) as well as the processing-time range of data observed so far. And indeed, if executed on a real implementation, the <span class="code_purple"><code>STREAM</code></span> query would wait indefinitely for additional data to arrive. Thus, if we waited until 12:03, three new rows would show up for the <span class="code_purple"><code>STREAM</code></span> query. Compare that to a fresh <span class="code_orange"><code>TABLE</code></span> rendering of the TVR at 12:03:</p>

<pre data-type="programlisting"><strong><em>                                          <span class="code_blue">12:01&gt;</span> SELECT <span class="code_purple">STREAM</span> Name, </em></strong>
<strong><em><span class="code_blue">12:03&gt;</span> SELECT <span class="code_orange">TABLE</span> Name,                          SUM(Score) as Total,</em></strong>
<strong><em>         SUM(Score) as Total,                      MAX(Time) as Time,</em></strong>
<strong><em>         MAX(Time) as Time                         Sys.Undo as Undo</em></strong>
<strong><em>       FROM UserScores GROUP BY Name;            FROM UserScores GROUP BY Name;</em></strong>
-------------------------                 --------------------------------
| Name  | Total | Time  |                 | Name  | Total | Time  | Undo |
-------------------------                 --------------------------------
| Julie | 8     | 12:03 |                 | Julie | 7     | 12:01 |      |
| Frank | 3     | 12:03 |                 | Frank | 3     | 12:03 |      |
-------------------------                 | Julie | 7     | 12:03 | undo |
                                          | Julie | 8     | 12:03 |      |
                                          ........ [12:01, 12:03] ........
</pre>

<p>Here’s an interesting point worth addressing: why are there <em>three</em> new rows in the stream (Frank’s 3 and Julie’s undo-7 and 8) when our original dataset contained only <em>two</em> rows (Frank’s 3 and Julie’s 1) for that time period? The answer lies in the fact that here we are observing the stream of changes to an <em>aggregation</em> of the original inputs; in particular, for the time period from 12:01 to 12:03, the stream needs to capture two important pieces of information regarding the change in Julie’s aggregate score due to the arrival of the new 1 value:</p>

<ul>
	<li>
	<p>The previously reported total of 7 was incorrect.</p>
	</li>
	<li>
	<p>The new total is 8.</p>
	</li>
</ul>

<p>That’s what the special <code>Sys.Undo</code> column allows <a contenteditable="false" data-primary="Sys.Undo column (hypothetical, in SQL)" data-secondary="distinguishing between normal rows and rows retracting a previous value" data-type="indexterm" id="idm140176510070496"></a>us to do: distinguish between normal <a contenteditable="false" data-primary="retractions (accumulating and retracting mode)" data-secondary="in Sys.Undo column (hypothetical) in streaming SQL" data-type="indexterm" id="idm140176510068848"></a>rows and rows that are a <em>retraction</em> of a previously reported value.<sup><a data-type="noteref" id="idm140176510066704-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510066704" class="totri-footnote">4</a></sup></p>

<p>A particularly nice feature of <span class="code_purple"><code>STREAM</code></span> queries is that you can begin to see how all of this <a contenteditable="false" data-primary="STREAM queries (hypothetical, in SQL)" data-secondary="relation to OLTP tables" data-type="indexterm" id="idm140176510064368"></a>relates to the <a contenteditable="false" data-primary="OLTP (Online Transaction Processing) tables" data-secondary="STREAM queries and" data-type="indexterm" id="idm140176510062832"></a>world of classic Online Transaction Processing (OLTP) tables: the <span class="code_purple"><code>STREAM</code></span> rendering of this query is essentially capturing a sequence of <code>INSERT</code> and <code>DELETE</code> operations that you could use to materialize this relation over time in an OLTP world (and really, when you think about it, OLTP tables themselves are essentially time-varying relations mutated over time via a stream of <code>INSERT</code>s, <code>UPDATE</code>s, and <code>DELETE</code>s).</p>

<p>Now, if we don’t care about the retractions in the stream, it’s also perfectly fine not to ask for them. In that case, our <span class="code_purple"><code>STREAM</code></span> query would look like this:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:01&gt;</span> SELECT <span class="code_purple">STREAM</span> Name,</em></strong>
<strong><em>         SUM(Score) as Total,</em></strong>
<strong><em>         MAX(Time) as Time</em></strong>
<strong><em>       FROM UserScores GROUP BY Name;</em></strong>
------------------------- 
| Name  | Total | Time  |
------------------------- 
| Julie | 7     | 12:01 | 
| Frank | 3     | 12:03 |
| Julie | 8     | 12:03 |
.... [12:01, 12:03] .....
</pre>

<p>But there’s clearly value in understanding what the full stream looks like, so we’ll go back to including the <code>Sys.Undo</code> column for our final example. Speaking of which, if we waited another four minutes until 12:07, we’d be greeted by two additional rows in the <span class="code_purple"><code>STREAM</code></span> query, whereas the <span class="code_orange"><code>TABLE</code></span> query would continue to evolve as before:</p>

<pre data-type="programlisting"><strong><em>                                          <span class="code_blue">12:01&gt;</span> SELECT <span class="code_purple">STREAM</span> Name, </em></strong>
<strong><em><span class="code_blue">12:07&gt;</span> SELECT <span class="code_orange">TABLE</span> Name,                          SUM(Score) as Total,</em></strong>
<strong><em>         SUM(Score) as Total,                      MAX(Time) as Time,</em></strong>
<strong><em>         MAX(Time) as Time                         Sys.Undo as Undo</em></strong>
<strong><em>       FROM UserScores GROUP BY Name;            FROM UserScores GROUP BY Name;</em></strong>
-------------------------                 --------------------------------
| Name  | Total | Time  |                 | Name  | Total | Time  | Undo |
-------------------------                 --------------------------------
| Julie | 12    | 12:07 |                 | Julie | 7     | 12:01 |      |
| Frank | 3     | 12:03 |                 | Frank | 3     | 12:03 |      |
-------------------------                 | Julie | 7     | 12:03 | undo |
                                          | Julie | 8     | 12:03 |      |
                                          | Julie | 8     | 12:07 | undo |
                                          | Julie | 12    | 12:07 |      |
                                          ........ [12:01, 12:07] ........
</pre>

<p>And by this time, it’s quite clear that the <code><span class="code_purple">STREAM</span></code> version of our time-varying relation is a very different beast from the table version: the table captures a snapshot of the entire relation <em>at a specific point in time</em>, whereas the stream captures a view of the individual changes to the relation <em>over time</em>.<sup><a data-type="noteref" id="idm140176510039456-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510039456" class="totri-footnote">5</a></sup> Interestingly though, that means that the <span class="code_purple"><code>STREAM</code></span> rendering has more in common with our original, table-based TVR <span class="keep-together">rendering</span>:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:07&gt;</span> SELECT <span class="code_grey">TVR</span> Name, SUM(Score) as Total, MAX(Time) as Time
       FROM UserScores GROUP BY Name;</em></strong>
---------------------------------------------------------
|       [-inf, 12:01)       |       [12:01, 12:03)      |
| ------------------------- | ------------------------- |
| | Name  | Total | Time  | | | Name  | Total | Time  | |
| ------------------------- | ------------------------- |
| |       |       |       | | | Julie | 7     | 12:01 | |
| |       |       |       | | |       |       |       | |
| ------------------------- | ------------------------- |
---------------------------------------------------------
|       [12:03, 12:07)      |       [12:07, now)        |
| ------------------------- | ------------------------- |
| | Name  | Total | Time  | | | Name  | Total | Time  | |
| ------------------------- | ------------------------- |
| | Julie | 8     | 12:03 | | | Julie | 12    | 12:07 | |
| | Frank | 3     | 12:03 | | | Frank | 3     | 12:03 | |
| ------------------------- | ------------------------- |
---------------------------------------------------------
</pre>

<p>Indeed, it’s safe to<a contenteditable="false" data-primary="STREAM queries (hypothetical, in SQL)" data-secondary="providing alternate data history to table-based TVR query" data-type="indexterm" id="idm140176510032096"></a> say that the <span class="code_purple"><code>STREAM</code></span> query simply provides an alternate rendering of the entire history of data that exists in the corresponding <a contenteditable="false" data-primary="tables" data-secondary="table-based TVR vs. STREAM query TVR" data-type="indexterm" id="idm140176510029520"></a>table-based <span class="code_grey"><code>TVR</code></span> query. The value of the <span class="code_purple"><code>STREAM</code></span> rendering is its conciseness: it captures only the delta of changes between each of the point-in-time relation snapshots in the <span class="code_grey"><code>TVR</code></span>. The value of the sequence-of-tables <code><span class="code_grey">TVR</span></code> rendering is the clarity it provides: it captures the evolution of the relation over time in a format that highlights its natural relationship to classic relations, and in doing so provides for a simple and clear definition of relational semantics within the context of streaming as well as the additional dimension of time that streaming brings.</p>

<p>Another important aspect of the similarities between the <span class="code_purple"><code>STREAM</code></span> and table-based <code><span class="code_grey">TVR</span></code> renderings is the fact that they are essentially equivalent in the overall data they encode. This gets to the core of the stream/table duality that its proponents have long preached: streams and tables<sup><a data-type="noteref" id="idm140176510021664-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510021664" class="totri-footnote">6</a></sup> are really just two different sides of the same coin. Or to resurrect the bad physics analogy from <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#streams_and_tables">Chapter&nbsp;6</a>, streams and tables are to time-varying relations as waves and particles are to light:<sup><a data-type="noteref" id="idm140176510019824-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510019824" class="totri-footnote">7</a></sup> a complete time-varying relation is both a table and a stream at the same time; tables and streams are simply different physical manifestations of the same concept, depending upon the context.</p>

<p>Now, it’s important to keep in mind that this stream/table duality is true only as long as both versions encode the same information; that is, when you have full-fidelity tables or streams. In many cases, however, full fidelity is impractical. As I alluded to earlier, encoding the full history of a time-varying relation, no matter whether it’s in stream or table form, can be rather expensive for a large data source. It’s quite common for stream and table manifestations of a TVR to be lossy in some way. Tables typically encode only the most recent version of a TVR; those that support temporal or versioned access often compress the encoded history to specific point-in-time snapshots, and/or garbage-collect versions that are older than some threshold. Similarly, streams typically encode only a limited duration of the evolution of a TVR, often a relatively recent portion of that history. Persistent streams like Kafka afford the ability to encode the entirety of a TVR, but again this is relatively uncommon, with data older than some threshold typically thrown away via a garbage-collection process.</p>

<p>The main point here is that streams and tables are absolutely duals of one another, each a valid way of encoding a time-varying relation. But in practice, it’s common for the physical stream/table manifestations of a TVR to be lossy in some way. These partial-fidelity streams and tables trade off a decrease in total encoded information for some benefit, usually decreased resource costs. And these types of trade-offs are important because they’re often what allow us to build pipelines that operate over data sources of truly massive scale. But they also complicate matters, and require a deeper understanding to use correctly. We discuss this topic in more detail later on when we get to SQL language extensions. But before we try to reason about SQL extensions, it will be useful to understand a little more concretely the biases present in both the SQL and non-SQL data processing approaches common today.<a contenteditable="false" data-primary="time-varying relations" data-secondary="relationship with stream and table theory" data-startref="ix_TVRstrmtbl" data-type="indexterm" id="idm140176510016192"></a><a contenteditable="false" data-primary="streams and tables" data-secondary="time-varying relations in" data-startref="ix_strmtblTVR" data-type="indexterm" id="idm140176510014512"></a></p>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Looking Backward: Stream and Table Biases"><div class="sect1" id="idm140176510147552">
<h1>Looking Backward: Stream and Table Biases</h1>

<p>In many ways, the act of adding robust streaming <a contenteditable="false" data-primary="streaming SQL" data-secondary="looking backward, stream and table biases" data-type="indexterm" id="ix_SQLback"></a>support to SQL is largely an exercise in attempting <a contenteditable="false" data-primary="streams and tables" data-secondary="comparing classic SQL and Beam Model, looking backward" data-type="indexterm" id="ix_strmtblbi"></a>to merge the <em><span class="where_lt">where</span></em>, <em><span class="when_lt">when</span></em>, and <em><span class="how_lt">how</span></em> semantics of the Beam Model with the <em><span class="what_lt">what</span></em> semantics of the classic SQL model. But to do so cleanly, and in a way that remains true to the look and feel of classic SQL, requires an understanding of how the two models relate to each other. Thus, much as we explored the relationship of the Beam Model to stream and table theory in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#streams_and_tables">Chapter&nbsp;6</a>, we’ll now explore the relationship of the Beam Model to the classic SQL model, using stream and table theory as the underlying framework for our comparison. In doing so, we’ll uncover the inherent biases present in each model, which will provide us some insights in how to best marry the two in a clean, natural way.</p>

<section data-type="sect2" data-pdf-bookmark="The Beam Model: A Stream-Biased Approach"><div class="sect2" id="idm140176510002912">
<h2>The Beam Model: A Stream-Biased Approach</h2>

<p>Let’s begin with the Beam Model, building upon<a contenteditable="false" data-primary="streams and tables" data-secondary="comparing classic SQL and Beam Model, looking backward" data-tertiary="stream-biased approch in Beam Model" data-type="indexterm" id="ix_strmtblbiBM"></a> the discussion in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#streams_and_tables">Chapter&nbsp;6</a>. To begin, I want to discuss the inherent stream bias in the Beam Model as it exists today relative to streams and tables.</p>

<p>If you think back to Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#even_time_processing_time_view_of_windowed_summation">6-11</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#streams_and_tables_view_of_windowed_summation_on_a_streaming">6-12</a>, they showed two different views of the same score-summation pipeline that we’ve used as an example throughout the book: in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#even_time_processing_time_view_of_windowed_summation">Figure&nbsp;6-11</a> a logical, Beam-Model view, and in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#streams_and_tables_view_of_windowed_summation_on_a_streaming">Figure&nbsp;6-12</a> a physical, streams and tables–oriented view. Comparing the two helped highlight the relationship of the Beam Model to streams and tables. But by overlaying one on top of the other, as I’ve done in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#stream_bias_in_the_beam_model_approach">Figure&nbsp;8-1</a>, we can see an additional interesting aspect of the relationship: the Beam Model’s inherent stream bias.</p>

<figure><div id="stream_bias_in_the_beam_model_approach" class="figure"><img alt="" class="iimagesch08fig_0801_beamoverlaypng" src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0801.png" width="579" height="800" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0801.png">
<h6><span class="label">Figure 8-1. </span>Stream bias in the Beam Model approach</h6>
</div></figure>

<p>In this figure, I’ve drawn dashed red lines connecting the transforms in the logical view to their corresponding components in the physical view. The thing that stands out when observed this way is that all of the logical transformations are connected by <em>streams</em>, even the operations that involve grouping (which we know from <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#streams_and_tables">Chapter&nbsp;6</a> results in a table being created <em>somewhere</em>). In Beam parlance, these transformations are <code>PTransforms</code>, and they are always applied to <code>PCollections</code> to yield new <code><span class="keep-together">PCollections</span></code>. The important takeaway here is that <code>PCollections</code> in Beam are <em>always</em> streams. As a result, the Beam Model is an inherently stream-biased approach to data processing: streams are the common currency in a Beam pipeline (even batch pipelines), and tables are always treated specially, either abstracted behind sources and sinks at the edges of the pipeline or hidden away beneath a grouping and triggering operation somewhere in the pipeline.</p>

<p>Because Beam operates in terms of streams, anywhere a table is involved (sources, sinks, and any intermediate groupings/ungroupings), some sort of conversion is necessary to keep the underlying table hidden. Those conversions in Beam look something like this:</p>

<ul>
	<li>
	<p><em>Sources</em> that <em>consume</em> tables typically hardcode the manner in which those tables are <em>triggered</em>; there is no way for a user to specify custom triggering of the table they want to consume. The source may be written to trigger every new update to the table as a record, it might batch groups of updates together, or it might provide a single, bounded snapshot of the data in the table at some point in time. It really just depends on what’s practical for a given source, and what use case the author of the source is trying to address.</p>
	</li>
	<li>
	<p><em>Sinks</em> that <em>write</em> tables typically hardcode the manner in which they <em>group</em> their input streams. Sometimes, this is done in a way that gives the user a certain amount of control; for example, by simply grouping on a user-assigned key. In other cases, the grouping might be implicitly defined; for example, by grouping on a random physical partition number when writing input data with no natural key to a sharded output source. As with sources, it really just depends on what’s practical for the given sink and what use case the author of the sink is trying to address.</p>
	</li>
	<li>
	<p>For <em>grouping/ungrouping operations</em>, in contrast to sources and sinks, Beam provides users complete flexibility in how they group data into tables and ungroup them back into streams.<a contenteditable="false" data-primary="grouping operations" data-secondary="grouping/ungrouping in Beam Model" data-type="indexterm" id="idm140176509975952"></a> This is by design. Flexibility in grouping operations is necessary because the way data are grouped is a key ingredient of the algorithms that define a pipeline. <a contenteditable="false" data-primary="ungrouping operations" data-seealso="grouping operations" data-type="indexterm" id="idm140176509974240"></a>And flexibility in ungrouping is important so that the application can shape the generated streams in ways that are appropriate for the use case at hand.<sup><a data-type="noteref" id="idm140176509972560-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509972560" class="totri-footnote">8</a></sup></p>

	<p>However, there’s a wrinkle here. Remember from <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#stream_bias_in_the_beam_model_approach">Figure&nbsp;8-1</a> that the Beam Model is inherently biased toward streams. As result, although it’s possible to cleanly apply a grouping operation directly to a stream (this is Beam’s <code>GroupByKey</code> operation), the model never provides first-class table objects to which a trigger can be directly applied. As a result, triggers must be applied somewhere else. There are basically two options<a contenteditable="false" data-primary="triggers" data-secondary="predeclaration or post-declaration options, Beam Model and" data-type="indexterm" id="idm140176509728496"></a> here:</p>

	<dl>
		<dt>Predeclaration of triggers</dt>
		<dd>
		<p>This is where triggers are specified<a contenteditable="false" data-primary="predeclaration of triggers" data-type="indexterm" id="idm140176509725248"></a> at a point in the pipeline <em>before</em> the table to which they are actually applied. In this case, you’re essentially prespecifying behavior you’d like to see later on in the pipeline after a grouping operation is encountered. When declared this way, triggers are <em>forward-propagating</em>.</p>
		</dd>
		<dt>Post-declaration of triggers</dt>
		<dd>
		<p>This is where triggers<a contenteditable="false" data-primary="post-declaration of triggers" data-type="indexterm" id="idm140176509721424"></a> are specified at a point in the pipeline <em>following</em> the table to which they are applied. In this case, you’re specifying the behavior you’d like to see at the point where the trigger is declared. When declared this way, triggers are <em>backward-propagating</em>.</p>
		</dd>
	</dl>

	<p>Because post-declaration of triggers allows you to specify the behavior you want at the actual place you want to observe it, it’s much more intuitive. Unfortunately, Beam as it exists today (2.x and earlier) uses predeclaration of triggers (similar to how windowing is also predeclared).</p>
	</li>
</ul>

<p>Even though Beam provides a number of ways to cope with the fact that tables are hidden, we’re still left with the fact that tables must always be triggered before they can be observed, even if the contents of that table are really the final data that you want to consume. This is a shortcoming of the Beam Model as it exists today, one which could be addressed by moving away from a stream-centric model and toward one that treats both streams and tables as first-class entities.</p>

<p>Let’s now look at the Beam Model’s conceptual converse: classic SQL.<a contenteditable="false" data-primary="streams and tables" data-secondary="comparing classic SQL and Beam Model, looking backward" data-startref="ix_strmtblbiBM" data-tertiary="stream-biased approch in Beam Model" data-type="indexterm" id="idm140176509716400"></a></p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="The SQL Model: A Table-Biased Approach"><div class="sect2" id="idm140176509714240">
<h2>The SQL Model: A Table-Biased Approach</h2>

<p>In contrast to the Beam Model’s<a contenteditable="false" data-primary="streams and tables" data-secondary="comparing classic SQL and Beam Model, looking backward" data-tertiary="table-biased approach in SQL" data-type="indexterm" id="ix_strmtblbiSQL"></a> stream-biased approach, SQL has historically taken a table-biased<a contenteditable="false" data-primary="SQL" data-secondary="table-biased approach" data-type="indexterm" id="ix_SQLtbl"></a> approach: queries are applied to tables, and always result in new tables. This is similar to the batch processing model we looked at in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#streams_and_tables">Chapter&nbsp;6</a> with MapReduce,<sup><a data-type="noteref" id="idm140176509707168-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509707168" class="totri-footnote">9</a></sup> but it will be useful to consider a concrete example like the one we just looked at for the Beam Model.</p>

<p>Consider the following denormalized SQL table:</p>

<pre data-type="programlisting">UserScores (user, team, score, timestamp)
</pre>

<p>It contains user scores, each annotated with the IDs of the corresponding user and their corresponding team. There is no primary key, so you can assume that this is an append-only table, with each row being identified implicitly by its unique physical offset. If we want to compute team scores from this table, we could use a query that looks something like this:</p>

<pre data-type="programlisting">    SELECT team, SUM(score) as total
    FROM UserScores
    GROUP BY team;
</pre>

<p>When executed by a query engine, the optimizer will probably break this query down into roughly three steps:</p>

<ol>
	<li>
	<p>Scanning the input table (i.e., triggering a snapshot of it)</p>
	</li>
	<li>
	<p>Projecting the fields in that table down to team and score</p>
	</li>
	<li>
	<p>Grouping rows by team and summing the scores</p>
	</li>
</ol>

<p>If we look at this using a diagram similar to <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#stream_bias_in_the_beam_model_approach">Figure&nbsp;8-1</a>, it would look like <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#table_bias_in_a_simple_sql_query">Figure&nbsp;8-2</a>.</p>

<p>The <code>SCAN</code> operation takes the input table and triggers it into a bounded stream that contains a snapshot of the contents of that table at query execution time. That stream is consumed by the <code>SELECT</code> operation, which projects the four-column input rows down to two-column output rows. Being a nongrouping operation, it yields another stream. Finally, that two-column stream of teams and user scores enters the <code>GROUP BY</code> and is grouped by team into a table, with scores for the same team <code>SUM</code>’d together, yielding our output table of teams and their corresponding team score totals.</p>

<figure class="smallereighty"><div id="table_bias_in_a_simple_sql_query" class="figure"><img src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0802.png" width="600" height="625" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0802.png">
<h6><span class="label">Figure 8-2. </span>Table bias in a simple SQL query</h6>
</div></figure>

<p>This is a relatively simple example that naturally ends in a table, so it really isn’t sufficient to highlight the table-bias in classic SQL. But we can tease out some more evidence by simply splitting the main pieces of this query (projection and grouping) into two separate queries:</p>

<pre data-type="programlisting">    SELECT team, score
    INTO TeamAndScore
    FROM UserScores;

    SELECT team, SUM(score) as total
    INTO TeamTotals
    FROM TeamAndScore
    GROUP BY team;
</pre>

<p>In these queries, we first project the <code>UserScores</code> table down to just the two columns we care about, storing the results in a temporary <code>TeamAndScore</code> table. We then group that table by team, summing up the scores as we do so. After breaking things out into a pipeline of two queries, our diagram looks like that shown in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#breaking_the_query_into_two_to_surface_more_evidence_of_table_bias">Figure&nbsp;8-3</a>.</p>

<figure class="smallerninety"><div id="breaking_the_query_into_two_to_surface_more_evidence_of_table_bias" class="figure"><img src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0803.png" width="518" height="800" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0803.png">
<h6><span class="label">Figure 8-3. </span>Breaking the query into two to reveal more evidence of table bias</h6>
</div></figure>

<p>If classic SQL exposed streams as first-class objects, you would expect the result from the first query, <code>TeamAndScore</code>, to be a stream because the <code>SELECT</code> operation consumes a stream and produces a stream. But because SQL’s common currency is tables, it must first convert the projected stream into a table. And because the user hasn’t specified any explicit key for grouping, it must simply group keys by their identity (i.e., append semantics, typically implemented by grouping by the physical storage offset for each row).</p>

<p>Because <code>TeamAndScore</code> is now a table, the second query must then prepend an additional <code>SCAN</code> operation to scan the table back into a stream to allow the <code>GROUP BY</code> to then group it back into a table again, this time with rows grouped by team and with their individual scores summed together. Thus, we see the two implicit conversions (from a stream and back again) that are inserted due to the explicit materialization of the intermediate table.</p>

<p>That said, tables in SQL are not <em>always</em> explicit; implicit tables can exist, <a contenteditable="false" data-primary="tables" data-secondary="explicit and implicit in SQL" data-type="indexterm" id="idm140176509681552"></a>as well. For example, if<a contenteditable="false" data-primary="GROUP BY statement with HAVING clause (SQL)" data-type="indexterm" id="idm140176509679984"></a> we <a contenteditable="false" data-primary="HAVING clause in GROUP BY statment (SQL)" data-type="indexterm" id="idm140176509678656"></a>were to add a <code>HAVING</code> clause to <a contenteditable="false" data-primary="implicit tables in SQL" data-type="indexterm" id="idm140176509676912"></a>the end of the query with the <code>GROUP BY</code> statement, to filter out teams with scores less than a certain threshold, the diagram would change to look something like <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#table_bias_with_a_final_having_clause">Figure&nbsp;8-4</a>.</p>

<figure><div id="table_bias_with_a_final_having_clause" class="figure"><img src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0804.png" width="367" height="800" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0804.png">
<h6><span class="label">Figure 8-4. </span>Table bias with a final HAVING clause</h6>
</div></figure>

<p>With the addition of the <code>HAVING</code> clause, what used to be the user-visible <code>TeamTotals</code> table is now an implicit, intermediate table. To filter the results of the table according to the rules in the <code>HAVING</code> clause, that table must be triggered into a stream that can be filtered and then that stream must be implicitly grouped back into a table to yield the new output table, <code>LargeTeamTotals</code>.</p>

<p>The important takeaway here is the clear table bias in classic SQL. Streams are always implicit, and thus for any materialized stream a conversion from/to a table is required. <a contenteditable="false" data-primary="tables" data-secondary="conversion of streams from/to in SQL" data-type="indexterm" id="idm140176509669504"></a>The rules for such conversions can be categorized roughly as follows:</p>

<dl>
	<dt>Input tables (i.e., sources, in Beam Model terms)</dt>
	<dd>
	<p>These are always implicitly triggered in their entirety <a contenteditable="false" data-primary="input tables (SQL)" data-type="indexterm" id="idm140176509666096"></a>at a specific point in time<sup><a data-type="noteref" id="idm140176509664688-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509664688">10</a></sup> (generally query execution time) to<a contenteditable="false" data-primary="sources" data-type="indexterm" id="idm140176509663760"></a> yield a bounded stream containing a snapshot of the table at that time. This is identical to what you get with classic batch processing, as well; for example, the MapReduce case we looked at in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#streams_and_tables">Chapter&nbsp;6</a>.</p>
	</dd>
	<dt>Output tables (i.e., sinks, in Beam Model terms)</dt>
	<dd>
	<p>These tables are either direct manifestations of a table created by a final grouping operation<a contenteditable="false" data-primary="output tables (SQL)" data-type="indexterm" id="idm140176509659904"></a> in the query, <a contenteditable="false" data-primary="sinks" data-type="indexterm" id="idm140176509658672"></a>or are the result of an implicit grouping (by some unique identifier for the row) applied to a query’s terminal stream, for queries that do not end in a grouping operation (e.g., the projection query in the previous examples, or a <code>GROUP BY</code> followed by a <code>HAVING</code> clause). As with inputs, this matches the behavior seen in classic batch processing.</p>
	</dd>
	<dt>Grouping/ungrouping operations</dt>
	<dd>
	<p>Unlike Beam, these operations provide complete flexibility in one <a contenteditable="false" data-primary="grouping operations" data-secondary="grouping/ungrouping in SQL" data-type="indexterm" id="idm140176509654960"></a>dimension only: grouping. Whereas classic SQL queries provide a full suite of grouping operations (<code>GROUP BY</code>, <code>JOIN</code>, <code>CUBE</code>, etc.), they provide only a single type of implicit ungrouping operation: trigger an intermediate table in its entirety after all of the upstream data contributing to it have been incorporated (again, the exact same implicit trigger provided in MapReduce as part of the shuffle operation). As a result, SQL offers great flexibility in shaping algorithms via grouping but essentially zero flexibility in shaping the implicit streams that exist under the covers during query execution.</p>
	</dd>
</dl>

<section data-type="sect3" data-pdf-bookmark="Materialized views"><div class="sect3" id="idm140176509651040">
<h3>Materialized views</h3>

<p>Given how analogous classic SQL queries are to classic batch processing, it might be tempting to write off SQL’s inherent table bias as nothing more than an artifact of SQL not supporting stream processing in any way. <a contenteditable="false" data-primary="streaming" data-secondary="support for stream processing in SQL materialized views" data-type="indexterm" id="ix_strmSQL"></a><a contenteditable="false" data-primary="materialized views" data-type="indexterm" id="ix_matview"></a>But to do so would be to ignore the fact that databases have supported a specific type of stream processing for quite some time: <em>materialized views</em>. A materialized view is a view that is physically materialized as a table and kept up to date <em>over</em> time by the database as the source table(s) evolve. Note how this sounds remarkably similar to our definition of a time-varying relation. What’s fascinating about materialized views is that they add a very useful form of stream processing to SQL <em>without</em> significantly altering the way it operates, including its inherent table bias.</p>

<p>For example, let’s consider the queries we looked at in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#table_bias_with_a_final_having_clause">Figure&nbsp;8-4</a>. We can alter those queries to instead be <code>CREATE MATERIALIZED VIEW</code><sup><a data-type="noteref" id="idm140176509642384-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509642384">11</a></sup> statements:</p>

<pre data-type="programlisting">    CREATE MATERIALIZED VIEW TeamAndScoreView AS
    SELECT team, score
    FROM UserScores;

    CREATE MATERIALIZED VIEW LargeTeamTotalsView AS
    SELECT team, SUM(score) as total
    FROM TeamAndScoreView
    GROUP BY team
    HAVING SUM(score) &gt; 100;
</pre>

<p>In doing so, we transform them into continuous, standing queries that process the updates to the <code>UserScores</code> table continuously, in a streaming manner. Even so, the resulting physical execution diagram for the views <em>looks almost exactly the same</em> as it did for the one-off queries; nowhere are streams made into explicit first-class objects in order to support this idea of streaming materialized views. <a contenteditable="false" data-primary="triggers" data-secondary="SCAN-AND-STREAM trigger in materialized views" data-type="indexterm" id="idm140176509636400"></a><a contenteditable="false" data-primary="SCAN-AND-STREAM trigger" data-type="indexterm" id="idm140176509634960"></a>The <em>only</em> noteworthy change in the physical execution plan is the substitution of a different trigger: <code>SCAN-AND-STREAM</code> instead of <code>SCAN</code>, as illustrated in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#table_bias_in_materialized_views">Figure&nbsp;8-5</a>.</p>

<figure><div id="table_bias_in_materialized_views" class="figure"><img src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0805.png" width="367" height="800" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0805.png">
<h6><span class="label">Figure 8-5. </span>Table bias in materialized views</h6>
</div></figure>

<p>What is this <code>SCAN-AND-STREAM</code> trigger? <code>SCAN-AND-STREAM</code> starts out like a <code>SCAN</code> trigger, emitting the full contents of the table at a point in time into a stream. But instead of stopping there and declaring the stream to be done (i.e., bounded), it continues to also trigger all subsequent modifications to the input table, yielding an unbounded stream that captures the evolution of the table over time. In the general case, these modifications include not only <code>INSERT</code>s of new values, but also <code>DELETE</code>s of previous values and <code>UPDATE</code>s to existing values (which, practically speaking, are treated as a simultaneous <code>DELETE</code>/<code>INSERT</code> pair, or <code>undo</code>/<code>redo</code> values as they are called in Flink).</p>

<p>Furthermore, if we consider the table/stream conversion rules for materialized views, the only real difference is the trigger used:</p>

<ul>
	<li>
	<p><em>Input tables</em> are implicitly triggered via a <code>SCAN-AND-STREAM</code> trigger<a contenteditable="false" data-primary="input tables (SQL)" data-type="indexterm" id="idm140176509621952"></a> instead of a <code>SCAN</code> trigger. Everything else is the same as classic batch queries.</p>
	</li>
	<li>
	<p><em>Output tables</em> are treated the same as classi<a contenteditable="false" data-primary="output tables (SQL)" data-type="indexterm" id="idm140176509618960"></a>c batch queries.</p>
	</li>
	<li>
	<p><em>Grouping/ungrouping operations</em> function the same as classic batch queries, <a contenteditable="false" data-primary="grouping operations" data-secondary="grouping/ungrouping in SQL" data-tertiary="in materialized views" data-type="indexterm" id="idm140176509616496"></a>with the only difference being the use of a <code>SCAN-AND-STREAM</code> trigger instead of a <code>SNAPSHOT</code> trigger for implicit ungrouping operations.</p>
	</li>
</ul>

<p>Given this example, it’s clear to see that SQL’s inherent table bias is not just an artifact of SQL being limited to batch processing:<sup><a data-type="noteref" id="idm140176509612640-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509612640">12</a></sup> materialized views lend SQL the ability to perform a specific type of stream processing without any significant changes in approach, including the inherent bias toward tables. Classic SQL is just a table-biased model, regardless <a contenteditable="false" data-primary="streaming" data-secondary="support for stream processing in SQL materialized views" data-startref="ix_strmSQL" data-type="indexterm" id="idm140176509611184"></a>of whether<a contenteditable="false" data-primary="materialized views" data-startref="ix_matview" data-type="indexterm" id="idm140176509609312"></a> you’re using it for batch or stream processing.<a contenteditable="false" data-primary="streaming SQL" data-secondary="looking backward, stream and table biases" data-startref="ix_SQLback" data-type="indexterm" id="idm140176509607776"></a><a contenteditable="false" data-primary="streams and tables" data-secondary="comparing classic SQL and Beam Model, looking backward" data-startref="ix_strmtblbiSQL" data-tertiary="table-biased approach in SQL" data-type="indexterm" id="idm140176509606032"></a><a contenteditable="false" data-primary="SQL" data-secondary="table-biased approach" data-startref="ix_SQLtbl" data-type="indexterm" id="idm140176509604112"></a><a contenteditable="false" data-primary="streams and tables" data-secondary="comparing classic SQL and Beam Model, looking backward" data-startref="ix_strmtblbi" data-type="indexterm" id="idm140176509602464"></a></p>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Looking Forward: Toward Robust Streaming SQL"><div class="sect1" id="idm140176509713328">
<h1>Looking Forward: Toward Robust Streaming SQL</h1>

<p>We’ve now looked at time-varying <a contenteditable="false" data-primary="streaming SQL" data-secondary="looking forward, toward robust streaming" data-type="indexterm" id="ix_SQLforstrm"></a>relations, the ways in which tables and streams provide different renderings of a time-varying relation, and what the inherent biases of the Beam and SQL models are with respect to stream and table theory. So where does all of this leave us? And perhaps more to the point, what do we need to change or add within SQL to support robust stream processing? The surprising answer is: not much if we have good defaults.</p>

<p>We know that the key conceptual change is to replace classic, point-in-time relations with time-varying relations. We saw earlier that this is a very seamless substitution, one which applies across the full breadth of relational operators already in existence, thanks to maintaining the critical closure property of relational algebra. But we also saw that dealing in time-varying relations directly is often impractical; we need the ability to operate in terms of our two more-common physical manifestations: tables and streams. This is where some simple extensions with good defaults come in.</p>

<p>We also need some tools for robustly reasoning about time, specifically event time. This is where things like timestamps, windowing, and triggering come into play. But again, judicious choice of defaults will be important to minimize how often these extensions are necessary in practice.</p>

<p>What’s great is that we don’t really need anything more than that. So let’s now finally spend some time looking in detail at these two categories of extensions: <em>stream/table selection</em> and <em>temporal operators</em>.</p>

<section data-type="sect2" data-pdf-bookmark="Stream and Table Selection"><div class="sect2" id="idm140176509594256">
<h2>Stream and Table Selection</h2>

<p>As we worked through time-varying relation examples, we already encountered the two key extensions related to<a contenteditable="false" data-primary="SELECT statement (SQL), STREAM and TABLE keywords after" data-type="indexterm" id="idm140176509592400"></a> stream and table selection.<a contenteditable="false" data-primary="streaming SQL" data-secondary="looking forward, toward robust streaming" data-tertiary="stream and table selection" data-type="indexterm" id="idm140176509591136"></a> They<a contenteditable="false" data-primary="STREAM keyword (hypothetical, in SQL)" data-type="indexterm" id="idm140176509589264"></a> were <a contenteditable="false" data-primary="TABLE keyword (hypothetical, in SQL)" data-type="indexterm" id="idm140176509587984"></a>those <code><span class="code_orange">TABLE</span></code> and <code><span class="code_purple">STREAM</span></code> keywords we placed after the <code>SELECT</code> keyword to dictate our desired physical view of a given time-varying relation:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:07&gt;</span> SELECT <span class="code_orange">TABLE</span> Name,                 <span class="code_blue">12:01&gt;</span> SELECT <span class="code_purple">STREAM</span> Name</em></strong>
<strong><em>         SUM(Score) as Total,                      SUM(Score) as Total,</em></strong>                      
<strong><em>         MAX(Time)                                 MAX(Time)</em></strong> 
<strong><em>       </em></strong><strong><em>FROM UserScores                           FROM UserScores</em></strong>
<strong><em>       GROUP BY Name;                            GROUP BY Name;</em></strong>
-------------------------                 -------------------------
| Name  | Total | Time  |                 | Name  | Total | Time  |
-------------------------                 -------------------------
| Julie | 12    | 12:07 |                 | Julie | 7     | 12:01 |
| Frank | 3     | 12:03 |                 | Frank | 3     | 12:03 |
-------------------------                 | Julie | 8     | 12:03 |
                                          | Julie | 12    | 12:07 |
                                          ..... [12:01, 12:07] ....
</pre>

<p>These extensions are <a contenteditable="false" data-primary="time-varying relations" data-type="indexterm" id="idm140176509576768"></a>relatively straightforward and easy to use when necessary. But the really important thing regarding stream and table selection is the choice of good defaults for times when they aren’t explicitly provided. Such defaults should honor the classic, table-biased behavior of SQL that everyone is accustomed to, while also operating intuitively in a world that includes streams. They should also be easy to remember. The goal here is to help maintain a natural feel to the system, while also greatly decreasing the frequency with which we must use explicit extensions. A good choice of defaults that satisfies all of these requirements is:</p>

<ul>
	<li>
	<p>If <em>all</em> of the inputs are <em><span class="code_orange">tables</span></em>, the output is a <em><span class="code_orange"><code>TABLE</code></span></em>.</p>
	</li>
	<li>
	<p>If <em>any</em> of the inputs are <em><span class="code_purple">streams</span></em>, the output is a <em><span class="code_purple"><code>STREAM</code></span></em>.</p>
	</li>
</ul>

<p>What’s additionally important to call out here is that these physical renderings of a time-varying relation are really only necessary when you want to materialize the TVR in some way, either to view it directly or write it to some output table or stream. Given a SQL system that operates under the covers in terms of full-fidelity time-varying relations, intermediate results (e.g., <code>WITH AS</code> or <code>SELECT INTO</code> statements) can remain as full-fidelity TVRs in whatever format the system naturally deals in, with no need to render them into some other, more limited concrete manifestation.</p>

<p>And that’s really it for stream and table selection. Beyond the ability to deal in streams and tables directly, we also need some better tools for reasoning about time if we want to support robust, out-of-order stream processing within SQL. Let’s now look in more detail about what those entail.</p>
</div></section>

<section data-type="sect2" data-pdf-bookmark="Temporal Operators"><div class="sect2" id="idm140176509565264">
<h2>Temporal Operators</h2>

<p>The foundation of robust, out-of-order processing is the event-time timestamp: that small piece of metadata that captures <a contenteditable="false" data-primary="temporal operators (in streaming SQL)" data-type="indexterm" id="ix_tempop"></a>the time <a contenteditable="false" data-primary="streaming SQL" data-secondary="looking forward, toward robust streaming" data-tertiary="temporal operators" data-type="indexterm" id="ix_SQLforstrmto"></a>at which an event occurred rather than the time at which it is observed. In a SQL world, event time is typically just another column of data for a given TVR, one which is natively present in the source data themselves.<sup><a data-type="noteref" id="idm140176509559248-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509559248">13</a></sup> In that sense, this idea of materializing a record’s event time within the record itself is something SQL already handles naturally by putting a timestamp in a regular column.</p>

<p>Before we go any further, let’s look at an example. To help tie all of this SQL stuff together with the concepts we’ve explored previously in the book, we resurrect our running example of summing up nine scores from various members of a team to arrive at that team’s total score. If you recall, those scores look like <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#data_points_in_our_running_example">Figure&nbsp;8-6</a> when plotted on X = event-time/Y = processing-time axes.</p>

<figure class="smallersixty"><div id="data_points_in_our_running_example" class="figure"><img src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0806.png" width="600" height="360" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0806.png">
<h6><span class="label">Figure 8-6. </span>Data points in our running example</h6>
</div></figure>

<p>If we were to imagine these data as a classic SQL table, they might look something like this, ordered by event time (left-to-right in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#data_points_in_our_running_example">Figure&nbsp;8-6</a>):</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:10&gt;</span> SELECT <span class="code_orange">TABLE</span> *, Sys.MTime as ProcTime
       FROM UserScores ORDER BY EventTime;</em></strong>
------------------------------------------------
| Name  | Team  | Score | EventTime | ProcTime |
------------------------------------------------
| Julie | TeamX |     5 |  12:00:26 | 12:05:19 |
| Frank | TeamX |     9 |  12:01:26 | 12:08:19 |
| Ed    | TeamX |     7 |  12:02:26 | 12:05:39 |
| Julie | TeamX |     8 |  12:03:06 | 12:07:06 |
| Amy   | TeamX |     3 |  12:03:39 | 12:06:13 |
| Fred  | TeamX |     4 |  12:04:19 | 12:06:39 |
| Naomi | TeamX |     3 |  12:06:39 | 12:07:19 |
| Becky | TeamX |     8 |  12:07:26 | 12:08:39 |
| Naomi | TeamX |     1 |  12:07:46 | 12:09:00 |
------------------------------------------------
</pre>

<p>If you recall, we saw this table way back in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch02.html#the_what_where_when_and_how">Chapter&nbsp;2</a> when I first introduced this dataset. This rendering provides a little more detail on the data than we’ve typically shown, explicitly highlighting the fact that the nine scores themselves belong to seven different users, each a member of the same team. SQL provides a nice, concise way to see the data laid out fully before we begin diving into examples.</p>

<p>Another nice<a contenteditable="false" data-primary="event time" data-secondary="in streaming SQL" data-type="indexterm" id="idm140176509547456"></a> thing <a contenteditable="false" data-primary="processing time" data-secondary="in streaming SQL" data-type="indexterm" id="idm140176509545920"></a>about this view of the data is that it fully captures the event time and processing time for each record.<a contenteditable="false" data-primary="Sys.MTime column (hypothetical, in SQL)" data-type="indexterm" id="idm140176509544256"></a> You can imagine the event-time column as being just another piece of the original data, and the processing-time column as being something supplied by the system (in this case, using a hypothetical <code>Sys.MTime</code> column that records the processing-time modification timestamp of a given row; that is, the time at which that row arrived in the source table), capturing the ingress time of the records themselves into the system.</p>

<p>The fun thing about SQL is how easy it is to view your data in different ways. For example, if we instead want to see the data in processing-time order (bottom-to-top in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#data_points_in_our_running_example">Figure&nbsp;8-6</a>), we could simply update the <code>ORDER BY</code> clause:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:10&gt;</span> SELECT <span class="code_orange">TABLE</span> *, Sys.MTime as ProcTime</em></strong>
<strong><em>       FROM UserScores <span class="grey_bg">ORDER BY ProcTime;</span></em></strong>
-----------------------------------------------
| Name  | Team  | Score | EventTime | ProcTime |
-----------------------------------------------
| Julie | TeamX |     5 |  12:00:26 | 12:05:19 |
| Ed    | TeamX |     7 |  12:02:26 | 12:05:39 |
| Amy   | TeamX |     3 |  12:03:39 | 12:06:13 |
| Fred  | TeamX |     4 |  12:04:19 | 12:06:39 |
| Julie | TeamX |     8 |  12:03:06 | 12:07:06 |
| Naomi | TeamX |     3 |  12:06:39 | 12:07:19 |
| Frank | TeamX |     9 |  12:01:26 | 12:08:19 |
| Becky | TeamX |     8 |  12:07:26 | 12:08:39 |
| Naomi | TeamX |     1 |  12:07:46 | 12:09:00 |
------------------------------------------------
</pre>

<p>As we learned earlier, these table renderings of the data are really a partial-fidelity view of the complete underlying TVR. If we were to instead query the full table-oriented <code>TVR</code> (but only for the three most important columns, for the sake of brevity), it would expand to something like this:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:10&gt;</span> SELECT <span class="code_grey">TVR</span> Score, EventTime, Sys.MTime as ProcTime
       FROM UserScores ORDER BY ProcTime;</em></strong>
-----------------------------------------------------------------------
|         [-inf, 12:05:19)         |       [12:05:19, 12:05:39)       | 
| -------------------------------- | -------------------------------- | 
| | Score | EventTime | ProcTime | | | Score | EventTime | ProcTime | |
| -------------------------------- | -------------------------------- |
| -------------------------------- | |     5 |  12:00:26 | 12:05:19 | |
|                                  | -------------------------------- |
|                                  |                                  |
-----------------------------------------------------------------------
|       [12:05:39, 12:06:13)       |       [12:06:13, 12:06:39)       | 
| -------------------------------- | -------------------------------- | 
| | Score | EventTime | ProcTime | | | Score | EventTime | ProcTime | |
| -------------------------------- | -------------------------------- |
| |     5 |  12:00:26 | 12:05:19 | | |     5 |  12:00:26 | 12:05:19 | |
| |     7 |  12:02:26 | 12:05:39 | | |     7 |  12:02:26 | 12:05:39 | |
| -------------------------------- | |     3 |  12:03:39 | 12:06:13 | |
|                                  | -------------------------------- |
-----------------------------------------------------------------------
|       [12:06:39, 12:07:06)       |       [12:07:06, 12:07:19)       |
| -------------------------------- | -------------------------------- |
| | Score | EventTime | ProcTime | | | Score | EventTime | ProcTime | |
| -------------------------------- | -------------------------------- |
| |     5 |  12:00:26 | 12:05:19 | | |     5 |  12:00:26 | 12:05:19 | |
| |     7 |  12:02:26 | 12:05:39 | | |     7 |  12:02:26 | 12:05:39 | |
| |     3 |  12:03:39 | 12:06:13 | | |     3 |  12:03:39 | 12:06:13 | |
| |     4 |  12:04:19 | 12:06:39 | | |     4 |  12:04:19 | 12:06:39 | |
| -------------------------------- | |     8 |  12:03:06 | 12:07:06 | |
|                                  | -------------------------------- |
-----------------------------------------------------------------------
|       [12:07:19, 12:08:19)       |       [12:08:19, 12:08:39)       | 
| -------------------------------- | -------------------------------- | 
| | Score | EventTime | ProcTime | | | Score | EventTime | ProcTime | |
| -------------------------------- | -------------------------------- |
| |     5 |  12:00:26 | 12:05:19 | | |     5 |  12:00:26 | 12:05:19 | |
| |     7 |  12:02:26 | 12:05:39 | | |     7 |  12:02:26 | 12:05:39 | |
| |     3 |  12:03:39 | 12:06:13 | | |     3 |  12:03:39 | 12:06:13 | |
| |     4 |  12:04:19 | 12:06:39 | | |     4 |  12:04:19 | 12:06:39 | |
| |     8 |  12:03:06 | 12:07:06 | | |     8 |  12:03:06 | 12:07:06 | |
| |     3 |  12:06:39 | 12:07:19 | | |     3 |  12:06:39 | 12:07:19 | |
| -------------------------------- | |     9 |  12:01:26 | 12:08:19 | |
|                                  | -------------------------------- |
|                                  |                                  |
-----------------------------------------------------------------------
|       [12:08:39, 12:09:00)       |         [12:09:00, now)          |
| -------------------------------- | -------------------------------- |
| | Score | EventTime | ProcTime | | | Score | EventTime | ProcTime | |
| -------------------------------- | -------------------------------- |
| |     5 |  12:00:26 | 12:05:19 | | |     5 |  12:00:26 | 12:05:19 | |
| |     7 |  12:02:26 | 12:05:39 | | |     7 |  12:02:26 | 12:05:39 | |
| |     3 |  12:03:39 | 12:06:13 | | |     3 |  12:03:39 | 12:06:13 | |
| |     4 |  12:04:19 | 12:06:39 | | |     4 |  12:04:19 | 12:06:39 | |
| |     8 |  12:03:06 | 12:07:06 | | |     8 |  12:03:06 | 12:07:06 | |
| |     3 |  12:06:39 | 12:07:19 | | |     3 |  12:06:39 | 12:07:19 | |
| |     9 |  12:01:26 | 12:08:19 | | |     9 |  12:01:26 | 12:08:19 | |
| |     8 |  12:07:26 | 12:08:39 | | |     8 |  12:07:26 | 12:08:39 | |
| -------------------------------- | |     1 |  12:07:46 | 12:09:00 | |
|                                  | -------------------------------- |
-----------------------------------------------------------------------
</pre>

<p>That’s a lot of data. Alternatively, the <code><span class="code_purple">STREAM</span></code> version would render much more compactly in this instance; thanks to there being no explicit grouping in the relation, it looks essentially identical to the point-in-time <code><span class="code_orange">TABLE</span></code> rendering earlier, with the addition of the trailing footer describing the range of processing time captured in the stream so far, plus the note that the system is still waiting for more data in the stream (assuming we’re treating the stream as unbounded; we’ll see a bounded version of the stream shortly):</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:00&gt;</span> SELECT <span class="code_purple">STREAM</span> Score, EventTime, Sys.MTime as ProcTime FROM UserScores;</em></strong>
--------------------------------
| Score | EventTime | ProcTime |
--------------------------------
|     5 |  12:00:26 | 12:05:19 |
|     7 |  12:02:26 | 12:05:39 |
|     3 |  12:03:39 | 12:06:13 |
|     4 |  12:04:19 | 12:06:39 |
|     8 |  12:03:06 | 12:07:06 |
|     3 |  12:06:39 | 12:07:19 |
|     9 |  12:01:26 | 12:08:19 |
|     8 |  12:07:26 | 12:08:39 |
|     1 |  12:07:46 | 12:09:00 |
........ [12:00, 12:10] ........
</pre>

<p>But this is all just looking at the raw input records without any sort of transformations. Much more interesting is when we start altering the relations. When we’ve explored this example in the past, we’ve always started with classic batch processing to sum up the scores over the entire dataset, so let’s do the same here. The first example pipeline (previously provided as <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#summation_pipeline_key_value_data_are_read">Example&nbsp;6-1</a>) looked like <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#summation_pipeline_chap_eight">Example&nbsp;8-1</a> in Beam.</p>

<div class="pagebreak-before less_space_example" data-type="example" id="summation_pipeline_chap_eight">
<h5><span class="label">Example 8-1. </span>Summation pipeline</h5>

<pre data-type="programlisting">PCollection&lt;String&gt; raw = IO.read(...);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; input = raw.apply(<span class="what_lt">new ParseFn()</span>);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; totals =
  input.apply(<span class="what_lt">Sum.integersPerKey()</span>);
</pre>
</div>

<p>And rendered in the streams and tables view of the world, that pipeline’s execution looked like <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#streams_and_tables_view_of_classic_batch_processing">Figure&nbsp;8-7</a>.</p>

<figure><div id="streams_and_tables_view_of_classic_batch_processing" class="figure">
<video style="margin: 0 auto; max-width: 100%;" controls="controls" poster="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0807.png" autoplay="autoplay" loop="loop">
<source src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0807.mp4" type="video/mp4"><img src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0807.png" alt="Streams and tables view of classic batch processing" width="600" height="328" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0807.png">
</video>
<h6><span class="label">Figure 8-7. </span>Streams and tables view of classic batch processing</h6>
</div></figure>

<p>Given that we already have our<a contenteditable="false" data-primary="batch processing" data-secondary="streams and tables view" data-type="indexterm" id="idm140176509508480"></a> data placed into an appropriate schema, we won’t be doing any parsing in SQL; instead, we focus on everything in the pipeline after the parse transformation. And because we’re going with the classic batch model of retrieving a single answer only after all of the input data have been processed, the <code><span class="code_orange">TABLE</span></code> and <code><span class="code_purple">STREAM</span></code> views of the summation relation would look essentially identical (recall that we’re dealing with bounded versions of our dataset for these initial, batch-style examples; as a result, this <code><span class="code_purple">STREAM</span></code> query actually terminates with a line of dashes and an <code>END-OF-STREAM</code> marker):</p>

<pre class="pagebreak-before" data-type="programlisting"><strong><em><span class="code_blue">12:10&gt;</span> SELECT <span class="code_orange">TABLE</span> SUM(Score) as Total, MAX(EventTime),</em></strong>
<strong><em>       MAX(Sys.MTime) as "MAX(ProcTime)" FROM UserScores GROUP BY Team;</em></strong>
------------------------------------------
| Total | MAX(EventTime) | MAX(ProcTime) |
------------------------------------------
|    48 |       12:07:46 |      12:09:00 |
------------------------------------------
</pre>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:00&gt;</span> SELECT <span class="code_purple">STREAM</span> SUM(Score) as Total, MAX(EventTime),</em></strong>
<strong><em>       MAX(Sys.MTime) as "MAX(ProcTime)" FROM UserScores GROUP BY Team;</em></strong>
------------------------------------------
| Total | MAX(EventTime) | MAX(ProcTime) |
------------------------------------------
|    48 |       12:07:46 |      12:09:00 |
------ [12:00, 12:10] END-OF-STREAM ------
</pre>

<p>More interesting is when we start adding windowing into the mix. That will give us a chance to begin looking more closely at the temporal operations that need to be added to SQL to support robust stream processing.</p>

<section data-type="sect3" data-pdf-bookmark="Where: windowing"><div class="sect3" id="idm140176509495744">
<h3><em><span class="where_lt">Where</span></em>: windowing</h3>

<p>As we learned in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#streams_and_tables">Chapter&nbsp;6</a>, windowing is<a contenteditable="false" data-primary="temporal operators (in streaming SQL)" data-secondary="windowing" data-type="indexterm" id="ix_tempopwin"></a> a modification<a contenteditable="false" data-primary="windowing" data-secondary="in streaming SQL" data-type="indexterm" id="ix_windstrmSQL"></a> of grouping by key, in which the window becomes a secondary part of a hierarchical key. As with classic programmatic batch processing, you can window data into more simplistic windows quite easily within SQL as it exists now by simply including time as part of the <code>GROUP BY</code> parameter. Or, if the system in question provides it, you can use a built-in windowing operation. We look at SQL examples of both in a moment, but first, let’s revisit the programmatic version from <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch03.html#watermarks_chapter">Chapter&nbsp;3</a>. Thinking back to <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#summation_pipeline_chap_six_second">Example&nbsp;6-2</a>, the windowed Beam pipeline looked like that shown in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#example_eight_two">Example&nbsp;8-2</a>.</p>

<div data-type="example" id="example_eight_two">
<h5><span class="label">Example 8-2. </span>Summation pipeline</h5>

<pre data-type="programlisting">PCollection&lt;String&gt; raw = IO.read(...);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; input = raw.apply(<span class="what_lt">new ParseFn()</span>);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; totals = input
  <span class="grey_bg">.apply(<span class="where_lt">Window.into(FixedWindows.of(TWO_MINUTES))</span>)</span>
  .apply(<span class="what_lt">Sum.integersPerKey()</span>);
</pre>
</div>

<p>And the execution of that pipeline (in streams and tables rendering from <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch06.html#event_time_process_time_view_of_windowed_summation_on_a_batch_engine">Figure&nbsp;6-5</a>), looked like the diagrams presented in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#streams_and_tables_view_of_windowed_summation_on_a_batch_engine_chap_eight">Figure&nbsp;8-8</a>.</p>

<figure><div id="streams_and_tables_view_of_windowed_summation_on_a_batch_engine_chap_eight" class="figure">
<video style="margin: 0 auto; max-width: 100%;" controls="controls" poster="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0808.png" autoplay="autoplay" loop="loop">
<source src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0808.mp4" type="video/mp4"><img src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0808.png" alt="Streams and tables view of windowed summation on a batch engine" width="600" height="328" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0808.png">
</video>
<h6><span class="label">Figure 8-8. </span>Streams and tables view of windowed summation on a batch engine</h6>
</div></figure>

<p>As we saw before, the only material change from Figure <a data-type="xref" data-xrefstyle="select:labelnumber" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#streams_and_tables_view_of_classic_batch_processing">8-7</a> to <a data-type="xref" data-xrefstyle="select:labelnumber" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#streams_and_tables_view_of_windowed_summation_on_a_batch_engine_chap_eight">8-8</a> is that the table created by the <code>SUM</code> operation is now partitioned into fixed, two-minute windows of time, yielding four windowed answers at the end rather than the single global sum that we had previously.</p>

<p>To do the same thing in SQL, we have two options: implicitly window by including some unique feature of the window (e.g., the end timestamp) in the <code>GROUP BY</code> statement, or use a built-in windowing operation. Let’s look at both.</p>

<p>First, ad hoc windowing. In this case, we perform the math of calculating windows ourselves in our SQL statement:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:10&gt;</span> SELECT <span class="code_orange">TABLE</span> SUM(Score) as Total, </em></strong>
<strong><em>         "[" || EventTime / INTERVAL '2' MINUTES || ", " || </em></strong>
<strong><em>           (EventTime / INTERVAL '2' MINUTES) + INTERVAL '2' MINUTES ||</em></strong>
<strong><em>           ")" as Window, </em></strong>
<strong><em>         MAX(Sys.MTime) as "MAX(ProcTime)"</em></strong>
<strong><em>       FROM UserScores</em></strong>
<strong><em>       GROUP BY Team, EventTime / INTERVAL '2' MINUTES;</em></strong>
------------------------------------------------
| Total | Window               | MAX(ProcTime) |
------------------------------------------------
| 14    | [12:00:00, 12:02:00) | 12:08:19      |
| 18    | [12:02:00, 12:04:00) | 12:07:06      |
| 4     | [12:04:00, 12:06:00) | 12:06:39      |
| 12    | [12:06:00, 12:08:00) | 12:09:00      |
------------------------------------------------
</pre>

<p>We can also achieve the same result using an explicit windowing statement such as those supported by Apache Calcite:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:10&gt;</span> SELECT <span class="code_orange">TABLE</span> SUM(Score) as Total,</em></strong>
<strong><em>         TUMBLE(EventTime, INTERVAL '2' MINUTES) as Window,</em></strong>
<strong><em>         MAX(Sys.MTime) as 'MAX(ProcTime)' </em></strong>
<strong><em>       FROM UserScores</em></strong>
<strong><em>       GROUP BY Team, TUMBLE(EventTime, INTERVAL '2' MINUTES);</em></strong>
------------------------------------------------
| Total | Window               | MAX(ProcTime) |
------------------------------------------------
| 14    | [12:00:00, 12:02:00) | 12:08:19      |
| 18    | [12:02:00, 12:04:00) | 12:07:06      |
| 4     | [12:04:00, 12:06:00) | 12:06:39      |
| 12    | [12:06:00, 12:08:00) | 12:09:00      |
------------------------------------------------
</pre>

<p>This then begs the question: if we can implicitly window using existing SQL constructs, why even bother supporting explicit windowing constructs? There are two reasons, only the first of which is apparent in this example (we’ll see the other one in action later on in the chapter):</p>

<ol>
	<li>
	<p>Windowing takes care of the window-computation math for you. It’s a lot easier to consistently get things right when you specify basic parameters like width and slide directly rather than computing the window math yourself.<sup><a data-type="noteref" id="idm140176509452304-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509452304">14</a></sup></p>
	</li>
	<li>
	<p>Windowing allows the concise expression of more complex, dynamic groupings such as sessions. Even though SQL is technically able to express the every-element-within-some-temporal-gap-of-another-element relationship that defines session windows, the corresponding incantation is a tangled mess of analytic functions, self joins, and array unnesting that no mere mortal could be reasonably expected to conjure on their own.</p>
	</li>
</ol>

<p>Both are compelling arguments for providing first-class windowing constructs in SQL, in addition to the ad hoc windowing capabilities that already exist.</p>

<p>At this point, we’ve seen what windowing looks like from a classic batch/classic relational perspective when consuming the data as a table. But if we want to consume the data as a stream, we get back to that third question from the Beam Model: when in processing time do we materialize outputs?<a contenteditable="false" data-primary="windowing" data-secondary="in streaming SQL" data-startref="ix_windstrmSQL" data-type="indexterm" id="idm140176509448720"></a><a contenteditable="false" data-primary="temporal operators (in streaming SQL)" data-secondary="windowing" data-startref="ix_tempopwin" data-type="indexterm" id="idm140176509447072"></a></p>
</div></section>

<section data-type="sect3" data-pdf-bookmark="When: triggers"><div class="sect3" id="idm140176509495152">
<h3><em><span class="when_lt">When</span></em>: triggers</h3>

<p>The answer to that question, as before, is triggers<a contenteditable="false" data-primary="triggers" data-secondary="in streaming SQL" data-type="indexterm" id="ix_trigstrmSQL"></a> and watermarks.<a contenteditable="false" data-primary="temporal operators (in streaming SQL)" data-secondary="triggers" data-type="indexterm" id="ix_tempoptrig"></a> However, in the context of SQL, there’s a strong argument to be made for having a different set of defaults than those we introduced with the Beam Model in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch03.html#watermarks_chapter">Chapter&nbsp;3</a>: rather than defaulting to using a single watermark trigger, a more SQL-ish default would be to take a cue from materialized views and trigger on every element. In other words, any time a new input arrives, we produce a corresponding new output.</p>

<section data-type="sect4" data-pdf-bookmark="A SQL-ish default: per-record triggers"><div class="sect4" id="idm140176509438096">
<h4>A SQL-ish default: per-record triggers</h4>

<p>There are two compelling benefits to using trigger-every-record as the default:</p>

<dl>
	<dt>Simplicity</dt>
	<dd>
	<p>The semantics of per-record updates are easy to understand; materialized views have operated this way for years.</p>
	</dd>
	<dt>Fidelity</dt>
	<dd>
	<p>As in change data capture systems, per-record triggering yields a full-fidelity stream rendering of a given time-varying relation; no information is lost as part of the conversion.</p>
	</dd>
</dl>

<p>The downside is primarily cost: triggers are always applied after a grouping operation, and the nature of grouping often presents an opportunity to reduce the cardinality of data flowing through the system, thus commensurately reducing the cost of further processing those aggregate results downstream. Even so, the benefits in clarity and simplicity for use cases where cost is not prohibitive arguably outweigh the cognitive complexity of defaulting to a non-full-fidelity trigger up front.</p>

<p>Thus, for our first take at consuming aggregate team scores as a stream, let’s see what things would look like using a per-record trigger. Beam itself doesn’t have a precise per-record trigger, so, as demonstrated in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#per_record_trigger_chap_eight">Example&nbsp;8-3</a>, we instead use a repeated <code>AfterCount(1)</code> trigger, which will fire immediately any time a new record arrives.</p>

<div data-type="example" id="per_record_trigger_chap_eight">
<h5><span class="label">Example 8-3. </span>Per-record trigger</h5>

<pre data-type="programlisting">PCollection&lt;String&gt; raw = IO.read(...);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; input = raw.apply(<span class="what_lt">new ParseFn()</span>);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; totals = input
  .apply(<span class="where_lt">Window.into(FixedWindows.of(TWO_MINUTES))</span>
               <span class="when_lt grey_bg">.triggering(Repeatedly(AfterCount(1)))</span>
  .apply(<span class="what_lt">Sum.integersPerKey()</span>);
</pre>
</div>

<p>A streams and tables rendering of this pipeline would then look something like that depicted in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#streams_and_tables_view_of_windowed_summation_chap_eight">Figure&nbsp;8-9</a>.</p>

<figure><div id="streams_and_tables_view_of_windowed_summation_chap_eight" class="figure">
<video style="margin: 0 auto; max-width: 100%;" controls="controls" poster="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0809.png" autoplay="autoplay" loop="loop">
<source src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0809.mp4" type="video/mp4"><img src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0809.png" alt="Streams and tables view of windowed summation on a streaming engine with per-record triggering" width="600" height="411" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0809.png">
</video>
<h6><span class="label">Figure 8-9. </span>Streams and tables view of windowed summation on a streaming engine with per-record triggering</h6>
</div></figure>

<p>An interesting side effect of using per-record triggers is how it somewhat masks the effect of data being brought to rest because they are then immediately put back into motion again by the trigger. Even so, the aggregate artifact from the grouping remains at rest in the table, as the ungrouped stream of values flows away from it.</p>

<p>Moving back to SQL, we can see now what the effect of rendering the corresponding time-value relation as a stream would be. It (unsurprisingly) looks a lot like the stream of values in the animation in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#streams_and_tables_view_of_windowed_summation_chap_eight">Figure&nbsp;8-9</a>:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:00&gt;</span> SELECT <span class="code_purple">STREAM</span> SUM(Score) as Total, </em></strong>
<strong><em>         TUMBLE(EventTime, INTERVAL '2' MINUTES) as Window,</em></strong>
<strong><em>         MAX(Sys.MTime) as 'MAX(ProcTime)'' </em></strong>
<strong><em>       FROM UserScores</em></strong>
<strong><em>       GROUP BY Team, TUMBLE(EventTime, INTERVAL '2' MINUTES);</em></strong>
------------------------------------------------
| Total | Window               | MAX(ProcTime) |
------------------------------------------------
| 5     | [12:00:00, 12:02:00) | 12:05:19      |
| 7     | [12:02:00, 12:04:00) | 12:05:39      |
| 10    | [12:02:00, 12:04:00) | 12:06:13      |
| 4     | [12:04:00, 12:06:00) | 12:06:39      |
| 18    | [12:02:00, 12:04:00) | 12:07:06      |
| 3     | [12:06:00, 12:08:00) | 12:07:19      |
| 14    | [12:00:00, 12:02:00) | 12:08:19      |
| 11    | [12:06:00, 12:08:00) | 12:08:39      |
| 12    | [12:06:00, 12:08:00) | 12:09:00      |
................ [12:00, 12:10] ................
</pre>

<p>But even for this simple use case, it’s pretty chatty. If we’re building a pipeline to process data for a large-scale mobile application, we might not want to pay the cost of processing downstream updates for each and every upstream user score. This is where custom triggers come in.</p>
</div></section>

<section data-type="sect4" data-pdf-bookmark="Watermark triggers"><div class="sect4" id="idm140176509437472">
<h4>Watermark triggers</h4>

<p>If we were to switch the<a contenteditable="false" data-primary="watermark triggers" data-secondary="in streaming SQL" data-type="indexterm" id="ix_wtrmktrig"></a> Beam pipeline to use a watermark<a contenteditable="false" data-primary="triggers" data-secondary="in streaming SQL" data-tertiary="watermark triggers" data-type="indexterm" id="ix_trigstrmSQLwtr"></a> trigger, for example, we could get exactly one output per window in the stream version of the TVR, as demonstrated in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#watermark_trigger_chap_eight">Example&nbsp;8-4</a> and shown in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#windowed_summation_with_watermark_triggering_chap_eight">Figure&nbsp;8-10</a>.</p>

<div data-type="example" id="watermark_trigger_chap_eight">
<h5><span class="label">Example 8-4. </span>Watermark trigger</h5>

<pre data-type="programlisting">PCollection&lt;String&gt; raw = IO.read(...);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; input = raw.apply(<span class="what_lt">new ParseFn()</span>);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; totals = input
  .apply(<span class="where_lt">Window.into(FixedWindows.of(TWO_MINUTES))</span>
               <span class="when_lt">.triggering(<span class="grey_bg">AfterWatermark()</span></span>)
  .apply(<span class="what_lt">Sum.integersPerKey()</span>);
</pre>
</div>

<figure><div id="windowed_summation_with_watermark_triggering_chap_eight" class="figure">
<video style="margin: 0 auto; max-width: 100%;" controls="controls" poster="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0810.png" autoplay="autoplay" loop="loop">
<source src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0810.mp4" type="video/mp4"><img src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0810.png" alt="Windowed summation with watermark triggering" width="600" height="411" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0810.png">
</video>
<h6><span class="label">Figure 8-10. </span>Windowed summation with watermark triggering</h6>
</div></figure>

<p>To get the same effect in SQL, we’d need language support for specifying a custom trigger. Something like an <code>EMIT <em>&lt;when&gt;</em></code> statement, such as <code>EMIT WHEN WATERMARK PAST <em>&lt;column&gt;</em></code>. This would signal to the system that the table created by the aggregation should be triggered into a stream exactly once per row, when the input watermark for the table exceeds the timestamp value in the specified column (which in this case happens to be the end of the window).</p>

<p>Let’s look at this relation rendered as a stream. From the perspective of understanding when trigger firings occur, it’s also handy to stop relying on the <code>MTime</code> values from the original inputs and instead capture the current timestamp at which rows in the stream are emitted:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:00&gt;</span> SELECT <span class="code_purple">STREAM</span> SUM(Score) as Total,</em></strong>
<strong><em>         TUMBLE(EventTime, INTERVAL '2' MINUTES) as Window,</em></strong>
<strong><em>         <span class="grey_bg">CURRENT_TIMESTAMP as EmitTime</span></em></strong>
<strong><em>       FROM UserScores</em></strong>
<strong><em>       GROUP BY Team, TUMBLE(EventTime, INTERVAL '2' MINUTES)</em></strong>
<strong><em>       <span class="grey_bg">EMIT WHEN WATERMARK PAST WINDOW_END(Window);</span></em></strong>
-------------------------------------------
| Total | Window               | EmitTime |
-------------------------------------------
| 5     | [12:00:00, 12:02:00) | 12:06:00 |
| 18    | [12:02:00, 12:04:00) | 12:07:30 |
| 4     | [12:04:00, 12:06:00) | 12:07:41 |
| 12    | [12:06:00, 12:08:00) | 12:09:22 |
............. [12:00, 12:10] ..............
</pre>

<p>The main downside here is the late data problem due to the use of a heuristic watermark, as we encountered in previous chapters. In light of late data, a nicer option might be to also immediately output <a contenteditable="false" data-primary="early/on-time/late triggers" data-secondary="watermark trigger with late firing in streaming SQL" data-type="indexterm" id="idm140176509380096"></a>an update any time a late record shows up, using a variation on the watermark trigger that supported repeated late firings, as shown in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#watermark_trigger_with_late_firing_chap_eight">Example&nbsp;8-5</a> and <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#windowed_summation_with_on_time_late_triggering_chap_eght">Figure&nbsp;8-11</a>.</p>

<div data-type="example" id="watermark_trigger_with_late_firing_chap_eight">
<h5><span class="label">Example 8-5. </span>Watermark trigger with late firings</h5>

<pre data-type="programlisting">PCollection&lt;String&gt; raw = IO.read(...);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; input = raw.apply(<span class="what_lt">new ParseFn()</span>);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; totals = input
  .apply(<span class="where_lt">Window.into(FixedWindows.of(TWO_MINUTES))</span>
               <span class="when_lt">.triggering(</span><span class="when_lt">AfterWatermark()</span>
                   <span class="when_lt"><span class="grey_bg">.withLateFirings(AfterCount(1))</span>)</span>)
  .apply(<span class="what_lt">Sum.integersPerKey()</span>);
</pre>
</div>


<figure><div id="windowed_summation_with_on_time_late_triggering_chap_eght" class="figure">
<video style="margin: 0 auto; max-width: 100%;" controls="controls" poster="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0811.png" autoplay="autoplay" loop="loop">
<source src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0811.mp4" type="video/mp4"><img src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0811.png" alt="Windowed summation with on-time/late triggering" width="600" height="411" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0811.png">
</video>
<h6><span class="label">Figure 8-11. </span>Windowed summation with on-time/late triggering</h6>
</div></figure>

<p>We can do the same thing in SQL by allowing the specification of two triggers:</p>

<ul>
	<li>
	<p>A watermark trigger to give us an initial value: <code>WHEN WATERMARK PAST <em>&lt;column&gt;</em></code>, with the end of the window used as the timestamp <code><em>&lt;column&gt;</em></code>.</p>
	</li>
	<li>
	<p>A repeated delay trigger for late data: <code>AND THEN AFTER <em>&lt;duration&gt;</em></code>, with a <code><em>&lt;duration&gt;</em></code> of 0 to give us per-record semantics.</p>
	</li>
</ul>

<p>Now that we’re getting multiple rows per window, it can also be useful to have another two system columns available: the timing of each row/pane for a given window relative <a contenteditable="false" data-primary="Sys.EmitTiming column (hypothetical, in SQL)" data-type="indexterm" id="idm140176509358400"></a>to the<a contenteditable="false" data-primary="Sys.EmitIndex column (hypothetical, in SQL)" data-type="indexterm" id="idm140176509357072"></a> watermark (<code>Sys.EmitTiming</code>), and the index of the pane/row for a given window (<code>Sys.EmitIndex</code>, to identify the sequence of revisions for a given row/window):</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:00&gt;</span> SELECT <span class="code_purple">STREAM</span> SUM(Score) as Total,</em></strong>
<strong><em>         TUMBLE(EventTime, INTERVAL '2' MINUTES) as Window,</em></strong>
<strong><em>         CURRENT_TIMESTAMP as EmitTime,</em></strong>
<strong><em>         <span class="grey_bg">Sys.EmitTiming, Sys.EmitIndex </span></em></strong>
<strong><em>       FROM UserScores</em></strong>
<strong><em>       GROUP BY Team, TUMBLE(EventTime, INTERVAL '2' MINUTES)</em></strong>
<strong><em>       EMIT WHEN WATERMARK PAST WINDOW_END(Window)</em></strong>
<strong><em>         <span class="grey_bg">AND THEN AFTER 0 SECONDS</span>;</em></strong>
----------------------------------------------------------------------------
| Total | Window               | EmitTime | Sys.EmitTiming | Sys.EmitIndex |
----------------------------------------------------------------------------
| 5     | [12:00:00, 12:02:00) | 12:06:00 | on-time        | 0             |
| 18    | [12:02:00, 12:04:00) | 12:07:30 | on-time        | 0             |
| 4     | [12:04:00, 12:06:00) | 12:07:41 | on-time        | 0             |
| 14    | [12:00:00, 12:02:00) | 12:08:19 | late           | 1             |
| 12    | [12:06:00, 12:08:00) | 12:09:22 | on-time        | 0             |
.............................. [12:00, 12:10] ..............................
</pre>

<p>For each pane, using this trigger, we’re able to get a single on-time answer that is likely to be correct, thanks to our heuristic watermark. And for any data that arrives late, we can get an updated version of the row amending our previous results.<a contenteditable="false" data-primary="watermark triggers" data-secondary="in streaming SQL" data-startref="ix_wtrmktrig" data-type="indexterm" id="idm140176509345376"></a><a contenteditable="false" data-primary="triggers" data-secondary="in streaming SQL" data-startref="ix_trigstrmSQLwtr" data-tertiary="watermark triggers" data-type="indexterm" id="idm140176509343792"></a></p>
</div></section>

<section data-type="sect4" data-pdf-bookmark="Repeated delay triggers"><div class="sect4" id="idm140176509408832">
<h4>Repeated delay triggers</h4>

<p>The other main temporal trigger use case <a contenteditable="false" data-primary="triggers" data-secondary="in streaming SQL" data-tertiary="repeated delay triggers" data-type="indexterm" id="idm140176509340368"></a>you might want<a contenteditable="false" data-primary="repeated delay triggers" data-type="indexterm" id="idm140176509338592"></a> is repeated delayed updates; that is, trigger a window one minute (in processing time) after any new data for it arrive. Note that this is different than triggering on aligned boundaries, as you would get with a microbatch system. As <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#repeated_triggering_with_one_minute_delays_chap_eight">Example&nbsp;8-6</a> shows, triggering via a delay relative to the most recent new record arriving for the window/row helps spread triggering load out more evenly than a bursty, aligned trigger would. It also does not require any sort of watermark support. <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#windowed_summation_chap_eight_twelve">Figure&nbsp;8-12</a> presents the results.</p>

<div data-type="example" id="repeated_triggering_with_one_minute_delays_chap_eight">
<h5><span class="label">Example 8-6. </span>Repeated triggering with one-minute delays</h5>

<pre data-type="programlisting">PCollection&lt;String&gt; raw = IO.read(...);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; input = raw.apply(<span class="what_lt">new ParseFn()</span>);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; totals = input
  .apply(<span class="where_lt">Window.into(FixedWindows.of(TWO_MINUTES))</span>
               <span class="when_lt">.triggering(Repeatedly(<span class="grey_bg">UnalignedDelay(ONE_MINUTE)</span>)</span>)
  .apply(<span class="what_lt">Sum.integersPerKey()</span>);
</pre>
</div>

<figure><div id="windowed_summation_chap_eight_twelve" class="figure">
<video style="margin: 0 auto; max-width: 100%;" controls="controls" poster="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0812.png" autoplay="autoplay" loop="loop">
<source src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0812.mp4" type="video/mp4"><img src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0812.png" alt="Windowed summation with on-time/late triggering" width="600" height="411" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0812.png">
</video>
<h6><span class="label">Figure 8-12. </span>Windowed summation with repeated one-minute-delay triggering</h6>
</div></figure>

<p>The effect of using such a trigger is very similar to the per-record triggering we started out with but slightly less chatty thanks to the additional delay introduced in triggering, which allows the system to elide some number of the rows being produced. Tweaking the delay allows us to tune the volume of data generated, and thus balance the tensions of cost and timeliness as appropriate for the use case.</p>

<p>Rendered as a SQL stream, it would look something like this:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:00&gt;</span> SELECT <span class="code_purple">STREAM</span> SUM(Score) as Total,</em></strong>
<strong><em>         TUMBLE(EventTime, INTERVAL '2' MINUTES) as Window,</em></strong>
<strong><em>         CURRENT_TIMESTAMP as EmitTime,</em></strong>
<strong><em>         Sys.EmitTiming, SysEmitIndex</em></strong>
<strong><em>       FROM UserScores</em></strong>
<strong><em>       GROUP BY Team, TUMBLE(EventTime, INTERVAL '2' MINUTES)</em></strong>
<strong><em>       EMIT <span class="grey_bg">AFTER 1 MINUTE</span>;</em></strong>
----------------------------------------------------------------------------
| Total | Window               | EmitTime | Sys.EmitTiming | Sys.EmitIndex |
----------------------------------------------------------------------------
| 5     | [12:00:00, 12:02:00) | 12:06:19 | n/a            | 0             |
| 10    | [12:02:00, 12:04:00) | 12:06:39 | n/a            | 0             |
| 4     | [12:04:00, 12:06:00) | 12:07:39 | n/a            | 0             |
| 18    | [12:02:00, 12:04:00) | 12:08:06 | n/a            | 1             |
| 3     | [12:06:00, 12:08:00) | 12:08:19 | n/a            | 0             |
| 14    | [12:00:00, 12:02:00) | 12:09:19 | n/a            | 1             |
| 12    | [12:06:00, 12:08:00) | 12:09:22 | n/a            | 1             |
.............................. [12:00, 12:10] ..............................
</pre>
</div></section>

<section data-type="sect4" data-pdf-bookmark="Data-driven triggers"><div class="sect4" id="idm140176509314864">
<h4>Data-driven triggers</h4>

<p>Before moving on to the final question in the <a contenteditable="false" data-primary="data-driven triggers" data-type="indexterm" id="idm140176509313376"></a>Beam Model, it’s worth briefly discussing<a contenteditable="false" data-primary="triggers" data-secondary="in streaming SQL" data-tertiary="data-driven triggers" data-type="indexterm" id="idm140176509312080"></a> the idea of <em>data-driven triggers</em>. Because of the dynamic way types are handled in SQL, it might seem like data-driven triggers would be a very natural addition to the proposed <code>EMIT <em>&lt;when&gt;</em></code> clause. For example, what if we want to trigger our summation any time the total score exceeds 10? Wouldn’t something like <code>EMIT WHEN Score &gt; 10</code> work very naturally?</p>

<p>Well, yes and no. Yes, such a construct would fit very naturally. But when you think about what would actually be happening with such a construct, you essentially would be triggering on every record, and then executing the <code>Score &gt; 10</code> predicate to decide whether the triggered row should be propagated downstream. As you might recall, this sounds a lot like what happens with a <code>HAVING</code> clause. And, indeed, you can get the exact same effect by simply prepending <code>HAVING Score &gt; 10</code> to the end of the query. At which point, it begs the question: is it worth adding explicit data-driven triggers? Probably not. Even so, it’s still encouraging to see just how easy it is to get the desired effect of data-driven triggers using standard SQL and well-chosen defaults.<a contenteditable="false" data-primary="temporal operators (in streaming SQL)" data-secondary="triggers" data-startref="ix_tempoptrig" data-type="indexterm" id="idm140176509306192"></a><a contenteditable="false" data-primary="triggers" data-secondary="in streaming SQL" data-startref="ix_trigstrmSQL" data-type="indexterm" id="idm140176509304576"></a></p>
</div></section>
</div></section>

<section data-type="sect3" data-pdf-bookmark="How: accumulation"><div class="sect3" id="idm140176509302672">
<h3><em><span class="how_lt">How</span></em>: accumulation</h3>

<p>So far in this section, we’ve been ignoring the <code>Sys.Undo</code> column that I introduced toward the beginning of this chapter.<a contenteditable="false" data-primary="accumulation" data-secondary="in streaming SQL" data-type="indexterm" id="idm140176509299776"></a> As a result, we’ve defaulted to using <em>accumulating mode</em> to answer the question of <em>how</em> refinements for a window/row relate to one another.<a contenteditable="false" data-primary="accumulating mode (accumulation)" data-type="indexterm" id="idm140176509297360"></a> In other words, any time we observed multiple revisions of an aggregate row, the later revisions built upon the previous revisions, accumulating new inputs together with old ones. I opted for this approach because it matches the approach used in an earlier chapter, and it’s a relatively straightforward translation from how things work in a table world.</p>

<p>That said, accumulating mode has some major drawbacks. In fact, as we discussed in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch02.html#the_what_where_when_and_how">Chapter&nbsp;2</a>, it’s plain broken for any query/pipeline with a sequence of two or more grouping operations due to over counting. The only sane way to allow for the consumption of multiple revisions of a row within a system that allows for queries containing more than one serial grouping operation is if it operates by default in <em>accumulating and retracting</em> mode. <a contenteditable="false" data-primary="accumulating and retracting mode" data-type="indexterm" id="idm140176509293760"></a>Otherwise, you run into issues where a given input record is included multiple times in a single aggregation due to the blind incorporation of multiple revisions for a single row.</p>

<p>So, when we come to the question of incorporating accumulation mode semantics into a SQL world, the option that fits best with our goal of providing an intuitive and natural experience is if the system uses retractions by default under the covers.<sup><a data-type="noteref" id="idm140176509291600-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509291600">15</a></sup> As noted when <a contenteditable="false" data-primary="Sys.Undo column (hypothetical, in SQL)" data-type="indexterm" id="idm140176509289968"></a>I introduced the <code>Sys.Undo</code> column earlier, if you don’t care about the retractions (as in the examples in this section up until now), you don’t need to ask for them. But if you do ask for them, they should be there.</p>

<section data-type="sect4" data-pdf-bookmark="Retractions in a SQL world"><div class="sect4" id="idm140176509287936">
<h4>Retractions in a SQL world</h4>

<p>To see what I mean, let’s look at another example. <a contenteditable="false" data-primary="accumulation" data-secondary="in streaming SQL" data-tertiary="retractions" data-type="indexterm" id="ix_accstrmSQLret"></a>To motivate the problem appropriately, let’s look at a use case that’s relatively impractical <a contenteditable="false" data-primary="retractions (accumulating and retracting mode)" data-secondary="in streaming SQL" data-type="indexterm" id="ix_retractSQL"></a>without retractions: building session windows and writing them incrementally to a key/value store like HBase. In this case, we’ll be producing incremental sessions from our aggregation as they are built up. But in many cases, a given session will simply be an evolution of one or more previous sessions. In that case, you’d really like to delete the previous session(s) and replace it/them with the new one. But how do you do that? The only way to tell whether a given session replaces another one is to compare them to see whether the new one overlaps the old one. But that means duplicating some of the session-building logic in a separate part of your pipeline. And, more important, it means that you no longer have idempotent output, and you’ll thus need to jump through a bunch of extra hoops if you want to maintain end-to-end exactly-once semantics. Far better would be for the pipeline to simply tell you which sessions were removed and which were added in their place. This is what retractions give you.</p>

<p>To see this in action (and in SQL), let’s modify our example pipeline to compute session windows with a gap duration of one minute. For simplicity and clarity, we go back to using the default per-record trigger. Note that I’ve also shifted a few of the data points within processing time for these session examples to make the diagram cleaner; event-time timestamps remain the same. The updated dataset looks like this (with shifted processing-time timestamps highlighted in yellow):</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:00&gt;</span> SELECT <span class="code_purple">STREAM</span> Score, EventTime, Sys.MTime as ProcTime </em></strong>
<strong><em>       FROM UserScoresForSessions;</em></strong>
--------------------------------
| Score | EventTime | ProcTime |
--------------------------------
|     5 |  12:00:26 | 12:05:19 |
|     7 |  12:02:26 | 12:05:39 |
|     3 |  12:03:39 | 12:06:13 |
|     4 |  12:04:19 |<span class="yellow_bg"> 12:06:46 </span>|  # Originally 12:06:39
|     3 |  12:06:39 | 12:07:19 |
|     8 |  12:03:06 |<span class="yellow_bg"> 12:07:33 </span>|  # Originally 12:07:06
|     8 |  12:07:26 |<span class="yellow_bg"> 12:08:13 </span>|  # Originally 12:08:39
|     9 |  12:01:26 | 12:08:19 |
|     1 |  12:07:46 | 12:09:00 |
........ [12:00, 12:10] ........
</pre>

<p>To begin with, let’s look at the pipeline without retractions. After it’s clear why that pipeline is problematic for the use case of writing incremental sessions to a key/value store, we’ll then look at the version with retractions.</p>

<p>The Beam code for the nonretracting pipeline would look something like <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#session_windows_with_per_record_triggering_and_accumulation_but_no_retractions">Example&nbsp;8-7</a>. <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#session_window_summation_with_accumulation_but_no_retractions">Figure&nbsp;8-13</a> shows the results.</p>

<div data-type="example" id="session_windows_with_per_record_triggering_and_accumulation_but_no_retractions">
<h5><span class="label">Example 8-7. </span>Session windows with per-record triggering and accumulation but no retractions</h5>

<pre data-type="programlisting">PCollection&lt;String&gt; raw = IO.read(...);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; input = raw.apply(<span class="what_lt">new ParseFn()</span>);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; totals = input
  .apply(<span class="where_lt">Window.into(<span class="grey_bg">Sessions.withGapDuration(ONE_MINUTE)</span>)</span>
               <span class="when_lt">.triggering(Repeatedly(AfterCount(1))</span>
               <span class="grey_bg how_lt">.accumulatingFiredPanes()</span>)
  .apply(<span class="what_lt">Sum.integersPerKey()</span>);
</pre>
</div>

<figure><div id="session_window_summation_with_accumulation_but_no_retractions" class="figure">
<video style="margin: 0 auto; max-width: 100%;" controls="controls" poster="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0813.png" autoplay="autoplay" loop="loop">
<source src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0813.mp4" type="video/mp4"><img src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0813.png" alt="Session window summation with accumulation but no retractions" width="600" height="480" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0813.png">
</video>
<h6><span class="label">Figure 8-13. </span>Session window summation with accumulation but no retractions</h6>
</div></figure>

<p>And finally, rendered in SQL, the output stream would look like this:</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:00&gt;</span> SELECT <span class="code_purple">STREAM</span> SUM(Score) as Total,</em></strong>
<strong><em>         <span class="grey_bg">SESSION(EventTime, INTERVAL '1' MINUTE)</span> as Window,</em></strong>
<strong><em>         CURRENT_TIMESTAMP as EmitTime</em></strong>
<strong><em>       FROM UserScoresForSessions</em></strong>
<strong><em>       GROUP BY Team, <span class="grey_bg">SESSION(EventTime, INTERVAL '1' MINUTE)</span>;</em></strong>
-------------------------------------------
| Total | Window               | EmitTime |
-------------------------------------------
| 5     | [12:00:26, 12:01:26) | 12:05:19 |
| 7     | [12:02:26, 12:03:26) | 12:05:39 |
| 3     | [12:03:39, 12:04:39) | 12:06:13 |
| 7     | [12:03:39, 12:05:19) | 12:06:46 |
| 3     | [12:06:39, 12:07:39) | 12:07:19 |
| 22    | [12:02:26, 12:05:19) | 12:07:33 |
| 11    | [12:06:39, 12:08:26) | 12:08:13 |
| 36    | [12:00:26, 12:05:19) | 12:08:19 |
| 12    | [12:06:39, 12:08:46) | 12:09:00 |
............. [12:00, 12:10] ..............
</pre>

<p>The important thing to notice in here (in the animation as well as the SQL rendering) is what the stream of incremental sessions looks like. From our holistic viewpoint, it’s pretty easy to visually identify in the animation which later sessions supersede those that came before. But imagine receiving elements in this stream one by one (as in the SQL listing) and needing to write them to HBase in a way that eventually results in the HBase table containing only the two final sessions (with values 36 and 12). How would you do that? Well, you’d need to do a bunch of read-modify-write operations to read all of the existing sessions for a key, compare them with the new session, determine which ones overlap, issue deletes for the obsolete sessions, and then finally issue a write for the new session—all at significant additional cost, and with a loss of idempotence, which would ultimately leave you unable to provide end-to-end, exactly-once semantics. It’s just not practical.</p>

<p>Contrast this then with the same pipeline, but with retractions enabled, as demonstrated in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#session_windows_with_per_record_triggering_accumulation_and_retractions">Example&nbsp;8-8</a> and depicted in <a data-type="xref" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#session_window_summation_with_accumulation_and_retractions">Figure&nbsp;8-14</a>.</p>

<div data-type="example" id="session_windows_with_per_record_triggering_accumulation_and_retractions">
<h5><span class="label">Example 8-8. </span>Session windows with per-record triggering, accumulation, and retractions</h5>

<pre data-type="programlisting">PCollection&lt;String&gt; raw = IO.read(...);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; input = raw.apply(<span class="what_lt">new ParseFn()</span>);
PCollection&lt;KV&lt;Team, Integer&gt;&gt; totals = input
  .apply(<span class="where_lt">Window.into(Sessions.withGapDuration(ONE_MINUTE))</span>
               <span class="when_lt">.triggering(Repeatedly(AfterCount(1))</span>
               <span class="how_lt">.accumulating<span class="yellow_bg">AndRetracting</span>FiredPanes()</span>)
  .apply(<span class="what_lt">Sum.integersPerKey()</span>);
</pre>
</div>

<figure><div id="session_window_summation_with_accumulation_and_retractions" class="figure">
<video style="margin: 0 auto; max-width: 100%;" controls="controls" poster="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0814.png" autoplay="autoplay" loop="loop">
<source src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0814.mp4" type="video/mp4"><img src="https://www.safaribooksonline.com/library/view/streaming-systems/9781491983867/assets/stsy_0814.png" alt="Session window summation with accumulation and retractions" width="600" height="480" data-mfp-src="/library/view/streaming-systems/9781491983867/assets/stsy_0814.png">
</video>
<h6><span class="label">Figure 8-14. </span>Session window summation with accumulation and retractions</h6>
</div></figure>

<p>And, lastly, in SQL form. For the SQL version, we’re assuming that the system is using retractions under the covers by default, and individual retraction rows are then materialized in the stream any time we request the special <code>Sys.Undo</code> column.<sup><a data-type="noteref" id="idm140176509235344-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509235344">16</a></sup> As I described originally, the value of that column is that it allows us to distinguish retraction rows (labeled <code>undo</code> in the <code>Sys.Undo</code> column) from normal rows (unlabeled in the <code>Sys.Undo</code> column here for clearer contrast, though they could just as easily be labeled <code>redo</code>, instead):</p>

<pre data-type="programlisting"><strong><em><span class="code_blue">12:00&gt;</span> SELECT <span class="code_purple">STREAM</span> SUM(Score) as Total,</em></strong>
<strong><em>         SESSION(EventTime, INTERVAL '1' MINUTE) as Window,</em></strong>
<strong><em>         CURRENT_TIMESTAMP as EmitTime,</em></strong>
<strong><em>         <span class="grey_bg">Sys.Undo as Undo</span></em></strong>
<strong><em>       FROM UserScoresForSessions</em></strong>
<strong><em>       GROUP BY Team, SESSION(EventTime, INTERVAL '1' MINUTE);</em></strong>
--------------------------------------------------
| Total | Window               | EmitTime | Undo |
--------------------------------------------------
| 5     | [12:00:26, 12:01:26) | 12:05:19 |      |
| 7     | [12:02:26, 12:03:26) | 12:05:39 |      |
| 3     | [12:03:39, 12:04:39) | 12:06:13 |      |
| 3     | [12:03:39, 12:04:39) | 12:06:46 | undo |
| 7     | [12:03:39, 12:05:19) | 12:06:46 |      |
| 3     | [12:06:39, 12:07:39) | 12:07:19 |      |
| 7     | [12:02:26, 12:03:26) | 12:07:33 | undo |
| 7     | [12:03:39, 12:05:19) | 12:07:33 | undo |
| 22    | [12:02:26, 12:05:19) | 12:07:33 |      |
| 3     | [12:06:39, 12:07:39) | 12:08:13 | undo |
| 11    | [12:06:39, 12:08:26) | 12:08:13 |      |
| 5     | [12:00:26, 12:01:26) | 12:08:19 | undo |
| 22    | [12:02:26, 12:05:19) | 12:08:19 | undo |
| 36    | [12:00:26, 12:05:19) | 12:08:19 |      |
| 11    | [12:06:39, 12:08:26) | 12:09:00 | undo |
| 12    | [12:06:39, 12:08:46) | 12:09:00 |      |
................. [12:00, 12:10] .................
</pre>

<p>With retractions included, the sessions stream no longer just includes new sessions, but also retractions for the old sessions that have been replaced. With this stream, it’s trivial<sup><a data-type="noteref" id="idm140176509223616-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509223616">17</a></sup> to properly build up the set of sessions in HBase over time: you simply write new sessions as they arrive (unlabeled <code>redo</code> rows) and delete old sessions as they’re retracted (<code>undo</code> rows). Much better!<a contenteditable="false" data-primary="accumulation" data-secondary="in streaming SQL" data-startref="ix_accstrmSQLret" data-tertiary="retractions" data-type="indexterm" id="idm140176509221328"></a><a contenteditable="false" data-primary="retractions (accumulating and retracting mode)" data-secondary="in streaming SQL" data-startref="ix_retractSQL" data-type="indexterm" id="idm140176509219376"></a></p>
</div></section>

<section data-type="sect4" data-pdf-bookmark="Discarding mode, or lack thereof"><div class="sect4" id="idm140176509287312">
<h4>Discarding mode, or lack thereof</h4>

<p>With this example, we’ve shown<a contenteditable="false" data-primary="discarding mode (accumulation)" data-secondary="in streaming SQL" data-type="indexterm" id="idm140176509216128"></a> how simply and<a contenteditable="false" data-primary="accumulation" data-secondary="in streaming SQL" data-tertiary="discarding mode" data-type="indexterm" id="idm140176509214560"></a> naturally you can incorporate retractions into SQL to provide both <em>accumulating mode</em> and <em>accumulating and retracting mode</em> semantics. But what about <em>discarding mode</em>?</p>

<p>For specific use cases such as very simple pipelines that partially aggregate high-volume input data via a single grouping operation and then write them into a storage system, which itself supports aggregation (e.g., a database-like system), discarding mode can be extremely valuable as a resource-saving option. But outside of those relatively narrow use cases, discarding mode is confusing and error-prone. As such, it’s probably not worth incorporating directly into SQL. Systems that need it can provide it as an option outside of the SQL language itself. Those that don’t can simply provide the more natural default of <em>accumulating and retracting mode</em>, with the option to ignore retractions when they aren’t needed.<a contenteditable="false" data-primary="streaming SQL" data-secondary="looking forward, toward robust streaming" data-startref="ix_SQLforstrmto" data-tertiary="temporal operators" data-type="indexterm" id="idm140176509209984"></a><a contenteditable="false" data-primary="temporal operators (in streaming SQL)" data-startref="ix_tempop" data-type="indexterm" id="idm140176509207984"></a><a contenteditable="false" data-primary="streaming SQL" data-secondary="looking forward, toward robust streaming" data-startref="ix_SQLforstrm" data-type="indexterm" id="idm140176509206544"></a></p>
</div></section>
</div></section>
</div></section>
</div></section>

<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm140176509564352">
<h1>Summary</h1>

<p>This has been a long journey but a fascinating one. We’ve covered a ton of information in this chapter, so let’s take a moment to reflect on it all.</p>

<p>First, we reasoned that the key difference<a contenteditable="false" data-primary="time-varying relations" data-type="indexterm" id="idm140176509202848"></a> between streaming and nonstreaming data processing is the <em>added dimension of time</em>. We observed that relations (the foundational data object from relational algebra, which itself is the basis for SQL) themselves evolve over time, and from that derived the notion of a <em>TVR</em>, which captures the evolution of a relation as a sequence of classic snapshot relations over time. From that definition, we were able to see<a contenteditable="false" data-primary="closure property (relational algebra)" data-type="indexterm" id="idm140176509200336"></a> that the <em>closure property</em> of relational algebra <em>remains intact</em> in a world of TVRs, which means that the entire suite of relational operators (and thus SQL constructs) continues to function as one would expect as we move from a world of point-in-time snapshot relations into a streaming-compatible world of TVRs.</p>

<p>Second, we explored the biases inherent in both the Beam Model and the classic SQL model as they exist today, coming to the conclusion that Beam has a stream-oriented approach, whereas SQL takes a table-oriented approach.</p>

<p>And finally, we looked at the hypothetical language extensions needed to add support for robust stream processing to SQL,<sup><a data-type="noteref" id="idm140176509196880-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509196880">18</a></sup> as well as some carefully chosen defaults that can greatly decrease the need for those extensions to be used:</p>

<dl>
	<dt>Table/stream selection</dt>
	<dd>
	<p>Given that any time-varying relation can <a contenteditable="false" data-primary="streams and tables" data-secondary="table/stream selection for TVRs in streaming SQL" data-type="indexterm" id="idm140176509194000"></a>be rendered in two different ways (table or stream), we need the ability to choose which rendering we want when materializing the results of a query. We introduced the <code><span class="code_orange">TABLE</span></code>, <code><span class="code_purple">STREAM</span></code>, and <code><span class="code_grey">TVR</span></code> keywords to provide a nice explicit way to choose the desired rendering.</p>

	<p>Even better is not needing to explicitly specify a choice, and that’s where good defaults come in. If all the inputs are tables, a good default is for the output to be a table, as well; this gives you the classic relational query behavior everyone is accustomed to. Conversely, if any of the inputs are streams, a reasonable default is for the output to be a stream, as well.</p>
	</dd>
	<dt>Windowing</dt>
	<dd>
	<p>Though you can declare some types of<a contenteditable="false" data-primary="windowing" data-secondary="in streaming SQL" data-type="indexterm" id="idm140176509187472"></a> simple windows declaratively using existing SQL constructs, there is still value in having explicit windowing operators:</p>

	<ul class="pagebreak-before">
		<li>
		<p>Windowing operators encapsulate the window-computation math.</p>
		</li>
		<li>
		<p>Windowing allows the concise expression of complex, dynamic groupings like sessions.</p>
		</li>
	</ul>

	<p>Thus, the addition of simple windowing constructs for use in grouping can help make queries less error prone while also providing capabilities (like sessions) that are impractical to express in declarative SQL as it exists today.</p>
	</dd>
	<dt>Watermarks</dt>
	<dd>
	<p>This isn’t so much a SQL extension as it is a system-level feature. <a contenteditable="false" data-primary="watermarks" data-secondary="in streaming SQL" data-type="indexterm" id="idm140176509181232"></a>If the system in question integrates watermarks under the covers, they can be used in conjunction with triggers to generate streams containing a single, authoritative version of a row only after the input for that row is believed to be complete. This is critical for use cases in which it’s impractical to poll a materialized view table for results, and instead the output of the pipeline must be consumed directly as a stream. Examples are notifications and anomaly detection.</p>
	</dd>
	<dt>Triggers</dt>
	<dd>
	<p>Triggers define the shape of a stream as it is created from a TVR.<a contenteditable="false" data-primary="triggers" data-secondary="in streaming SQL" data-type="indexterm" id="idm140176509177840"></a> If unspecified, the default should be per-record triggering, which provides straightforward and natural semantics matching those of materialized views. Beyond the default, there are essentially two main types of useful triggers:</p>

	<ul>
		<li>
		<p><em>Watermark triggers</em>, for yielding a single output per<a contenteditable="false" data-primary="watermark triggers" data-secondary="in streaming SQL" data-type="indexterm" id="idm140176509174480"></a> window when the inputs to that window are believed to be complete.</p>
		</li>
		<li>
		<p><em>Repeated delay triggers</em>, for providing<a contenteditable="false" data-primary="repeated delay triggers" data-type="indexterm" id="idm140176509171744"></a> periodic updates.</p>
		</li>
	</ul>

	<p>Combinations of those two can also be useful, especially in the case of heuristic watermarks, to provide the early/on-time/late pattern we saw earlier.</p>
	</dd>
	<dt>Special system columns</dt>
	<dd>
	<p>When consuming a TVR as a stream, there are some interesting metadata that can be useful and which are most easily exposed as system-level columns. We looked at four:</p>

	<dl>
		<dt><code>Sys.MTime</code></dt>
		<dd>
		<p>The processing time at which a given <a contenteditable="false" data-primary="Sys.MTime column (hypothetical, in SQL)" data-type="indexterm" id="idm140176509166272"></a>row was last modified in a TVR.</p>
		</dd>
		<dt><code>Sys.EmitTiming</code></dt>
		<dd>
		<p>The timing of the row <a contenteditable="false" data-primary="Sys.EmitTiming column (hypothetical, in SQL)" data-type="indexterm" id="idm140176509163632"></a>emit relative to the watermark (early, on-time, late).</p>
		</dd>
		<dt><code>Sys.EmitIndex</code></dt>
		<dd>
		<p>The zero-based <a contenteditable="false" data-primary="Sys.EmitIndex column (hypothetical, in SQL)" data-type="indexterm" id="idm140176509161008"></a>index of the emit version for this row.<sup><a data-type="noteref" id="idm140176509159600-marker" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509159600">19</a></sup></p>
		</dd>
		<dt><code>Sys.Undo</code></dt>
		<dd>
		<p>Whether the row is a <a contenteditable="false" data-primary="Sys.Undo column (hypothetical, in SQL)" data-type="indexterm" id="idm140176509157168"></a>normal row or a retraction (<code>undo</code>). By default, the system should operate with retractions under the covers, as is necessary any time a series of more than one grouping operation might exist. If the <code>Sys.Undo</code> column is not projected when rendering a TVR as a stream, only normal rows will be returned, providing a simple way to toggle between <em>accumulating</em> and <em>accumulating and retracting</em> modes.</p>
		</dd>
	</dl>
	</dd>
</dl>

<p>Stream processing with SQL doesn’t need to be difficult. In fact, stream processing in SQL is quite common already in the form of materialized views. The important pieces really boil down to capturing the evolution of datasets/relations over time (via time-varying relations), providing the means of choosing between physical table or stream representations of those time-varying relations, and providing the tools for reasoning about time (windowing, watermarks, and triggers) that we’ve been talking about throughout this book. And, critically, you need good defaults to minimize how often these extensions need to be used in practice.<a contenteditable="false" data-primary="streaming SQL" data-startref="ix_SQL" data-type="indexterm" id="idm140176509152784"></a></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm140176510213328"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510213328-marker" class="totri-footnote">1</a></sup> What I mean by “valid relation” here is simply a relation for which the application of a given operator is well formed. For example, for the SQL query <code>SELECT x FROM y</code>​, a valid relation y would be any relation containing an attribute/column named x. Any relation not containing a such-named attribute would be invalid and, in the case of a real database system, would yield a query execution error.</p><p data-type="footnote" id="idm140176510200704"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510200704-marker" class="totri-footnote">2</a></sup> Much credit to Julian Hyde for this name and succinct rendering of the concept.</p><p data-type="footnote" id="idm140176510100624"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510100624-marker" class="totri-footnote">3</a></sup> Note that the <code>Sys.Undo</code> name used here is riffing off the concise <a href="https://flink.apache.org/news/2017/04/04/dynamic-tables.html">undo/redo nomenclature from Apache Flink</a>, which I think is a very clean way to capture the ideas of retraction and nonretraction rows.</p><p data-type="footnote" id="idm140176510066704"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510066704-marker" class="totri-footnote">4</a></sup> Now, in this example, it’s not too difficult to figure out that the new value of 8 should replace the old value of 7, given that the mapping is 1:1. But we’ll see a more complicated example later on when we talk about sessions that is much more difficult to handle without having retractions as a guide.</p><p data-type="footnote" id="idm140176510039456"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510039456-marker" class="totri-footnote">5</a></sup> And indeed, this is a key point to remember. There are some systems that advocate treating streams and tables as identical, claiming that we can simply treat streams like never-ending tables. That statement is accurate inasmuch as the true underlying primitive is the time-varying relation, and all relational operations may be applied equally to any time-varying relation, regardless of whether the actual physical manifestation is a stream or a table. But that sort of approach conflates the two very different types of views that tables and streams provide for a given time-varying relation. Pretending that two very different things are the same might seem simple on the surface, but it’s not a road toward understanding, clarity, and correctness.</p><p data-type="footnote" id="idm140176510021664"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510021664-marker" class="totri-footnote">6</a></sup> Here referring to tables in the sense of tables that can vary over time; that is, the table-based TVRs we’ve been looking at.</p><p data-type="footnote" id="idm140176510019824"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176510019824-marker" class="totri-footnote">7</a></sup> This one courtesy Julian Hyde.</p><p data-type="footnote" id="idm140176509972560"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509972560-marker" class="totri-footnote">8</a></sup> Though there are a number of efforts in flight across various projects that are trying to simplify the specification of triggering/ungrouping semantics. The most compelling proposal, made independently within both the Flink and Beam communities, is that triggers should simply be specified at the outputs of a pipeline and automatically propagated up throughout the pipeline. In this way, one would describe only the desired shape of the streams that actually create materialized output; the shape of all other streams in the pipeline would be implicitly derived from there.</p><p data-type="footnote" id="idm140176509707168"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509707168-marker" class="totri-footnote">9</a></sup> Though, of course, a single SQL query has vastly more expressive power than a single MapReduce, given the far less-confining set of operations and composition options available.</p><p data-type="footnote" id="idm140176509664688"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509664688-marker">10</a></sup> Note that we’re speaking conceptually here; there are of course a multitude of optimizations that can be applied in actual execution; for example, looking up specific rows via an index rather than scanning the entire table.</p><p data-type="footnote" id="idm140176509642384"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509642384-marker">11</a></sup> It’s been brought to my attention multiple times that the “<code>MATERIALIZED</code>” aspect of these queries is just an optimization: semantically speaking, these queries could just as easily be replaced with generic <code>CREATE VIEW</code> statements, in which case the database might instead simply rematerialize the entire view each time it is referenced. This is true. The reason I use the <code>MATERIALIZED</code> variant here is that the semantics of a materialized view are to incrementally update the view table in response to a stream of changes, which is indicative of the streaming nature behind them. That said, the fact that you can instead provide a similar experience by re-executing a bounded query each time a view is accessed provides a nice link between streams and tables as well as a link between streaming systems and the way batch systems have been historically used for processing data that evolves over time. You can either incrementally process changes as they occur or you can reprocess the entire input dataset from time to time. Both are valid ways of processing an evolving table of data.</p><p data-type="footnote" id="idm140176509612640"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509612640-marker">12</a></sup> Though it’s probably fair to say that SQL’s table bias is likely an artifact of SQL’s <em>roots</em> in batch processing.</p><p data-type="footnote" id="idm140176509559248"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509559248-marker">13</a></sup> For some use cases, capturing and using the current processing time for a given record as its event time going forward can be useful (for example, when logging events directly into a TVR, where the time of ingress is the natural event time for that record).</p><p data-type="footnote" id="idm140176509452304"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509452304-marker">14</a></sup> Maths are easy to get wrong.</p><p data-type="footnote" id="idm140176509291600"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509291600-marker">15</a></sup> It’s sufficient for retractions to be used by default and not simply always because the system only needs the <em>option</em> to use retractions. There are specific use cases; for example, queries with a single grouping operation whose results are being written into an external storage system that supports per-key updates, where the system can detect retractions are not needed and disable them as an optimization.</p><p data-type="footnote" id="idm140176509235344"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509235344-marker">16</a></sup> Note that it’s a little odd for the simple addition of a new column in the <code>SELECT</code> statement to result in a new rows appearing in a query. A fine alternative approach would be to require <code>Sys.Undo</code> rows to be filtered out via a <code>WHERE</code> clause when not needed.</p><p data-type="footnote" id="idm140176509223616"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509223616-marker">17</a></sup> Not that this triviality applies only in cases for which eventual consistency is sufficient. If you need to always have a globally coherent view of all sessions at any given time, you must 1) be sure to write/delete (via tombstones) each session at its emit time, and 2) only ever read from the HBase table at a timestamp that is less than the output watermark from your pipeline (to synchronize reads against the multiple, independent writes/deletes that happen when sessions merge). Or better yet, cut out the middle person and serve the sessions from your state tables directly.</p><p data-type="footnote" id="idm140176509196880"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509196880-marker">18</a></sup> To be clear, they’re not all hypothetical. Calcite has support for the windowing constructs described in this chapter.</p><p data-type="footnote" id="idm140176509159600"><sup><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#idm140176509159600-marker">19</a></sup> Note that the definition of “index” becomes complicated in the case of merging windows like sessions. A reasonable approach is to take the maximum of all of the previous sessions being merged together and increment by one.</p></div></div></section><div class="annotator-outer annotator-viewer viewer annotator-hide">
  <ul class="annotator-widget annotator-listing"></ul>
</div><div class="annotator-modal-wrapper annotator-editor-modal annotator-editor annotator-hide">
	<div class="annotator-outer editor">
		<h2 class="title">Highlight</h2>
		<form class="annotator-widget">
			<ul class="annotator-listing">
			<li class="annotator-item"><textarea id="annotator-field-0" placeholder="Add a note using markdown (optional)" class="js-editor" maxlength="750"></textarea></li></ul>
			<div class="annotator-controls">
				<a class="link-to-markdown" href="https://daringfireball.net/projects/markdown/basics" target="_blank">?</a>
				<ul>
					<li class="delete annotator-hide"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#delete" class="annotator-delete-note button positive">Delete Note</a></li>
					<li class="save"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#save" class="annotator-save annotator-focus button positive">Save Note</a></li>
					<li class="cancel"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#cancel" class="annotator-cancel button">Cancel</a></li>
				</ul>
			</div>
		</form>
	</div>
</div><div class="annotator-modal-wrapper annotator-delete-confirm-modal" style="display: none;">
  <div class="annotator-outer">
    <h2 class="title">Highlight</h2>
      <a class="js-close-delete-confirm annotator-cancel close" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#close">Close</a>
      <div class="annotator-widget">
         <div class="delete-confirm">
            Are you sure you want to permanently delete this note?
         </div>
         <div class="annotator-controls">
            <a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#cancel" class="annotator-cancel button js-cancel-delete-confirm">No, I changed my mind</a>
            <a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#delete" class="annotator-delete button positive js-delete-confirm">Yes, delete it</a>
         </div>
       </div>
   </div>
</div><div class="annotator-adder" style="display: none;">
	<ul class="adders ">
		
		<li class="copy"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#">Copy</a></li>
		
		<li class="add-highlight"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#">Add Highlight</a></li>
		<li class="add-note"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#">
			
				Add Note
			
		</a></li>
		
	</ul>
</div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch07.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">7. The Practicalities of Persistent State</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch09.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">9. Streaming Joins</div>
        </a>
    
  
  </div>


        
    </section>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  




    
    
      <div id="js-subscribe-nag" class="subscribe-nag clearfix trial-panel t-subscribe-nag collapsed slideUp">
        
        
          
          
            <p class="usage-data">Find answers on the fly, or master something new. Subscribe today. <a href="https://www.safaribooksonline.com/subscribe/" class="ga-active-trial-subscribe-nag">See pricing options.</a></p>
          

          
        
        

      </div>

    
    



        
      </div>
      




  <footer class="pagefoot t-pagefoot" style="padding-bottom: 69px;">
    <a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#" class="icon-up"><div class="visuallyhidden">Back to top</div></a>
    <ul class="js-footer-nav">
      
        <li><a class="t-recommendations-footer" href="https://www.safaribooksonline.com/r/">Recommended</a></li>
      
      <li>
      <a class="t-queue-footer" href="https://www.safaribooksonline.com/playlists/">Playlists</a>
      </li>
      
        <li><a class="t-recent-footer" href="https://www.safaribooksonline.com/history/">History</a></li>
        <li><a class="t-topics-footer" href="https://www.safaribooksonline.com/topics?q=*&amp;limit=21">Topics</a></li>
      
      
        <li><a class="t-tutorials-footer" href="https://www.safaribooksonline.com/tutorials/">Tutorials</a></li>
      
      <li><a class="t-settings-footer js-settings" href="https://www.safaribooksonline.com/u/preferences/">Settings</a></li>
      <li class="full-support"><a href="https://www.oreilly.com/online-learning/support/">Support</a></li>
      <li><a href="https://www.safaribooksonline.com/apps/">Get the App</a></li>
      <li><a href="https://www.safaribooksonline.com/accounts/logout/">Sign Out</a></li>
    </ul>
    <span class="copyright">© 2018 <a href="https://www.safaribooksonline.com/" target="_blank">Safari</a>.</span>
    <a href="https://www.safaribooksonline.com/terms/">Terms of Service</a> /
    <a href="https://www.safaribooksonline.com/privacy/">Privacy Policy</a>
  </footer>




    
    
      <img src="https://www.oreilly.com/library/view/oreilly_set_cookie/" alt="" style="display:none;">
    
    
    
  

<div class="annotator-notice"></div><div class="font-flyout" style="top: 151px; left: 1356px;"><div class="font-controls-panel">
	<div class="nightmodes">
		<ul>
			<li class="day"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#" id="day-mode" title="Day Mode">
				<i class="fa fa-sun-o"></i>
				<span>Day Mode</span></a></li>
			<li class="cloudy"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#" id="cloudy-mode" title="Cloudy Mode">
				<i class="fa fa-cloud"></i>
				<span>Cloud Mode</span>
			</a></li>
			<li class="night"><a href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#" id="night-mode" title="Night Mode">
				<i class="fa fa-moon-o"></i>
				<span>Night Mode</span>
			</a></li>
		</ul>
	</div>

	<div class="font-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-font left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-font-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-font right"></i>
		</div>
	</div>

	<div class="column-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-compress left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-column-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-expand right"></i>
		</div>
	</div>

	<a id="reset" class="button" href="/safari-books-archive/site/library/view/streaming-systems/9781491983867/ch08.html#">Reset</a>
</div>
</div>
<div style="width:0px; height:0px; display:none; visibility:hidden;" id="batBeacon0.8957629771238342"><img style="width:0px; height:0px; display:none; visibility:hidden;" id="batBeacon0.5559471838428269" width="0" height="0" alt="" src="https://bat.bing.com/action/0?ti=5794699&amp;Ver=2&amp;mid=3d1abc75-0ebd-9bc4-cede-e9b1f16a4fd7&amp;pi=1200101525&amp;lg=en-US&amp;sw=1440&amp;sh=900&amp;sc=24&amp;tl=8.%20Streaming%20SQL%20-%20Streaming%20Systems&amp;p=https%3A%2F%2Fwww.safaribooksonline.com%2Flibrary%2Fview%2Fstreaming-systems%2F9781491983867%2Fch08.html&amp;r=&amp;lt=15699&amp;evt=pageLoad&amp;msclkid=N&amp;rn=53575"></div></body></html>