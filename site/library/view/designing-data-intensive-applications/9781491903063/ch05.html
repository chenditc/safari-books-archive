<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/designing-data-intensive-applications/9781491903063/ch05.html"
data-csrf-cookie="csrfsafari"
data-highlight-privacy=""


  data-user-id="3905629"
  data-user-uuid="f04af719-1c84-4fc3-9be3-1f1b4622ab99"
  data-username="safaribooksonline122"
  data-account-type="Trial"
  
  data-activated-trial-date="12/09/2018"


  data-archive="9781491903063"
  data-publishers="O&#39;Reilly Media, Inc."



  data-htmlfile-name="ch05.html"
  data-epub-title="Designing Data-Intensive Applications" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class="js flexbox flexboxlegacy no-touch websqldatabase indexeddb history csscolumns csstransforms localstorage sessionstorage applicationcache svg inlinesvg zoom gr__safaribooksonline_com" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#" itemscope="" itemtype="http://schema.org/Book http://schema.org/ItemPage" data-login-url="/accounts/login/" data-offline-url="/" data-url="/library/view/designing-data-intensive-applications/9781491903063/ch05.html" data-csrf-cookie="csrfsafari" data-highlight-privacy="" data-user-id="3905629" data-user-uuid="f04af719-1c84-4fc3-9be3-1f1b4622ab99" data-username="safaribooksonline122" data-account-type="Trial" data-activated-trial-date="12/09/2018" data-archive="9781491903063" data-publishers="O'Reilly Media, Inc." data-htmlfile-name="ch05.html" data-epub-title="Designing Data-Intensive Applications" data-debug="0" data-testing="0" style=""><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="author" content="Safari Books Online"><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9781491903063"><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"><meta property="twitter:account_id" content="4503599627559754"><link rel="apple-touch-icon" href="https://www.safaribooksonline.com/static/images/apple-touch-icon.0c29511d2d72.png"><link rel="shortcut icon" href="https://www.safaribooksonline.com/favicon.ico" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic" rel="stylesheet" type="text/css"><title>5. Replication - Designing Data-Intensive Applications</title><link rel="stylesheet" href="https://www.safaribooksonline.com/static/CACHE/css/5e586a47a3b7.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://www.safaribooksonline.com/static/css/annotator.e3b0c44298fc.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book">
    @charset "utf-8";#sbo-rt-content html,#sbo-rt-content div,#sbo-rt-content div,#sbo-rt-content span,#sbo-rt-content applet,#sbo-rt-content object,#sbo-rt-content iframe,#sbo-rt-content h1,#sbo-rt-content h2,#sbo-rt-content h3,#sbo-rt-content h4,#sbo-rt-content h5,#sbo-rt-content h6,#sbo-rt-content p,#sbo-rt-content blockquote,#sbo-rt-content pre,#sbo-rt-content a,#sbo-rt-content abbr,#sbo-rt-content acronym,#sbo-rt-content address,#sbo-rt-content big,#sbo-rt-content cite,#sbo-rt-content code,#sbo-rt-content del,#sbo-rt-content dfn,#sbo-rt-content em,#sbo-rt-content img,#sbo-rt-content ins,#sbo-rt-content kbd,#sbo-rt-content q,#sbo-rt-content s,#sbo-rt-content samp,#sbo-rt-content small,#sbo-rt-content strike,#sbo-rt-content strong,#sbo-rt-content sub,#sbo-rt-content sup,#sbo-rt-content tt,#sbo-rt-content var,#sbo-rt-content b,#sbo-rt-content u,#sbo-rt-content i,#sbo-rt-content center,#sbo-rt-content dl,#sbo-rt-content dt,#sbo-rt-content dd,#sbo-rt-content ol,#sbo-rt-content ul,#sbo-rt-content li,#sbo-rt-content fieldset,#sbo-rt-content form,#sbo-rt-content label,#sbo-rt-content legend,#sbo-rt-content table,#sbo-rt-content caption,#sbo-rt-content tdiv,#sbo-rt-content tfoot,#sbo-rt-content thead,#sbo-rt-content tr,#sbo-rt-content th,#sbo-rt-content td,#sbo-rt-content article,#sbo-rt-content aside,#sbo-rt-content canvas,#sbo-rt-content details,#sbo-rt-content embed,#sbo-rt-content figure,#sbo-rt-content figcaption,#sbo-rt-content footer,#sbo-rt-content header,#sbo-rt-content hgroup,#sbo-rt-content menu,#sbo-rt-content nav,#sbo-rt-content output,#sbo-rt-content ruby,#sbo-rt-content section,#sbo-rt-content summary,#sbo-rt-content time,#sbo-rt-content mark,#sbo-rt-content audio,#sbo-rt-content video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}#sbo-rt-content article,#sbo-rt-content aside,#sbo-rt-content details,#sbo-rt-content figcaption,#sbo-rt-content figure,#sbo-rt-content footer,#sbo-rt-content header,#sbo-rt-content hgroup,#sbo-rt-content menu,#sbo-rt-content nav,#sbo-rt-content section{display:block}#sbo-rt-content div{line-height:1}#sbo-rt-content ol,#sbo-rt-content ul{list-style:none}#sbo-rt-content blockquote,#sbo-rt-content q{quotes:none}#sbo-rt-content blockquote:before,#sbo-rt-content blockquote:after,#sbo-rt-content q:before,#sbo-rt-content q:after{content:none}#sbo-rt-content table{border-collapse:collapse;border-spacing:0}@page{margin:5px !important}#sbo-rt-content p{margin:10px 0 0;line-height:125%;text-align:left}#sbo-rt-content p.byline{text-align:left;margin:-33px auto 35px;font-style:italic;font-weight:bold}#sbo-rt-content div.preface p+p.byline{margin:1em 0 0 !important}#sbo-rt-content div.preface p.byline+p.byline{margin:0 !important}#sbo-rt-content div.sect1>p.byline{margin:-.25em 0 1em}#sbo-rt-content div.sect1>p.byline+p.byline{margin-top:-1em}#sbo-rt-content em{font-style:italic;font-family:inherit}#sbo-rt-content em strong,#sbo-rt-content strong em{font-weight:bold;font-style:italic;font-family:inherit}#sbo-rt-content strong,#sbo-rt-content span.bold{font-weight:bold}#sbo-rt-content em.replaceable{font-style:italic}#sbo-rt-content strong.userinput{font-weight:bold;font-style:normal}#sbo-rt-content span.bolditalic{font-weight:bold;font-style:italic}#sbo-rt-content a.ulink,#sbo-rt-content a.xref,#sbo-rt-content a.email,#sbo-rt-content a.link,#sbo-rt-content a{text-decoration:none;color:#8e0012}#sbo-rt-content span.lineannotation{font-style:italic;color:#a62a2a;font-family:serif}#sbo-rt-content span.underline{text-decoration:underline}#sbo-rt-content span.strikethrough{text-decoration:line-through}#sbo-rt-content span.smallcaps{font-variant:small-caps}#sbo-rt-content span.cursor{background:#000;color:#fff}#sbo-rt-content span.smaller{font-size:75%}#sbo-rt-content .boxedtext,#sbo-rt-content .keycap{border-style:solid;border-width:1px;border-color:#000;padding:1px}#sbo-rt-content span.gray50{color:#7F7F7F;}#sbo-rt-content h1,#sbo-rt-content div.toc-title,#sbo-rt-content h2,#sbo-rt-content h3,#sbo-rt-content h4,#sbo-rt-content h5{-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none;font-weight:bold;text-align:left;page-break-after:avoid !important;font-family:sans-serif,"DejaVuSans"}#sbo-rt-content div.toc-title{font-size:1.5em;margin-top:20px !important;margin-bottom:30px !important}#sbo-rt-content section[data-type="sect1"] h1{font-size:1.3em;color:#8e0012;margin:40px 0 8px 0}#sbo-rt-content section[data-type="sect2"] h2{font-size:1.1em;margin:30px 0 8px 0 !important}#sbo-rt-content section[data-type="sect3"] h3{font-size:1em;color:#555;margin:20px 0 8px 0 !important}#sbo-rt-content section[data-type="sect4"] h4{font-size:1em;font-weight:normal;font-style:italic;margin:15px 0 6px 0 !important}#sbo-rt-content section[data-type="chapter"]>div>h1,#sbo-rt-content section[data-type="preface"]>div>h1,#sbo-rt-content section[data-type="appendix"]>div>h1,#sbo-rt-content section[data-type="glossary"]>div>h1,#sbo-rt-content section[data-type="bibliography"]>div>h1,#sbo-rt-content section[data-type="index"]>div>h1{font-size:2em;line-height:1;margin-bottom:50px;color:#000;padding-bottom:10px;border-bottom:1px solid #000}#sbo-rt-content span.label,#sbo-rt-content span.keep-together{font-size:inherit;font-weight:inherit}#sbo-rt-content div[data-type="part"] h1{font-size:2em;text-align:center;margin-top:0 !important;margin-bottom:50px;padding:50px 0 10px 0;border-bottom:1px solid #000}#sbo-rt-content img.width-ninety{width:90%}#sbo-rt-content img{max-width:95%;margin:0 auto;padding:0}#sbo-rt-content div.figure{background-color:transparent;text-align:center !important;margin:15px 0 15px 0 !important;page-break-inside:avoid}#sbo-rt-content figure{margin:15px 0 15px 0 !important;page-break-inside:avoid}#sbo-rt-content div.figure h6,#sbo-rt-content figure h6,#sbo-rt-content figure figcaption{font-size:.9rem !important;text-align:center;font-weight:normal !important;font-style:italic;font-family:serif !important;text-transform:none !important;letter-spacing:normal !important;color:#000 !important;padding-top:10px !important;page-break-before:avoid}#sbo-rt-content div.informalfigure{text-align:center !important;padding:5px 0 !important}#sbo-rt-content div.sidebar{margin:15px 0 10px 0 !important;border:1px solid #DCDCDC;background-color:#F7F7F7;padding:15px !important;page-break-inside:avoid}#sbo-rt-content aside[data-type="sidebar"]{margin:15px 0 10px 0 !important;page-break-inside:avoid}#sbo-rt-content div.sidebar-title,#sbo-rt-content aside[data-type="sidebar"] h5{font-weight:bold;font-size:1em;font-family:sans-serif;text-transform:uppercase;letter-spacing:1px;text-align:center;margin:4px 0 6px 0 !important;page-break-inside:avoid}#sbo-rt-content div.sidebar ol,#sbo-rt-content div.sidebar ul,#sbo-rt-content aside[data-type="sidebar"] ol,#sbo-rt-content aside[data-type="sidebar"] ul{margin-left:1.25em !important}#sbo-rt-content div.sidebar div.figure p.title,#sbo-rt-content aside[data-type="sidebar"] figcaption,#sbo-rt-content div.sidebar div.informalfigure div.caption{font-size:90%;text-align:center;font-weight:normal;font-style:italic;font-family:serif !important;color:#000;padding:5px !important;page-break-before:avoid;page-break-after:avoid}#sbo-rt-content div.sidebar div.tip,#sbo-rt-content div.sidebar div[data-type="tip"],#sbo-rt-content div.sidebar div.note,#sbo-rt-content div.sidebar div[data-type="note"],#sbo-rt-content div.sidebar div.warning,#sbo-rt-content div.sidebar div[data-type="warning"],#sbo-rt-content div.sidebar div[data-type="caution"],#sbo-rt-content div.sidebar div[data-type="important"]{margin:20px auto 20px auto !important;font-size:90%;width:85%}#sbo-rt-content aside[data-type="sidebar"] p.byline{font-size:90%;font-weight:bold;font-style:italic;text-align:center;text-indent:0;margin:5px auto 6px;page-break-after:avoid}#sbo-rt-content pre{white-space:pre-wrap;font-family:"Ubuntu Mono",monospace;margin:25px 0 25px 20px;font-size:85%;display:block;-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none;overflow-wrap:break-word}#sbo-rt-content div.note pre.programlisting,#sbo-rt-content div.tip pre.programlisting,#sbo-rt-content div.warning pre.programlisting,#sbo-rt-content div.caution pre.programlisting,#sbo-rt-content div.important pre.programlisting{margin-bottom:0}#sbo-rt-content code{font-family:"Ubuntu Mono",monospace;-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none;overflow-wrap:break-word}#sbo-rt-content code strong em,#sbo-rt-content code em strong,#sbo-rt-content pre em strong,#sbo-rt-content pre strong em,#sbo-rt-content strong code em code,#sbo-rt-content em code strong code,#sbo-rt-content span.bolditalic code{font-weight:bold;font-style:italic;font-family:"Ubuntu Mono BoldItal",monospace}#sbo-rt-content code em,#sbo-rt-content em code,#sbo-rt-content pre em,#sbo-rt-content em.replaceable{font-family:"Ubuntu Mono Ital",monospace;font-style:italic}#sbo-rt-content code strong,#sbo-rt-content strong code,#sbo-rt-content pre strong,#sbo-rt-content strong.userinput{font-family:"Ubuntu Mono Bold",monospace;font-weight:bold}#sbo-rt-content div[data-type="example"]{margin:10px 0 15px 0 !important}#sbo-rt-content div[data-type="example"] h1,#sbo-rt-content div[data-type="example"] h2,#sbo-rt-content div[data-type="example"] h3,#sbo-rt-content div[data-type="example"] h4,#sbo-rt-content div[data-type="example"] h5,#sbo-rt-content div[data-type="example"] h6{font-style:italic;font-weight:normal;text-align:left !important;text-transform:none !important;font-family:serif !important;margin:10px 0 5px 0 !important;border-bottom:1px solid #000}#sbo-rt-content li pre.example{padding:10px 0 !important}#sbo-rt-content div[data-type="example"] pre[data-type="programlisting"],#sbo-rt-content div[data-type="example"] pre[data-type="screen"]{margin:0}#sbo-rt-content section[data-type="titlepage"]>div>h1{font-size:2em;margin:50px 0 10px 0 !important;line-height:1;text-align:center}#sbo-rt-content section[data-type="titlepage"] h2,#sbo-rt-content section[data-type="titlepage"] p.subtitle,#sbo-rt-content section[data-type="titlepage"] p[data-type="subtitle"]{font-size:1.3em;font-weight:normal;text-align:center;margin-top:.5em;color:#555}#sbo-rt-content section[data-type="titlepage"]>div>h2[data-type="author"],#sbo-rt-content section[data-type="titlepage"] p.author{font-size:1.3em;font-family:serif !important;font-weight:bold;margin:50px 0 !important;text-align:center}#sbo-rt-content section[data-type="titlepage"] p.edition{text-align:center;text-transform:uppercase;margin-top:2em}#sbo-rt-content section[data-type="titlepage"]{text-align:center}#sbo-rt-content section[data-type="titlepage"]:after{content:url(css_assets/titlepage_footer_ebook.png);margin:0 auto;max-width:80%}#sbo-rt-content div.book div.titlepage div.publishername{margin-top:60%;margin-bottom:20px;text-align:center;font-size:1.25em}#sbo-rt-content div.book div.titlepage div.locations p{margin:0;text-align:center}#sbo-rt-content div.book div.titlepage div.locations p.cities{font-size:80%;text-align:center;margin-top:5px}#sbo-rt-content section.preface[title="Dedication"]>div.titlepage h2.title{text-align:center;text-transform:uppercase;font-size:1.5em;margin-top:50px;margin-bottom:50px}#sbo-rt-content ul.stafflist{margin:15px 0 15px 20px !important}#sbo-rt-content ul.stafflist li{list-style-type:none;padding:5px 0}#sbo-rt-content ul.printings li{list-style-type:none}#sbo-rt-content section.preface[title="Dedication"] p{font-style:italic;text-align:center}#sbo-rt-content div.colophon h1.title{font-size:1.3em;margin:0 !important;font-family:serif !important;font-weight:normal}#sbo-rt-content div.colophon h2.subtitle{margin:0 !important;color:#000;font-family:serif !important;font-size:1em;font-weight:normal}#sbo-rt-content div.colophon div.author h3.author{font-size:1.1em;font-family:serif !important;margin:10px 0 0 !important;font-weight:normal}#sbo-rt-content div.colophon div.editor h4,#sbo-rt-content div.colophon div.editor h3.editor{color:#000;font-size:.8em;margin:15px 0 0 !important;font-family:serif !important;font-weight:normal}#sbo-rt-content div.colophon div.editor h3.editor{font-size:.8em;margin:0 !important;font-family:serif !important;font-weight:normal}#sbo-rt-content div.colophon div.publisher{margin-top:10px}#sbo-rt-content div.colophon div.publisher p,#sbo-rt-content div.colophon div.publisher span.publishername{margin:0;font-size:.8em}#sbo-rt-content div.legalnotice p,#sbo-rt-content div.timestamp p{font-size:.8em}#sbo-rt-content div.timestamp p{margin-top:10px}#sbo-rt-content div.colophon[title="About the Author"] h1.title,#sbo-rt-content div.colophon[title="Colophon"] h1.title{font-size:1.5em;margin:0 !important;font-family:sans-serif !important}#sbo-rt-content section.chapter div.titlepage div.author{margin:10px 0 10px 0}#sbo-rt-content section.chapter div.titlepage div.author div.affiliation{font-style:italic}#sbo-rt-content div.attribution{margin:5px 0 0 50px !important}#sbo-rt-content h3.author span.orgname{display:none}#sbo-rt-content div.epigraph{margin:10px 0 10px 20px !important;page-break-inside:avoid;font-size:90%}#sbo-rt-content div.epigraph p{font-style:italic}#sbo-rt-content blockquote,#sbo-rt-content div.blockquote{margin:10px !important;page-break-inside:avoid;font-size:95%}#sbo-rt-content blockquote p,#sbo-rt-content div.blockquote p{font-style:italic;margin:.75em 0 0 !important}#sbo-rt-content blockquote div.attribution,#sbo-rt-content blockquote p[data-type="attribution"]{margin:5px 0 10px 30px !important;text-align:right;width:80%}#sbo-rt-content blockquote div.attribution p,#sbo-rt-content blockquote p[data-type="attribution"]{font-style:normal;margin-top:5px}#sbo-rt-content blockquote div.attribution p:before,#sbo-rt-content blockquote p[data-type="attribution"]:before{font-style:normal;content:"—";-webkit-hyphens:none;hyphens:none;adobe-hyphenate:none}#sbo-rt-content p.right{text-align:right;margin:0}#sbo-rt-content div[data-type="footnotes"]{border-top:1px solid black;margin-top:1.5em}#sbo-rt-content sub,#sbo-rt-content sup{font-size:75%;line-height:0;position:relative}#sbo-rt-content sup{top:-.5em}#sbo-rt-content sub{bottom:-.25em}#sbo-rt-content div.refentry p.refname{font-size:1em;font-family:sans-serif,"DejaVuSans";font-weight:bold;margin-bottom:5px;overflow:auto;width:100%}#sbo-rt-content div.refentry{width:100%;display:block;margin-top:2em}#sbo-rt-content div.refsynopsisdiv{display:block;clear:both}#sbo-rt-content div.refentry header{page-break-inside:avoid !important;display:block;break-inside:avoid !important;padding-top:0;border-bottom:1px solid #000}#sbo-rt-content div.refsect1 h6{font-size:.9em;font-family:sans-serif,"DejaVuSans";font-weight:bold}#sbo-rt-content div.refsect1{margin-top:3em}#sbo-rt-content dt{padding-top:10px !important;padding-bottom:0 !important}#sbo-rt-content dd{margin-left:1.5em !important;margin-bottom:.25em}#sbo-rt-content dd ol,#sbo-rt-content dd ul{padding-left:1em}#sbo-rt-content dd li{margin-top:0;margin-bottom:0}#sbo-rt-content dd,#sbo-rt-content li{text-align:left}#sbo-rt-content ul,#sbo-rt-content ul>li,#sbo-rt-content ol ul,#sbo-rt-content ol ul>li,#sbo-rt-content ul ol ul,#sbo-rt-content ul ol ul>li{list-style-type:disc}#sbo-rt-content ul ul,#sbo-rt-content ul ul>li{list-style-type:square}#sbo-rt-content ul ul ul,#sbo-rt-content ul ul ul>li{list-style-type:circle}#sbo-rt-content ol,#sbo-rt-content ol>li,#sbo-rt-content ol ul ol,#sbo-rt-content ol ul ol>li,#sbo-rt-content ul ol,#sbo-rt-content ul ol>li{list-style-type:decimal}#sbo-rt-content ol ol,#sbo-rt-content ol ol>li{list-style-type:lower-alpha}#sbo-rt-content ol ol ol,#sbo-rt-content ol ol ol>li{list-style-type:lower-roman}#sbo-rt-content ol,#sbo-rt-content ul{list-style-position:outside;margin:15px 0 15px 1.25em;padding-left:2.25em}#sbo-rt-content ol li,#sbo-rt-content ul li{margin:.5em 0 .65em;line-height:125%}#sbo-rt-content div.orderedlistalpha{list-style-type:upper-alpha}#sbo-rt-content table.simplelist,#sbo-rt-content ul.simplelist{margin:15px 0 15px 20px !important}#sbo-rt-content ul.simplelist li{list-style-type:none;padding:5px 0}#sbo-rt-content table.simplelist td{border:none}#sbo-rt-content table.simplelist tr{border-bottom:none}#sbo-rt-content table.simplelist tr:nth-of-type(even){background-color:transparent}#sbo-rt-content dl.calloutlist p:first-child{margin-top:-25px !important}#sbo-rt-content dl.calloutlist dd{padding-left:0;margin-top:-25px}#sbo-rt-content dl.calloutlist img,#sbo-rt-content a.co img{padding:0}#sbo-rt-content div.toc ol{margin-top:8px !important;margin-bottom:8px !important;margin-left:0 !important;padding-left:0 !important}#sbo-rt-content div.toc ol ol{margin-left:30px !important;padding-left:0 !important}#sbo-rt-content div.toc ol li{list-style-type:none}#sbo-rt-content div.toc a{color:#8e0012}#sbo-rt-content div.toc ol a{font-size:1em;font-weight:bold}#sbo-rt-content div.toc ol>li>ol a{font-weight:bold;font-size:1em}#sbo-rt-content div.toc ol>li>ol>li>ol a{text-decoration:none;font-weight:normal;font-size:1em}#sbo-rt-content div.tip,#sbo-rt-content div[data-type="tip"],#sbo-rt-content div.note,#sbo-rt-content div[data-type="note"],#sbo-rt-content div.warning,#sbo-rt-content div[data-type="warning"],#sbo-rt-content div[data-type="caution"],#sbo-rt-content div[data-type="important"]{margin:30px !important;font-size:90%;padding:10px 8px 20px 8px !important;page-break-inside:avoid}#sbo-rt-content div.tip ol,#sbo-rt-content div.tip ul,#sbo-rt-content div[data-type="tip"] ol,#sbo-rt-content div[data-type="tip"] ul,#sbo-rt-content div.note ol,#sbo-rt-content div.note ul,#sbo-rt-content div[data-type="note"] ol,#sbo-rt-content div[data-type="note"] ul,#sbo-rt-content div.warning ol,#sbo-rt-content div.warning ul,#sbo-rt-content div[data-type="warning"] ol,#sbo-rt-content div[data-type="warning"] ul,#sbo-rt-content div[data-type="caution"] ol,#sbo-rt-content div[data-type="caution"] ul,#sbo-rt-content div[data-type="important"] ol,#sbo-rt-content div[data-type="important"] ul{margin-left:1.5em !important}#sbo-rt-content div.tip,#sbo-rt-content div[data-type="tip"],#sbo-rt-content div.note,#sbo-rt-content div[data-type="note"]{border:1px solid #BEBEBE;background-color:transparent}#sbo-rt-content div.warning,#sbo-rt-content div[data-type="warning"],#sbo-rt-content div[data-type="caution"],#sbo-rt-content div[data-type="important"]{border:1px solid #BC8F8F}#sbo-rt-content div.tip h3,#sbo-rt-content div[data-type="tip"] h6,#sbo-rt-content div[data-type="tip"] h1,#sbo-rt-content div.note h3,#sbo-rt-content div[data-type="note"] h6,#sbo-rt-content div[data-type="note"] h1,#sbo-rt-content div.warning h3,#sbo-rt-content div[data-type="warning"] h6,#sbo-rt-content div[data-type="warning"] h1,#sbo-rt-content div[data-type="caution"] h6,#sbo-rt-content div[data-type="caution"] h1,#sbo-rt-content div[data-type="important"] h1,#sbo-rt-content div[data-type="important"] h6{font-weight:bold;font-size:110%;font-family:sans-serif !important;text-transform:uppercase;letter-spacing:1px;text-align:center;margin:4px 0 6px !important}#sbo-rt-content div[data-type="tip"] figure h6,#sbo-rt-content div[data-type="note"] figure h6,#sbo-rt-content div[data-type="warning"] figure h6,#sbo-rt-content div[data-type="caution"] figure h6,#sbo-rt-content div[data-type="important"] figure h6{font-family:serif !important}#sbo-rt-content div.tip h3,#sbo-rt-content div[data-type="tip"] h6,#sbo-rt-content div.note h3,#sbo-rt-content div[data-type="note"] h6,#sbo-rt-content div[data-type="tip"] h1,#sbo-rt-content div[data-type="note"] h1{color:#737373}#sbo-rt-content div.warning h3,#sbo-rt-content div[data-type="warning"] h6,#sbo-rt-content div[data-type="caution"] h6,#sbo-rt-content div[data-type="important"] h6,#sbo-rt-content div[data-type="warning"] h1,#sbo-rt-content div[data-type="caution"] h1,#sbo-rt-content div[data-type="important"] h1{color:#C67171}#sbo-rt-content div.sect1[title="Safari® Books Online"] div.note,#sbo-rt-content div.safarienabled{background-color:transparent;margin:8px 0 0 !important;border:0 solid #BEBEBE;font-size:100%;padding:0 !important;page-break-inside:avoid}#sbo-rt-content div.sect1[title="Safari® Books Online"] div.note h3,#sbo-rt-content div.safarienabled h6{display:none}#sbo-rt-content div.table,#sbo-rt-content table{margin:15px 0 30px 0 !important;max-width:95%;border:none !important;background:none;display:table !important}#sbo-rt-content div.table,#sbo-rt-content div.informaltable,#sbo-rt-content table{page-break-inside:avoid}#sbo-rt-content tr,#sbo-rt-content tr td{border-bottom:1px solid #c3c3c3}#sbo-rt-content thead td,#sbo-rt-content thead th{border-bottom:#9d9d9d 1px solid !important;border-top:#9d9d9d 1px solid !important}#sbo-rt-content tr:nth-of-type(even){background-color:#f1f6fc}#sbo-rt-content thead{font-family:sans-serif;font-weight:bold}#sbo-rt-content td,#sbo-rt-content th{display:table-cell;padding:.3em;text-align:left;vertical-align:middle;font-size:80%}#sbo-rt-content div.informaltable table{margin:10px auto !important}#sbo-rt-content div.informaltable table tr{border-bottom:none}#sbo-rt-content div.informaltable table tr:nth-of-type(even){background-color:transparent}#sbo-rt-content div.informaltable td,#sbo-rt-content div.informaltable th{border:#9d9d9d 1px solid}#sbo-rt-content div.table-title,#sbo-rt-content table caption{font-weight:normal;font-style:italic;font-family:serif;font-size:1em;margin:10px 0 10px 0 !important;padding:0;page-break-after:avoid;text-align:left !important}#sbo-rt-content table code{font-size:smaller}#sbo-rt-content div.equation,#sbo-rt-content div[data-type="equation"]{margin:10px 0 15px 0 !important}#sbo-rt-content div.equation-title,#sbo-rt-content div[data-type="equation"] h5{font-style:italic;font-weight:normal;font-family:serif !important;font-size:90%;margin:20px 0 10px 0 !important;page-break-after:avoid}#sbo-rt-content div.equation-contents{margin-left:20px}#sbo-rt-content div[data-type="equation"] math{font-size:calc(.35em + 1vw)}#sbo-rt-content span.inlinemediaobject{height:.85em;display:inline-block;margin-bottom:.2em}#sbo-rt-content span.inlinemediaobject img{margin:0;height:.85em}#sbo-rt-content div.informalequation{margin:20px 0 20px 20px;width:75%}#sbo-rt-content div.informalequation img{width:75%}#sbo-rt-content div.index{text-indent:0}#sbo-rt-content div.index h3{padding:.25em;margin-top:1em !important;background-color:#F0F0F0}#sbo-rt-content div.index li{line-height:130%;list-style-type:none}#sbo-rt-content div.index a.indexterm{color:#8e0012 !important}#sbo-rt-content div.index ul{margin-left:0 !important;padding-left:0 !important}#sbo-rt-content div.index ul ul{margin-left:1em !important;margin-top:0 !important}#sbo-rt-content code.boolean,#sbo-rt-content .navy{color:rgb(0,0,128);}#sbo-rt-content code.character,#sbo-rt-content .olive{color:rgb(128,128,0);}#sbo-rt-content code.comment,#sbo-rt-content .blue{color:rgb(0,0,255);}#sbo-rt-content code.conditional,#sbo-rt-content .limegreen{color:rgb(50,205,50);}#sbo-rt-content code.constant,#sbo-rt-content .darkorange{color:rgb(255,140,0);}#sbo-rt-content code.debug,#sbo-rt-content .darkred{color:rgb(139,0,0);}#sbo-rt-content code.define,#sbo-rt-content .darkgoldenrod,#sbo-rt-content .gold{color:rgb(184,134,11);}#sbo-rt-content code.delimiter,#sbo-rt-content .dimgray{color:rgb(105,105,105);}#sbo-rt-content code.error,#sbo-rt-content .red{color:rgb(255,0,0);}#sbo-rt-content code.exception,#sbo-rt-content .salmon{color:rgb(250,128,11);}#sbo-rt-content code.float,#sbo-rt-content .steelblue{color:rgb(70,130,180);}#sbo-rt-content pre code.function,#sbo-rt-content .green{color:rgb(0,128,0);}#sbo-rt-content code.identifier,#sbo-rt-content .royalblue{color:rgb(65,105,225);}#sbo-rt-content code.ignore,#sbo-rt-content .gray{color:rgb(128,128,128);}#sbo-rt-content code.include,#sbo-rt-content .purple{color:rgb(128,0,128);}#sbo-rt-content code.keyword,#sbo-rt-content .sienna{color:rgb(160,82,45);}#sbo-rt-content code.label,#sbo-rt-content .deeppink{color:rgb(255,20,147);}#sbo-rt-content code.macro,#sbo-rt-content .orangered{color:rgb(255,69,0);}#sbo-rt-content code.number,#sbo-rt-content .brown{color:rgb(165,42,42);}#sbo-rt-content code.operator,#sbo-rt-content .black{color:#000;}#sbo-rt-content code.preCondit,#sbo-rt-content .teal{color:rgb(0,128,128);}#sbo-rt-content code.preProc,#sbo-rt-content .fuschia{color:rgb(255,0,255);}#sbo-rt-content code.repeat,#sbo-rt-content .indigo{color:rgb(75,0,130);}#sbo-rt-content code.special,#sbo-rt-content .saddlebrown{color:rgb(139,69,19);}#sbo-rt-content code.specialchar,#sbo-rt-content .magenta{color:rgb(255,0,255);}#sbo-rt-content code.specialcomment,#sbo-rt-content .seagreen{color:rgb(46,139,87);}#sbo-rt-content code.statement,#sbo-rt-content .forestgreen{color:rgb(34,139,34);}#sbo-rt-content code.storageclass,#sbo-rt-content .plum{color:rgb(221,160,221);}#sbo-rt-content code.string,#sbo-rt-content .darkred{color:rgb(139,0,0);}#sbo-rt-content code.structure,#sbo-rt-content .chocolate{color:rgb(210,106,30);}#sbo-rt-content code.tag,#sbo-rt-content .darkcyan{color:rgb(0,139,139);}#sbo-rt-content code.todo,#sbo-rt-content .black{color:#000;}#sbo-rt-content code.type,#sbo-rt-content .mediumslateblue{color:rgb(123,104,238);}#sbo-rt-content code.typedef,#sbo-rt-content .darkgreen{color:rgb(0,100,0);}#sbo-rt-content code.underlined{text-decoration:underline;}#sbo-rt-content pre code.hll{background-color:#ffc}#sbo-rt-content pre code.c{color:#09F;font-style:italic}#sbo-rt-content pre code.err{color:#A00}#sbo-rt-content pre code.k{color:#069;font-weight:bold}#sbo-rt-content pre code.o{color:#555}#sbo-rt-content pre code.cm{color:#35586C;font-style:italic}#sbo-rt-content pre code.cp{color:#099}#sbo-rt-content pre code.c1{color:#35586C;font-style:italic}#sbo-rt-content pre code.cs{color:#35586C;font-weight:bold;font-style:italic}#sbo-rt-content pre code.gd{background-color:#FCC}#sbo-rt-content pre code.ge{font-style:italic}#sbo-rt-content pre code.gr{color:#F00}#sbo-rt-content pre code.gh{color:#030;font-weight:bold}#sbo-rt-content pre code.gi{background-color:#CFC}#sbo-rt-content pre code.go{color:#000}#sbo-rt-content pre code.gp{color:#009;font-weight:bold}#sbo-rt-content pre code.gs{font-weight:bold}#sbo-rt-content pre code.gu{color:#030;font-weight:bold}#sbo-rt-content pre code.gt{color:#9C6}#sbo-rt-content pre code.kc{color:#069;font-weight:bold}#sbo-rt-content pre code.kd{color:#069;font-weight:bold}#sbo-rt-content pre code.kn{color:#069;font-weight:bold}#sbo-rt-content pre code.kp{color:#069}#sbo-rt-content pre code.kr{color:#069;font-weight:bold}#sbo-rt-content pre code.kt{color:#078;font-weight:bold}#sbo-rt-content pre code.m{color:#F60}#sbo-rt-content pre code.s{color:#C30}#sbo-rt-content pre code.na{color:#309}#sbo-rt-content pre code.nb{color:#366}#sbo-rt-content pre code.nc{color:#0A8;font-weight:bold}#sbo-rt-content pre code.no{color:#360}#sbo-rt-content pre code.nd{color:#99F}#sbo-rt-content pre code.ni{color:#999;font-weight:bold}#sbo-rt-content pre code.ne{color:#C00;font-weight:bold}#sbo-rt-content pre code.nf{color:#C0F}#sbo-rt-content pre code.nl{color:#99F}#sbo-rt-content pre code.nn{color:#0CF;font-weight:bold}#sbo-rt-content pre code.nt{color:#309;font-weight:bold}#sbo-rt-content pre code.nv{color:#033}#sbo-rt-content pre code.ow{color:#000;font-weight:bold}#sbo-rt-content pre code.w{color:#bbb}#sbo-rt-content pre code.mf{color:#F60}#sbo-rt-content pre code.mh{color:#F60}#sbo-rt-content pre code.mi{color:#F60}#sbo-rt-content pre code.mo{color:#F60}#sbo-rt-content pre code.sb{color:#C30}#sbo-rt-content pre code.sc{color:#C30}#sbo-rt-content pre code.sd{color:#C30;font-style:italic}#sbo-rt-content pre code.s2{color:#C30}#sbo-rt-content pre code.se{color:#C30;font-weight:bold}#sbo-rt-content pre code.sh{color:#C30}#sbo-rt-content pre code.si{color:#A00}#sbo-rt-content pre code.sx{color:#C30}#sbo-rt-content pre code.sr{color:#3AA}#sbo-rt-content pre code.s1{color:#C30}#sbo-rt-content pre code.ss{color:#A60}#sbo-rt-content pre code.bp{color:#366}#sbo-rt-content pre code.vc{color:#033}#sbo-rt-content pre code.vg{color:#033}#sbo-rt-content pre code.vi{color:#033}#sbo-rt-content pre code.il{color:#F60}#sbo-rt-content pre code.g{color:#050}#sbo-rt-content pre code.l{color:#C60}#sbo-rt-content pre code.l{color:#F90}#sbo-rt-content pre code.n{color:#008}#sbo-rt-content pre code.nx{color:#008}#sbo-rt-content pre code.py{color:#96F}#sbo-rt-content pre code.p{color:#000}#sbo-rt-content pre code.x{color:#F06}#sbo-rt-content div.blockquote_sampler_toc{width:95%;margin:5px 5px 5px 10px !important}#sbo-rt-content div{font-family:serif;text-align:left}#sbo-rt-content .gray-background,#sbo-rt-content .reverse-video{background:#2E2E2E;color:#FFF}#sbo-rt-content .light-gray-background{background:#A0A0A0}#sbo-rt-content .preserve-whitespace{white-space:pre-wrap}#sbo-rt-content span.gray{color:#4C4C4C}#sbo-rt-content div.map-ebook{page-break-after:always}
    </style><link rel="canonical" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html"><meta name="description" content=" Chapter 5. Replication The major difference between a thing that might go wrong and a thing that cannot possibly go wrong is that when a thing that cannot possibly go ... "><meta property="og:title" content="5. Replication"><meta itemprop="isPartOf" content="/library/view/designing-data-intensive-applications/9781491903063/"><meta itemprop="name" content="5. Replication"><meta property="og:url" itemprop="url" content="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/ch05.html"><meta property="og:site_name" content="Safari"><meta property="og:image" itemprop="thumbnailUrl" content="https://www.safaribooksonline.com/library/cover/9781491903063/"><meta property="og:description" itemprop="description" content=" Chapter 5. Replication The major difference between a thing that might go wrong and a thing that cannot possibly go wrong is that when a thing that cannot possibly go ... "><meta itemprop="inLanguage" content="en"><meta itemprop="publisher" content="O'Reilly Media, Inc."><meta property="og:type" content="book"><meta property="og:book:isbn" itemprop="isbn" content="9781449373320"><meta property="og:book:author" itemprop="author" content="Martin Kleppmann"><meta property="og:book:tag" itemprop="about" content="Core Programming"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@safari"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><style id="annotator-dynamic-style">.annotator-adder, .annotator-outer, .annotator-notice {
  z-index: 100019;
}
.annotator-filter {
  z-index: 100009;
}</style></head>


<body class="reading sidenav nav-collapsed  scalefonts subscribe-panel library" data-gr-c-s-loaded="true">

    
  
  
  



    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        





<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#container" class="skip">Skip to content</a><header class="topbar t-topbar" style="display:None"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li class="t-logo"><a href="https://www.safaribooksonline.com/home/" class="l0 None safari-home nav-icn js-keyboard-nav-home"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>Safari Home Icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M4 9.9L4 9.9 4 18 16 18 16 9.9 10 4 4 9.9ZM2.6 8.1L2.6 8.1 8.7 1.9 10 0.5 11.3 1.9 17.4 8.1 18 8.7 18 9.5 18 18.1 18 20 16.1 20 3.9 20 2 20 2 18.1 2 9.5 2 8.7 2.6 8.1Z"></path><rect x="10" y="12" width="3" height="7"></rect><rect transform="translate(18.121320, 10.121320) rotate(-315.000000) translate(-18.121320, -10.121320) " x="16.1" y="9.1" width="4" height="2"></rect><rect transform="translate(2.121320, 10.121320) scale(-1, 1) rotate(-315.000000) translate(-2.121320, -10.121320) " x="0.1" y="9.1" width="4" height="2"></rect></g></svg><span>Safari Home</span></a></li><li><a href="https://www.safaribooksonline.com/r/" class="t-recommendations-nav l0 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>recommendations icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M50 25C50 18.2 44.9 12.5 38.3 11.7 37.5 5.1 31.8 0 25 0 18.2 0 12.5 5.1 11.7 11.7 5.1 12.5 0 18.2 0 25 0 31.8 5.1 37.5 11.7 38.3 12.5 44.9 18.2 50 25 50 31.8 50 37.5 44.9 38.3 38.3 44.9 37.5 50 31.8 50 25ZM25 3.1C29.7 3.1 33.6 6.9 34.4 11.8 30.4 12.4 26.9 15.1 25 18.8 23.1 15.1 19.6 12.4 15.6 11.8 16.4 6.9 20.3 3.1 25 3.1ZM34.4 15.6C33.6 19.3 30.7 22.2 27.1 22.9 27.8 19.2 30.7 16.3 34.4 15.6ZM22.9 22.9C19.2 22.2 16.3 19.3 15.6 15.6 19.3 16.3 22.2 19.2 22.9 22.9ZM3.1 25C3.1 20.3 6.9 16.4 11.8 15.6 12.4 19.6 15.1 23.1 18.8 25 15.1 26.9 12.4 30.4 11.8 34.4 6.9 33.6 3.1 29.7 3.1 25ZM22.9 27.1C22.2 30.7 19.3 33.6 15.6 34.4 16.3 30.7 19.2 27.8 22.9 27.1ZM25 46.9C20.3 46.9 16.4 43.1 15.6 38.2 19.6 37.6 23.1 34.9 25 31.3 26.9 34.9 30.4 37.6 34.4 38.2 33.6 43.1 29.7 46.9 25 46.9ZM27.1 27.1C30.7 27.8 33.6 30.7 34.4 34.4 30.7 33.6 27.8 30.7 27.1 27.1ZM38.2 34.4C37.6 30.4 34.9 26.9 31.3 25 34.9 23.1 37.6 19.6 38.2 15.6 43.1 16.4 46.9 20.3 46.9 25 46.9 29.7 43.1 33.6 38.2 34.4Z"></path></g></svg><span>Recommended</span></a></li><li><a href="https://www.safaribooksonline.com/playlists/" class="t-queue-nav l0 nav-icn None"><!--?xml version="1.0" encoding="UTF-8"?--><svg width="21px" height="17px" viewBox="0 0 21 17" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><!-- Generator: Sketch 46.2 (44496) - http://www.bohemiancoding.com/sketch --><title>icon_Playlist_sml</title><desc>Created with Sketch.</desc><defs></defs><g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g id="icon_Playlist_sml" fill-rule="nonzero" fill="#000000"><g id="playlist-icon"><g id="Group-6"><rect id="Rectangle-path" x="5" y="0" width="16" height="3" rx="0.5"></rect><circle id="Oval" cx="1.5" cy="1.5" r="1.5"></circle></g><g id="Group-5" transform="translate(0.000000, 7.000000)"><circle id="Oval" cx="1.5" cy="1.5" r="1.5"></circle><rect id="Rectangle-path" x="5" y="0" width="16" height="3" rx="0.5"></rect></g><g id="Group-5-Copy" transform="translate(0.000000, 14.000000)"><circle id="Oval" cx="1.5" cy="1.5" r="1.5"></circle><rect id="Rectangle-path" x="5" y="0" width="16" height="3" rx="0.5"></rect></g></g></g></g></svg><span>
               Playlists
            </span></a></li><li class="search"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z"></path></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"></path></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li><a href="https://www.safaribooksonline.com/history/" class="t-recent-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>recent items icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 0C11.2 0 0 11.2 0 25 0 38.8 11.2 50 25 50 38.8 50 50 38.8 50 25 50 11.2 38.8 0 25 0ZM6.3 25C6.3 14.6 14.6 6.3 25 6.3 35.4 6.3 43.8 14.6 43.8 25 43.8 35.4 35.4 43.8 25 43.8 14.6 43.8 6.3 35.4 6.3 25ZM31.8 31.5C32.5 30.5 32.4 29.2 31.6 28.3L27.1 23.8 27.1 12.8C27.1 11.5 26.2 10.4 25 10.4 23.9 10.4 22.9 11.5 22.9 12.8L22.9 25.7 28.8 31.7C29.2 32.1 29.7 32.3 30.2 32.3 30.8 32.3 31.3 32 31.8 31.5Z"></path></g></svg><span>History</span></a></li><li><a href="https://www.safaribooksonline.com/topics" class="t-topics-link l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 55" width="20" height="20" version="1.1" fill="#4A3C31"><desc>topics icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 55L50 41.262 50 13.762 25 0 0 13.762 0 41.262 25 55ZM8.333 37.032L8.333 17.968 25 8.462 41.667 17.968 41.667 37.032 25 46.538 8.333 37.032Z"></path></g></svg><span>Topics</span></a></li><li><a href="https://www.safaribooksonline.com/tutorials/" class="l1 nav-icn t-tutorials-nav js-toggle-menu-item None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width="20" height="20" version="1.1" fill="#4A3C31"><desc>tutorials icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M15.8 18.2C15.8 18.2 15.9 18.2 16 18.2 16.1 18.2 16.2 18.2 16.4 18.2 16.5 18.2 16.7 18.1 16.9 18 17 17.9 17.1 17.8 17.2 17.7 17.3 17.6 17.4 17.5 17.4 17.4 17.5 17.2 17.6 16.9 17.6 16.7 17.6 16.6 17.6 16.5 17.6 16.4 17.5 16.2 17.5 16.1 17.4 15.9 17.3 15.8 17.2 15.6 17 15.5 16.8 15.3 16.6 15.3 16.4 15.2 16.2 15.2 16 15.2 15.8 15.2 15.7 15.2 15.5 15.3 15.3 15.4 15.2 15.4 15.1 15.5 15 15.7 14.9 15.8 14.8 15.9 14.7 16 14.7 16.1 14.6 16.3 14.6 16.4 14.6 16.5 14.6 16.6 14.6 16.6 14.6 16.7 14.6 16.9 14.6 17 14.6 17.1 14.7 17.3 14.7 17.4 14.8 17.6 15 17.7 15.1 17.9 15.2 18 15.3 18 15.5 18.1 15.5 18.1 15.6 18.2 15.7 18.2 15.7 18.2 15.7 18.2 15.8 18.2L15.8 18.2ZM9.4 11.5C9.5 11.5 9.5 11.5 9.6 11.5 9.7 11.5 9.9 11.5 10 11.5 10.2 11.5 10.3 11.4 10.5 11.3 10.6 11.2 10.8 11.1 10.9 11 10.9 10.9 11 10.8 11.1 10.7 11.2 10.5 11.2 10.2 11.2 10 11.2 9.9 11.2 9.8 11.2 9.7 11.2 9.5 11.1 9.4 11 9.2 10.9 9.1 10.8 8.9 10.6 8.8 10.5 8.7 10.3 8.6 10 8.5 9.9 8.5 9.7 8.5 9.5 8.5 9.3 8.5 9.1 8.6 9 8.7 8.8 8.7 8.7 8.8 8.6 9 8.5 9.1 8.4 9.2 8.4 9.3 8.2 9.5 8.2 9.8 8.2 10 8.2 10.1 8.2 10.2 8.2 10.3 8.2 10.5 8.3 10.6 8.4 10.7 8.5 10.9 8.6 11.1 8.7 11.2 8.9 11.3 9 11.4 9.1 11.4 9.2 11.4 9.3 11.5 9.3 11.5 9.3 11.5 9.4 11.5 9.4 11.5L9.4 11.5ZM3 4.8C3.1 4.8 3.1 4.8 3.2 4.8 3.4 4.8 3.5 4.8 3.7 4.8 3.8 4.8 4 4.7 4.1 4.6 4.3 4.5 4.4 4.4 4.5 4.3 4.6 4.2 4.6 4.1 4.7 4 4.8 3.8 4.8 3.5 4.8 3.3 4.8 3.1 4.8 3 4.8 2.9 4.7 2.8 4.7 2.6 4.6 2.5 4.5 2.3 4.4 2.2 4.2 2.1 4 1.9 3.8 1.9 3.6 1.8 3.5 1.8 3.3 1.8 3.1 1.8 2.9 1.8 2.7 1.9 2.6 2 2.4 2.1 2.3 2.2 2.2 2.3 2.1 2.4 2 2.5 2 2.6 1.8 2.8 1.8 3 1.8 3.3 1.8 3.4 1.8 3.5 1.8 3.6 1.8 3.8 1.9 3.9 2 4 2.1 4.2 2.2 4.4 2.4 4.5 2.5 4.6 2.6 4.7 2.7 4.7 2.8 4.7 2.9 4.8 2.9 4.8 3 4.8 3 4.8 3 4.8L3 4.8ZM13.1 15.2C13.2 15.1 13.2 15.1 13.2 15.1 13.3 14.9 13.4 14.7 13.6 14.5 13.8 14.2 14.1 14 14.4 13.8 14.7 13.6 15.1 13.5 15.5 13.4 15.9 13.4 16.3 13.4 16.7 13.5 17.2 13.5 17.6 13.7 17.9 13.9 18.2 14.1 18.5 14.4 18.7 14.7 18.9 15 19.1 15.3 19.2 15.6 19.3 15.9 19.4 16.1 19.4 16.4 19.4 17 19.3 17.5 19.1 18.1 19 18.3 18.9 18.5 18.7 18.7 18.5 19 18.3 19.2 18 19.4 17.7 19.6 17.3 19.8 16.9 19.9 16.6 20 16.3 20 16 20 15.8 20 15.6 20 15.4 19.9 15.4 19.9 15.4 19.9 15.4 19.9 15.2 19.9 15 19.8 14.9 19.8 14.8 19.7 14.7 19.7 14.6 19.7 14.4 19.6 14.3 19.5 14.1 19.3 13.7 19.1 13.4 18.7 13.2 18.4 13.1 18.1 12.9 17.8 12.9 17.5 12.8 17.3 12.8 17.1 12.8 16.9L3.5 14.9C3.3 14.9 3.1 14.8 3 14.8 2.7 14.7 2.4 14.5 2.1 14.3 1.7 14 1.4 13.7 1.2 13.3 1 13 0.9 12.6 0.8 12.3 0.7 12 0.7 11.7 0.7 11.4 0.7 11 0.8 10.5 1 10.1 1.1 9.8 1.3 9.5 1.6 9.2 1.8 8.9 2.1 8.7 2.4 8.5 2.8 8.3 3.2 8.1 3.6 8.1 3.9 8 4.2 8 4.5 8 4.6 8 4.8 8 4.9 8.1L6.8 8.5C6.8 8.4 6.8 8.4 6.8 8.4 6.9 8.2 7.1 8 7.2 7.8 7.5 7.5 7.7 7.3 8 7.1 8.4 6.9 8.7 6.8 9.1 6.7 9.5 6.7 10 6.7 10.4 6.8 10.8 6.8 11.2 7 11.5 7.2 11.8 7.5 12.1 7.7 12.4 8 12.6 8.3 12.7 8.6 12.8 8.9 12.9 9.2 13 9.4 13 9.7 13 9.7 13 9.8 13 9.8 13.6 9.9 14.2 10.1 14.9 10.2 15 10.2 15 10.2 15.1 10.2 15.3 10.2 15.4 10.2 15.6 10.2 15.8 10.1 16 10 16.2 9.9 16.4 9.8 16.5 9.6 16.6 9.5 16.8 9.2 16.9 8.8 16.9 8.5 16.9 8.3 16.9 8.2 16.8 8 16.8 7.8 16.7 7.7 16.6 7.5 16.5 7.3 16.3 7.2 16.2 7.1 16 7 15.9 6.9 15.8 6.9 15.7 6.9 15.6 6.8 15.5 6.8L6.2 4.8C6.2 5 6 5.2 5.9 5.3 5.7 5.6 5.5 5.8 5.3 6 4.9 6.2 4.5 6.4 4.1 6.5 3.8 6.6 3.5 6.6 3.2 6.6 3 6.6 2.8 6.6 2.7 6.6 2.6 6.6 2.6 6.5 2.6 6.5 2.5 6.5 2.3 6.5 2.1 6.4 1.8 6.3 1.6 6.1 1.3 6 1 5.7 0.7 5.4 0.5 5 0.3 4.7 0.2 4.4 0.1 4.1 0 3.8 0 3.6 0 3.3 0 2.8 0.1 2.2 0.4 1.7 0.5 1.5 0.7 1.3 0.8 1.1 1.1 0.8 1.3 0.6 1.6 0.5 2 0.3 2.3 0.1 2.7 0.1 3.1 0 3.6 0 4 0.1 4.4 0.2 4.8 0.3 5.1 0.5 5.5 0.8 5.7 1 6 1.3 6.2 1.6 6.3 1.9 6.4 2.3 6.5 2.5 6.6 2.7 6.6 3 6.6 3 6.6 3.1 6.6 3.1 9.7 3.8 12.8 4.4 15.9 5.1 16.1 5.1 16.2 5.2 16.4 5.2 16.7 5.3 16.9 5.5 17.2 5.6 17.5 5.9 17.8 6.2 18.1 6.5 18.3 6.8 18.4 7.2 18.6 7.5 18.6 7.9 18.7 8.2 18.7 8.6 18.7 9 18.6 9.4 18.4 9.8 18.3 10.1 18.2 10.3 18 10.6 17.8 10.9 17.5 11.1 17.3 11.3 16.9 11.6 16.5 11.8 16 11.9 15.7 12 15.3 12 15 12 14.8 12 14.7 12 14.5 11.9 13.9 11.8 13.3 11.7 12.6 11.5 12.5 11.7 12.4 11.9 12.3 12 12.1 12.3 11.9 12.5 11.7 12.7 11.3 12.9 10.9 13.1 10.5 13.2 10.2 13.3 9.9 13.3 9.6 13.3 9.4 13.3 9.2 13.3 9 13.2 9 13.2 9 13.2 9 13.2 8.8 13.2 8.7 13.2 8.5 13.1 8.2 13 8 12.8 7.7 12.6 7.4 12.4 7.1 12 6.8 11.7 6.7 11.4 6.6 11.1 6.5 10.8 6.4 10.6 6.4 10.4 6.4 10.2 5.8 10.1 5.2 9.9 4.5 9.8 4.4 9.8 4.4 9.8 4.3 9.8 4.1 9.8 4 9.8 3.8 9.8 3.6 9.9 3.4 10 3.2 10.1 3 10.2 2.9 10.4 2.8 10.5 2.6 10.8 2.5 11.1 2.5 11.5 2.5 11.6 2.5 11.8 2.6 12 2.6 12.1 2.7 12.3 2.8 12.5 2.9 12.6 3.1 12.8 3.2 12.9 3.3 13 3.5 13.1 3.6 13.1 3.7 13.1 3.8 13.2 3.9 13.2L13.1 15.2 13.1 15.2Z"></path></g></svg><span>Tutorials</span></a></li><li class="nav-offers flyout-parent"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#" class="l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" width="20" height="20" version="1.1" fill="#4A3C31"><desc>offers icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M35.9 20.6L27 15.5C26.1 15 24.7 15 23.7 15.5L14.9 20.6C13.9 21.1 13.2 22.4 13.2 23.4L13.2 41.4C13.2 42.4 13.9 43.7 14.9 44.2L23.3 49C24.2 49.5 25.6 49.5 26.6 49L35.9 43.6C36.8 43.1 37.6 41.8 37.6 40.8L37.6 23.4C37.6 22.4 36.8 21.1 35.9 20.6L35.9 20.6ZM40 8.2C39.1 7.6 37.6 7.6 36.7 8.2L30.2 11.9C29.3 12.4 29.3 13.2 30.2 13.8L39.1 18.8C40 19.4 40.7 20.6 40.7 21.7L40.7 39C40.7 40.1 41.4 40.5 42.4 40L48.2 36.6C49.1 36.1 49.8 34.9 49.8 33.8L49.8 15.6C49.8 14.6 49.1 13.3 48.2 12.8L40 8.2 40 8.2ZM27 10.1L33.6 6.4C34.5 5.9 34.5 5 33.6 4.5L26.6 0.5C25.6 0 24.2 0 23.3 0.5L16.7 4.2C15.8 4.7 15.8 5.6 16.7 6.1L23.7 10.1C24.7 10.6 26.1 10.6 27 10.1ZM10.1 21.7C10.1 20.6 10.8 19.4 11.7 18.8L20.6 13.8C21.5 13.2 21.5 12.4 20.6 11.9L13.6 7.9C12.7 7.4 11.2 7.4 10.3 7.9L1.6 12.8C0.7 13.3 0 14.6 0 15.6L0 33.8C0 34.9 0.7 36.1 1.6 36.6L8.4 40.5C9.3 41 10.1 40.6 10.1 39.6L10.1 21.7 10.1 21.7Z"></path></g></svg><span>Offers &amp; Deals</span></a><ul class="flyout"><li><a href="https://get.oreilly.com/email-signup.html" target="_blank" class="l2 nav-icn"><span>Newsletters</span></a></li></ul></li><li class="nav-highlights"><a href="https://www.safaribooksonline.com/u/f04af719-1c84-4fc3-9be3-1f1b4622ab99/" class="t-highlights-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 35" width="20" height="20" version="1.1" fill="#4A3C31"><desc>highlights icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M13.325 18.071L8.036 18.071C8.036 11.335 12.36 7.146 22.5 5.594L22.5 0C6.37 1.113 0 10.632 0 22.113 0 29.406 3.477 35 10.403 35 15.545 35 19.578 31.485 19.578 26.184 19.578 21.556 17.211 18.891 13.325 18.071L13.325 18.071ZM40.825 18.071L35.565 18.071C35.565 11.335 39.86 7.146 50 5.594L50 0C33.899 1.113 27.5 10.632 27.5 22.113 27.5 29.406 30.977 35 37.932 35 43.045 35 47.078 31.485 47.078 26.184 47.078 21.556 44.74 18.891 40.825 18.071L40.825 18.071Z"></path></g></svg><span>Highlights</span></a></li><li><a href="https://www.safaribooksonline.com/u/preferences/" class="t-settings-nav l1 js-settings nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"></path></g></svg><span>Settings</span></a></li><li><a href="https://www.oreilly.com/online-learning/support/" class="l1 no-icon">Support</a></li><li><a href="https://www.safaribooksonline.com/accounts/logout/" class="l1 no-icon">Sign Out</a></li></ul><ul class="profile"><li><a href="https://www.safaribooksonline.com/u/preferences/" class="l2 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" width="20" height="20" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z"></path></g></svg><span>Settings</span></a><span class="l2 t-nag-notification" id="nav-nag"><strong class="trial-green">10</strong> days left in your trial.
  
  

  
    
      

<a class="" href="https://www.safaribooksonline.com/subscribe/">Subscribe</a>.


    
  

  

</span></li><li><a href="https://www.oreilly.com/online-learning/support/" class="l2">Support</a></li><li><a href="https://www.safaribooksonline.com/accounts/logout/" class="l2">Sign Out</a></li></ul></div></li></ul></nav></header>


      </div>
      <div id="container" class="application" style="height: auto;">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Designing Data-Intensive Applications
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#" title="Search in archive" class="js-search-controls search-controls"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><div class="js-content-uri" data-content-uri="/api/v1/book/9781491903063/chapter/ch05.html"><div class="js-collections-dropdown collections-dropdown menu-bit-cards"><div data-reactroot="" class="menu-dropdown-wrapper js-menu-dropdown-wrapper align-right"><img class="hidden" src="https://www.safaribooksonline.com/static/images/ajax-transp.gif" alt="loading spinner"><div class="menu-control"><div class="control "><div class="js-playlists-menu"><button class="js-playlist-icon"><svg class="icon-add-to-playlist-sml" viewBox="0 0 16 14" version="1.1" xmlns="http://www.w3.org/2000/svg"><g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"><g fill-rule="nonzero" fill="#000000"><g transform="translate(-1.000000, 0.000000)"><rect x="5" y="0" width="12" height="2"></rect><title>Playlists</title><path d="M4.5,14 C6.43299662,14 8,12.4329966 8,10.5 C8,8.56700338 6.43299662,7 4.5,7 C2.56700338,7 1,8.56700338 1,10.5 C1,12.4329966 2.56700338,14 4.5,14 Z M2.5,10 L4,10 L4,8.5 L5,8.5 L5,10 L6.5,10 L6.5,11 L5,11 L5,12.5 L4,12.5 L4,11 L2.5,11 L2.5,10 Z"></path><circle cx="2" cy="5" r="1"></circle><circle cx="1.94117647" cy="1" r="1"></circle><rect x="5" y="4" width="12" height="2"></rect><rect x="9" y="8" width="8" height="2"></rect><rect x="9" y="12" width="8" height="2"></rect></g></g></g></svg><div class="js-playlist-addto-label">Add&nbsp;To</div></button></div></div></div></div></div></div></li><li class="js-font-control-panel font-control-activator"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a class="twitter share-button t-twitter" target="_blank" aria-label="Share this section on Twitter" title="Share this section on Twitter" href="https://twitter.com/share?url=https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/ch05.html&amp;text=Designing%20Data-Intensive%20Applications&amp;via=safari"><span>Twitter</span></a></li><li><a class="facebook share-button t-facebook" target="_blank" aria-label="Share this section on Facebook" title="Share this section on Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/ch05.html"><span>Facebook</span></a></li><li><a class="googleplus share-button t-googleplus" target="_blank" aria-label="Share this secton on Google Plus" title="Share this secton on Google Plus" href="https://plus.google.com/share?url=https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/ch05.html"><span>Google Plus</span></a></li><li><a class="email share-button t-email" aria-label="Share this section via email" title="Share this section via email" href="mailto:?subject=Safari:%205.%20Replication&amp;body=https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/ch05.html%0D%0Afrom%20Designing%20Data-Intensive%20Applications%0D%0A"><span>Email</span></a></li></ul></li>
      </ul>
    </div>

    <section role="document">
        
        



 <!--[if lt IE 9]>
  
<![endif]-->



  


        
	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="/site/library/view/designing-data-intensive-applications/9781491903063/part02.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">II. Distributed Data</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch06.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">6. Partitioning</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content" style="transform: none;"><div class="annotator-wrapper"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Replication"><div class="chapter" id="ch_replication">
<h1><span class="label">Chapter 5. </span>Replication</h1>

<blockquote data-type="epigraph" epub:type="epigraph">
  <p><em>The major difference between a thing that might go wrong and a thing that cannot possibly go wrong
is that when a thing that cannot possibly go wrong goes wrong it usually turns out to be impossible
to get at or repair.</em></p>
  <p data-type="attribution">Douglas Adams, <em>Mostly Harmless</em> (1992)</p>
</blockquote>

<div class="map-ebook">
 <img id="c271" src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ch05-map.png" width="2100" height="2756" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ch05-map.png">
</div>

<p><a data-type="indexterm" data-primary="replication" id="ix_replicate"></a>
<a data-type="indexterm" data-primary="distributed systems" data-secondary="reasons for using" id="idm140417569428656"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="reasons for using" id="idm140417569427552"></a>
<em>Replication</em> means keeping a copy of the same data on multiple machines that are connected via a
network. As discussed in the introduction to <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/part02.html#part_distributed_data">Part&nbsp;II</a>, there are several reasons
why you might want to replicate data:</p>

<ul>
<li>
<p>To keep data geographically close to your users (and thus reduce latency)</p>
</li>
<li>
<p>To allow the system to continue working even if some of its parts have failed (and thus
increase availability)</p>
</li>
<li>
<p>To scale out the number of machines that can serve read queries (and thus increase read
throughput)</p>
</li>
</ul>

<p>In this chapter we will assume that your dataset is so small that each machine can hold a copy of
the entire dataset. In <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch06.html#ch_partitioning">Chapter&nbsp;6</a> we will relax that assumption and discuss <em>partitioning</em>
(<em>sharding</em>) of datasets that are too big for a single machine. In later chapters we will discuss
various kinds of faults that can occur in a replicated data system, and how to deal with them.</p>

<p>If the data that you’re replicating does not change over time, then replication is easy: you just
need to copy the data to every node once, and you’re done. All of the difficulty in replication lies
in handling <em>changes</em> to replicated data, and that’s what this chapter is about. We will discuss
three popular algorithms for replicating changes between nodes: <em>single-leader</em>, <em>multi-leader</em>, and
<em>leaderless</em> replication. Almost all distributed databases use one of these three approaches. They
all have various pros and cons, which we will examine in detail.</p>

<p>There are many trade-offs to consider with replication: for example, whether to use synchronous or
asynchronous replication, and how to handle failed replicas. Those are often configuration options
in databases, and although the details vary by database, the general principles are similar across
many different implementations. We will discuss the consequences of such choices in this chapter.</p>

<p><a data-type="indexterm" data-primary="eventual consistency" data-seealso="conflicts" id="idm140417569415504"></a>
Replication of databases is an old topic—the principles haven’t changed much since they were
studied in the 1970s
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Lindsay1979wv_ch5-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Lindsay1979wv_ch5" class="totri-footnote">1</a>],
because the fundamental constraints of networks have remained the same. However, outside of
research, many developers continued to assume for a long time that a database consisted of just one
node. Mainstream use of distributed databases is more recent. Since many application developers are
new to this area, there has been a lot of misunderstanding around issues such as <em>eventual
consistency</em>. In <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_lag">“Problems with Replication Lag”</a> we will get more precise about eventual consistency and
discuss things like the <em>read-your-writes</em> and <em>monotonic reads</em> guarantees.</p>






<section data-type="sect1" data-pdf-bookmark="Leaders and Followers"><div class="sect1" id="sec_replication_leader">
<h1>Leaders and Followers</h1>

<p><a data-type="indexterm" data-primary="replicas" id="idm140417569407808"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="single-leader" id="ix_replleadfol"></a>
<a data-type="indexterm" data-primary="leader-based replication" data-seealso="replication" id="ix_leaderrepl"></a>
<a data-type="indexterm" data-primary="active/passive replication" data-see="leader-based replication" id="idm140417569404032"></a>
<a data-type="indexterm" data-primary="master-slave replication" data-see="leader-based replication" id="idm140417569402992"></a>
<a data-type="indexterm" data-primary="primary-secondary replication" data-see="leader-based replication" id="idm140417569401856"></a>
Each node that stores a copy of the database is called a <em>replica</em>. With multiple replicas, a
question inevitably arises: how do we ensure that all the data ends up on all the replicas?</p>

<p>Every write to the database needs to be processed by every replica; otherwise, the replicas would no
longer contain the same data. The most common solution for this is called <em>leader-based
replication</em> (also known as <em>active/passive</em> or <em>master–slave replication</em>) and is illustrated in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_leader_follower">Figure&nbsp;5-1</a>. It works as follows:</p>
<ol>
<li>
<p>One of the replicas is designated the <em>leader</em> (also known as <em>master</em> or <em>primary</em>). When
clients want to write to the database, they must send their requests to the leader, which first
writes the new data to its local storage.</p>
</li>
<li>
<p><a data-type="indexterm" data-primary="followers" data-seealso="leader-based replication" id="idm140417569394096"></a>
<a data-type="indexterm" data-primary="read replicas" data-see="leader-based replication" id="idm140417569392528"></a>
<a data-type="indexterm" data-primary="slaves" data-see="leader-based replication" id="idm140417569391408"></a>
<a data-type="indexterm" data-primary="secondaries" data-see="leader-based replication" id="idm140417569390288"></a>
<a data-type="indexterm" data-primary="standbys" data-see="leader-based replication" id="idm140417569389168"></a>
<a data-type="indexterm" data-primary="hot standbys" data-see="leader-based replication" id="idm140417569388048"></a>
<a data-type="indexterm" data-primary="logs (data structure)" data-secondary="replication" id="idm140417569386928"></a>
The other replicas are known as <em>followers</em> (<em>read replicas</em>, <em>slaves</em>, <em>secondaries</em>, or
<em>hot standbys</em>).<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm140417569383648-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417569383648" class="totri-footnote">i</a></sup> Whenever the leader writes new data to its local storage, it also sends the
data change to all of its followers as part of a  <em>replication log</em> or
<em>change stream</em>. Each follower takes the log from the leader and updates its local copy of the
database accordingly, by applying all writes in the same order as they were processed on the
leader.</p>
</li>
<li>
<p>When a client wants to read from the database, it can query either the leader or any of the
followers. However, writes are only accepted on the leader (the followers are read-only from the
client’s point of view).</p>
</li>

</ol>

<figure><div id="fig_replication_leader_follower" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0501.png" alt="ddia 0501" width="2880" height="925" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0501.png">
<h6><span class="label">Figure 5-1. </span>Leader-based (master–slave) replication.</h6>
</div></figure>

<p><a data-type="indexterm" data-primary="relational databases" data-secondary="leader-based replication" id="idm140417569375712"></a>
<a data-type="indexterm" data-primary="PostgreSQL (database)" data-secondary="leader-based replication" id="idm140417569374192"></a>
<a data-type="indexterm" data-primary="MySQL (database)" data-secondary="leader-based replication" id="idm140417569373072"></a>
<a data-type="indexterm" data-primary="Oracle (database)" data-secondary="leader-based replication" id="idm140417569371952"></a>
<a data-type="indexterm" data-primary="SQL Server (database)" data-secondary="leader-based replication" id="idm140417569370832"></a>
<a data-type="indexterm" data-primary="MongoDB (database)" data-secondary="leader-based replication" id="idm140417569369712"></a>
<a data-type="indexterm" data-primary="RethinkDB (database)" data-secondary="leader-based replication" id="idm140417569368592"></a>
<a data-type="indexterm" data-primary="LinkedIn" data-secondary="Espresso (database)" id="idm140417569367472"></a>
<a data-type="indexterm" data-primary="Kafka (messaging)" data-secondary="leader-based replication" id="idm140417569366368"></a>
<a data-type="indexterm" data-primary="RabbitMQ (messaging)" data-secondary="leader-based replication" id="idm140417569365248"></a>
<a data-type="indexterm" data-primary="DRBD (Distributed Replicated Block Device)" id="idm140417569364128"></a>
This mode of replication is a built-in feature of many relational databases, such as PostgreSQL
(since version 9.0), MySQL, Oracle Data Guard
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Oracle2013uz-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Oracle2013uz" class="totri-footnote">2</a>],
and SQL Server’s AlwaysOn Availability Groups
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="AlwaysOn2012-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#AlwaysOn2012" class="totri-footnote">3</a>].
It is also used in some nonrelational databases, including MongoDB, RethinkDB, and Espresso
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Qiao2013uv_ch5-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Qiao2013uv_ch5" class="totri-footnote">4</a>]. Finally, leader-based
replication is not restricted to only databases: distributed message brokers such as Kafka
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Rao2013tf-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Rao2013tf" class="totri-footnote">5</a>]
and RabbitMQ highly available queues
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="RabbitMQ2013-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#RabbitMQ2013" class="totri-footnote">6</a>]
also use it. Some network filesystems and replicated block devices such as DRBD are similar.</p>








<section data-type="sect2" data-pdf-bookmark="Synchronous Versus Asynchronous Replication"><div class="sect2" id="sec_replication_sync_async">
<h2>Synchronous Versus Asynchronous Replication</h2>

<p><a data-type="indexterm" data-primary="leader-based replication" data-secondary="synchronous versus asynchronous" id="ix_leadreplsyncasync"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="single-leader" data-tertiary="synchronous versus asynchronous" id="ix_replleadfolsyncasync"></a>
An important detail of a replicated system is whether the replication happens <em>synchronously</em> or
<em>asynchronously</em>. (In relational databases, this is often a configurable option; other systems are
often hardcoded to be either one or the other.)</p>

<p>Think about what happens in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_leader_follower">Figure&nbsp;5-1</a>, where the user of a website updates
their profile image. At some point in time, the client sends the update request to the leader;
shortly afterward, it is received by the leader. At some point, the leader forwards the data change
to the followers. Eventually, the leader notifies the client that the update was successful.</p>

<p><a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_sync_replication">Figure&nbsp;5-2</a> shows the communication between various components of the
system: the user’s client, the leader, and two followers. Time flows from left to right. A request
or response message is shown as a thick arrow.</p>

<figure><div id="fig_replication_sync_replication" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0502.png" alt="ddia 0502" width="2880" height="1128" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0502.png">
<h6><span class="label">Figure 5-2. </span>Leader-based replication with one synchronous and one asynchronous follower.</h6>
</div></figure>

<p><a data-type="indexterm" data-primary="synchronous replication" id="idm140417569341136"></a>
<a data-type="indexterm" data-primary="asynchronous replication" id="idm140417569340304"></a>
In the example of <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_sync_replication">Figure&nbsp;5-2</a>, the replication to follower 1 is
<em>synchronous</em>: the leader waits until follower 1 has confirmed that it received the write before
reporting success to the user, and before making the write visible to other clients. The replication
to follower 2 is <em>asynchronous</em>: the leader sends the message, but doesn’t wait for a response from
the follower.</p>

<p>The diagram shows that there is a substantial delay before follower 2 processes the message.
Normally, replication is quite fast: most database systems apply changes to followers in less than a
second. However, there is no guarantee of how long it might take. There are circumstances when
followers might fall behind the leader by several minutes or more; for example, if a follower is
recovering from a failure, if the system is operating near maximum capacity, or if there are network
problems between the nodes.</p>

<p>The advantage of synchronous replication is that the follower is guaranteed to have an up-to-date
copy of the data that is consistent with the leader. If the leader suddenly fails, we can be sure
that the data is still available on the follower. The disadvantage is that if the synchronous
follower doesn’t respond (because it has crashed, or there is a network fault, or for any other
reason), the write cannot be processed. The leader must block all writes and wait until the
synchronous replica is available again.</p>

<p><a data-type="indexterm" data-primary="semi-synchronous replication" id="idm140417569335312"></a>
For that reason, it is impractical for all followers to be synchronous: any one node outage would
cause the whole system to grind to a halt. In practice, if you enable synchronous replication on a
database, it usually means that <em>one</em> of the followers is synchronous, and the others are
asynchronous. If the synchronous follower becomes unavailable or slow, one of the asynchronous
followers is made synchronous. This guarantees that you have an up-to-date copy of the data on at
least two nodes: the leader and one synchronous follower. This configuration is sometimes also
called <em>semi-synchronous</em> [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Matsunobu2014wu-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Matsunobu2014wu" class="totri-footnote">7</a>].</p>

<p>Often, leader-based replication is configured to be completely asynchronous. In this case, if the
leader fails and is not recoverable, any writes that have not yet been replicated to followers are
lost. This means that a write is not guaranteed to be durable, even if it has been confirmed to the
client. However, a fully asynchronous configuration has the advantage that the leader can continue
processing writes, even if all of its followers have fallen behind.</p>

<p>Weakening durability may sound like a bad trade-off, but asynchronous replication is nevertheless
widely used, especially if there are many followers or if they are geographically distributed. We
will return to this issue in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_lag">“Problems with Replication Lag”</a>.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_replication_research">
<h5>Research on Replication</h5>
<p><a data-type="indexterm" data-primary="chain replication" id="idm140417569326480"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="chain replication" id="idm140417569325456"></a>
<a data-type="indexterm" data-primary="synchronous replication" data-secondary="chain replication" id="idm140417569324352"></a>
<a data-type="indexterm" data-primary="Microsoft" data-secondary="Azure Storage" id="idm140417569323248"></a>
<a data-type="indexterm" data-primary="Azure" data-see="Microsoft" id="idm140417569322144"></a>
It can be a serious problem for asynchronously replicated systems to lose data if the leader fails,
so researchers have continued investigating replication methods that do not lose data but still
provide good performance and availability. For example, <em>chain replication</em>
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="vanRenesse2004td_ch5-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#vanRenesse2004td_ch5" class="totri-footnote">8</a>,
<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Terrace2009vx-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Terrace2009vx" class="totri-footnote">9</a>] is a variant of synchronous replication
that has been successfully implemented in a few systems such as Microsoft Azure Storage
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Calder2011to-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Calder2011to">10</a>,
<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Wang2016vy-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Wang2016vy">11</a>].</p>

<p><a data-type="indexterm" data-primary="consensus" data-secondary="relation to replication" id="idm140417569310832"></a>
There is a strong connection between consistency of replication and <em>consensus</em> (getting several
nodes to agree on a value), and we will explore this area of theory in more detail in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch09.html#ch_consistency">Chapter&nbsp;9</a>. In this chapter we will concentrate on the simpler forms of replication that are
most commonly used in databases in practice.
<a data-type="indexterm" data-primary="leader-based replication" data-secondary="synchronous versus asynchronous" data-startref="ix_leadreplsyncasync" id="idm140417569308160"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="single-leader" data-tertiary="synchronous versus asynchronous" data-startref="ix_replleadfolsyncasync" id="idm140417569306880"></a></p>
</div></aside>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Setting Up New Followers"><div class="sect2" id="sec_replication_new_replica">
<h2>Setting Up New Followers</h2>

<p><a data-type="indexterm" data-primary="leader-based replication" data-secondary="setting up new followers" id="idm140417569303552"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="single-leader" data-tertiary="setting up new followers" id="idm140417569302368"></a>
From time to time, you need to set up new followers—perhaps to increase the number of replicas,
or to replace failed nodes. How do you ensure that the new follower has an accurate copy of the
leader’s data?</p>

<p>Simply copying data files from one node to another is typically not sufficient: clients are
constantly writing to the database, and the data is always in flux, so a standard file copy would
see different parts of the database at different points in time. The result might not make any
sense.</p>

<p>You could make the files on disk consistent by locking the database (making it unavailable for
writes), but that would go against our goal of high availability. Fortunately, setting up a
follower can usually be done without downtime. Conceptually, the process looks like this:</p>
<ol>
<li>
<p><a data-type="indexterm" data-primary="backups" data-secondary="database snapshot for replication" id="idm140417569298432"></a>
<a data-type="indexterm" data-primary="consistency" data-secondary="consistent snapshots" data-seealso="snapshots" id="idm140417569297200"></a>
<a data-type="indexterm" data-primary="snapshots (databases)" data-secondary="setting up a new replica" id="idm140417569295824"></a>
<a data-type="indexterm" data-primary="MySQL (database)" data-secondary="consistent snapshots" id="idm140417569294704"></a>
<a data-type="indexterm" data-primary="Percona XtraBackup (MySQL tool)" id="idm140417569293600"></a>
Take a consistent snapshot of the leader’s database at some point in time—if possible, without
taking a lock on the entire database. Most databases have this feature, as it is also required
for backups. In some cases, third-party tools are needed, such as <em>innobackupex</em> for MySQL
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Xtrabackup2014-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Xtrabackup2014">12</a>].</p>
</li>
<li>
<p>Copy the snapshot to the new follower node.</p>
</li>
<li>
<p><a data-type="indexterm" data-primary="logs (data structure)" data-secondary="replication" data-tertiary="coordination with snapshot" id="idm140417569288848"></a>
<a data-type="indexterm" data-primary="log sequence number" id="idm140417569287280"></a>
<a data-type="indexterm" data-primary="leader-based replication" data-secondary="log sequence number" id="idm140417569286448"></a>
<a data-type="indexterm" data-primary="PostgreSQL (database)" data-secondary="log sequence number" id="idm140417569285328"></a>
<a data-type="indexterm" data-primary="MySQL (database)" data-secondary="binlog coordinates" id="idm140417569284224"></a>
The follower connects to the leader and requests all the data changes that have happened since
the snapshot was taken. This requires that the snapshot is associated with an exact position in
the leader’s replication log. That position has various names: for example, PostgreSQL calls it
the <em>log sequence number</em>, and MySQL calls it the <em>binlog coordinates</em>.</p>
</li>
<li>
<p>When the follower has processed the backlog of data changes since the snapshot, we say it has
<em>caught up</em>. It can now continue to process data changes from the leader as they happen.</p>
</li>

</ol>

<p>The practical steps of setting up a follower vary significantly by database. In some systems the
process is fully automated, whereas in others it can be a somewhat arcane multi-step workflow that
needs to be manually performed by an administrator.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Handling Node Outages"><div class="sect2" id="sec_replication_failover">
<h2>Handling Node Outages</h2>

<p><a data-type="indexterm" data-primary="leader-based replication" data-secondary="handling node outages" id="idm140417569277984"></a>
<a data-type="indexterm" data-primary="nodes (processes)" data-secondary="handling outages in leader-based replication" id="idm140417569276864"></a>
Any node in the system can go down, perhaps unexpectedly due to a fault, but just as likely due to
planned maintenance (for example, rebooting a machine to install a kernel security patch). Being
able to reboot individual nodes without downtime is a big advantage for operations and maintenance.
Thus, our goal is to keep the system as a whole running despite individual node failures, and to keep
the impact of a node outage as small as possible.</p>

<p>How do you achieve high availability with leader-based replication?</p>










<section data-type="sect3" data-pdf-bookmark="Follower failure: Catch-up recovery"><div class="sect3" id="idm140417569274752">
<h3>Follower failure: Catch-up recovery</h3>

<p>On its local disk, each follower keeps a log of the data changes it has received from the leader. If
a follower crashes and is restarted, or if the network between the leader and the follower is
temporarily interrupted, the follower can recover quite easily: from its log, it knows the last
transaction that was processed before the fault occurred. Thus, the follower can connect to the
leader and request all the data changes that occurred during the time when the follower was
disconnected. When it has applied these changes, it has caught up to the leader and can continue
receiving a stream of data changes as before.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Leader failure: Failover"><div class="sect3" id="idm140417569272480">
<h3>Leader failure: Failover</h3>

<p><a data-type="indexterm" data-primary="leader-based replication" data-secondary="failover" id="idm140417569271024"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="single-leader" data-tertiary="failover" id="idm140417569269856"></a>
<a data-type="indexterm" data-primary="failover" data-seealso="leader-based replication" id="idm140417569268480"></a>
Handling a failure of the leader is trickier: one of the followers needs to be promoted to be the
new leader, clients need to be reconfigured to send their writes to the new leader, and the other
followers need to start consuming data changes from the new leader. This process is called
<em>failover</em>.</p>

<p>Failover can happen manually (an administrator is notified that the leader has failed and takes the
necessary steps to make a new leader) or automatically. An automatic failover process usually
consists of the following steps:</p>
<ol>
<li>
<p><em>Determining that the leader has failed.</em> There are many things that could potentially go wrong:
crashes, power outages, network issues, and more. There is no foolproof way of detecting what
has gone wrong, so most systems simply use a timeout: nodes frequently bounce messages back and
forth between each other, and if a node doesn’t respond for some period of time—say, 30
seconds—it is assumed to be dead. (If the leader is deliberately taken down for planned
maintenance, this doesn’t apply.)</p>
</li>
<li>
<p><em>Choosing a new leader.</em> This could be done through an election process (where the leader is chosen by
a majority of the remaining replicas), or a new leader could be appointed by a previously elected
<em>controller node</em>. The best candidate for leadership is usually the replica with the most
up-to-date data changes from the old leader (to minimize any data loss). Getting all the nodes to
agree on a new leader is a consensus problem, discussed in detail in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch09.html#ch_consistency">Chapter&nbsp;9</a>.</p>
</li>
<li>
<p><em>Reconfiguring the system to use the new leader.</em> Clients now need to send
<span class="keep-together">their write requests</span> to the new leader (we discuss this
in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch06.html#sec_partitioning_routing">“Request Routing”</a>). If the old leader comes back, it might still believe that it is
the leader, <span class="keep-together">not realizing</span> that the other replicas have
forced it to step down. The system needs to ensure that the old leader becomes a follower and
recognizes the new leader.</p>
</li>

</ol>

<p>Failover is fraught with things that can go wrong:</p>

<ul>
<li>
<p><a data-type="indexterm" data-primary="failover" data-secondary="potential problems" id="idm140417569255936"></a>
<a data-type="indexterm" data-primary="distributed systems" data-secondary="issues with failover" id="idm140417569254832"></a>
<a data-type="indexterm" data-primary="asynchronous replication" data-secondary="data loss on failover" id="idm140417569253728"></a>
If asynchronous replication is used, the new leader may not have received all the writes from the old
leader before it failed. If the former leader rejoins the cluster after a new leader has been
chosen, what should happen to those writes? The new leader may have received conflicting writes
in the meantime. The most common solution is for the old leader’s unreplicated writes to simply be
discarded, which may violate clients’ durability expectations.</p>
</li>
<li>
<p><a data-type="indexterm" data-primary="incidents" data-secondary="disclosure of sensitive data due to primary key reuse" id="idm140417569251424"></a>
<a data-type="indexterm" data-primary="GitHub, postmortems" id="idm140417569250224"></a>
Discarding writes is especially dangerous if other storage systems outside of the database need to
be coordinated with the database contents.
<a data-type="indexterm" data-primary="consistency" data-secondary="across different databases" id="idm140417569249232"></a>
For example, in one incident at GitHub [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Newland2012tw-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Newland2012tw">13</a>], an out-of-date MySQL follower
was promoted to leader. The database used an autoincrementing counter to assign primary keys to
new rows, but because the new leader’s counter lagged behind the old leader’s, it reused some
primary keys that were previously assigned by the old leader. These primary keys were also used in
a Redis store, so the reuse of primary keys resulted in inconsistency between MySQL and Redis,
which caused some private data to be disclosed to the wrong users.</p>
</li>
<li>
<p><a data-type="indexterm" data-primary="split brain" id="idm140417569244704"></a><a data-type="indexterm" data-primary="STONITH (Shoot The Other Node In The Head)" id="idm140417569243600"></a>
<a data-type="indexterm" data-primary="incidents" data-secondary="split brain due to 1-minute packet delay" id="idm140417569242768"></a>
<a data-type="indexterm" data-primary="GitHub, postmortems" id="idm140417569241632"></a>
<a data-type="indexterm" data-primary="fencing (preventing split brain)" id="idm140417569240800"></a>
<a data-type="indexterm" data-primary="corruption of data" data-secondary="due to split brain" id="idm140417569239904"></a>
<a data-type="indexterm" data-primary="data corruption" data-see="corruption of data" id="idm140417569238800"></a>
In certain fault scenarios (see <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch08.html#ch_distributed">Chapter&nbsp;8</a>), it could happen that two nodes both believe
that they are the leader. This situation is called <em>split brain</em>, and it is dangerous: if both
leaders accept writes, and there is no process for resolving conflicts (see
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_multi_leader">“Multi-Leader Replication”</a>), data is likely to be lost or corrupted. As a safety catch, some
systems have a mechanism to shut down one node if two leaders are
detected.<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm140417569235216-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417569235216">ii</a></sup>
However, if this mechanism is not carefully designed, you can end up with both nodes being shut down
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Imbriaco2012tx_ch5-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Imbriaco2012tx_ch5">14</a>].</p>
</li>
<li>
<p><a data-type="indexterm" data-primary="timeouts" data-secondary="for failover" id="idm140417569229680"></a>
What is the right timeout before the leader is declared dead? A longer timeout means a longer
time to recovery in the case where the leader fails. However, if the timeout is too short, there
could be unnecessary failovers. For example, a temporary load spike could cause a node’s response
time to increase above the timeout, or a network glitch could cause delayed packets. If the system
is already struggling with high load or network problems, an unnecessary failover is likely to
make the situation worse, not better.</p>
</li>
</ul>

<p>There are no easy solutions to these problems. For this reason, some operations teams prefer to
perform failovers manually, even if the software supports automatic failover.</p>

<p>These issues—node failures; unreliable networks; and trade-offs around replica consistency,
durability, availability, and latency—are in fact fundamental problems in distributed systems.
In <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch08.html#ch_distributed">Chapter&nbsp;8</a> and <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch09.html#ch_consistency">Chapter&nbsp;9</a> we will discuss them in greater depth.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Implementation of Replication Logs"><div class="sect2" id="sec_replication_implementation">
<h2>Implementation of Replication Logs</h2>

<p><a data-type="indexterm" data-primary="logs (data structure)" data-secondary="replication" id="ix_logsreplica"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="single-leader" data-tertiary="implementation of replication logs" id="ix_replleadfollog"></a>
<a data-type="indexterm" data-primary="replication logs" data-see="logs" id="idm140417569220080"></a>
How does leader-based replication work under the hood? Several different replication methods are
used in practice, so let’s look at each one briefly.</p>










<section data-type="sect3" data-pdf-bookmark="Statement-based replication"><div class="sect3" id="idm140417569218672">
<h3>Statement-based replication</h3>

<p><a data-type="indexterm" data-primary="statement-based replication" id="idm140417569217296"></a>
<a data-type="indexterm" data-primary="leader-based replication" data-secondary="implementation of replication logs" data-tertiary="statement-based" id="idm140417569216288"></a>
<a data-type="indexterm" data-primary="relational databases" data-secondary="statement-based replication" id="idm140417569214880"></a>
<a data-type="indexterm" data-primary="logs (data structure)" data-secondary="replication" data-tertiary="statement-based replication" id="idm140417569213760"></a>
<a data-type="indexterm" data-primary="SQL (Structured Query Language)" data-secondary="statement-based replication" id="idm140417569212368"></a>
In the simplest case, the leader logs every write request (<em>statement</em>) that it executes and sends
that statement log to its followers. For a relational database, this means that every <code>INSERT</code>,
<code>UPDATE</code>, or <code>DELETE</code> statement is forwarded to followers, and each follower parses and executes
that SQL statement as if it had been received from a <span class="keep-together">client.</span></p>

<p>Although this may sound reasonable, there are various ways in which this approach to replication can
break down:</p>

<ul>
<li>
<p>Any statement that calls a nondeterministic function, such as <code>NOW()</code> to get the current date
and time or <code>RAND()</code> to get a random number, is likely to generate a different value on each
replica.</p>
</li>
<li>
<p>If statements use an autoincrementing column, or if they depend on the existing data in the
database (e.g., <code>UPDATE … WHERE <em>&lt;some condition&gt;</em></code>), they must be executed in exactly the same
order on each replica, or else they may have a different effect. This can be limiting when there
are multiple concurrently executing transactions.</p>
</li>
<li>
<p>Statements that have side effects (e.g., triggers, stored procedures, user-defined functions) may
result in different side effects occurring on each replica, unless the side effects are absolutely
deterministic.</p>
</li>
</ul>

<p>It is possible to work around those issues—for example, the leader can replace any
nondeterministic function calls with a fixed return value when the statement is logged so that the
followers all get the same value. However, because there are so many edge cases, other replication
methods are now generally preferred.</p>

<p><a data-type="indexterm" data-primary="MySQL (database)" data-secondary="statement-based replication" id="idm140417569201936"></a>
<a data-type="indexterm" data-primary="VoltDB (database)" data-secondary="statement-based replication" id="idm140417569200816"></a>
Statement-based replication was used in MySQL before version 5.1. It is still sometimes used today,
as it is quite compact, but by default MySQL now switches to row-based replication (discussed shortly) if
there is any nondeterminism in a statement. VoltDB uses statement-based replication, and makes it
safe by requiring transactions to be deterministic
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Hugg2015wp-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Hugg2015wp">15</a>].</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Write-ahead log (WAL) shipping"><div class="sect3" id="idm140417569197168">
<h3>Write-ahead log (WAL) shipping</h3>

<p><a data-type="indexterm" data-primary="write-ahead log (WAL)" id="idm140417569195728"></a>
<a data-type="indexterm" data-primary="logs (data structure)" data-secondary="replication" data-tertiary="write-ahead log (WAL) shipping" id="idm140417569194896"></a>
<a data-type="indexterm" data-primary="leader-based replication" data-secondary="implementation of replication logs" data-tertiary="write-ahead log (WAL) shipping" id="idm140417569193504"></a>
In <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch03.html#ch_storage">Chapter&nbsp;3</a> we discussed how storage engines represent data on disk, and we found that usually
every write is appended to a log:</p>

<ul>
<li>
<p>In the case of a log-structured storage engine (see <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch03.html#sec_storage_lsm_trees">“SSTables and LSM-Trees”</a>), this log is the
main place for storage. Log segments are compacted and garbage-collected in the background.</p>
</li>
<li>
<p>In the case of a B-tree (see <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch03.html#sec_storage_b_trees">“B-Trees”</a>), which overwrites individual disk blocks,
every modification is first written to a write-ahead log so that the index can be restored
to a consistent state after a crash.</p>
</li>
</ul>

<p>In either case, the log is an append-only sequence of bytes containing all writes to the database.
We can use the exact same log to build a replica on another node: besides writing the log to disk,
the leader also sends it across the network to its followers. When the follower processes this log,
it builds a copy of the exact same data structures as found on the leader.</p>

<p><a data-type="indexterm" data-primary="PostgreSQL (database)" data-secondary="WAL-based replication" id="idm140417569185968"></a>
<a data-type="indexterm" data-primary="Oracle (database)" data-secondary="WAL-based replication" id="idm140417569184864"></a>
This method of replication is used in PostgreSQL and Oracle, among others
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="WALInternalsOfPos2012vf-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#WALInternalsOfPos2012vf">16</a>].
The main disadvantage is that the log describes the data on a very low level: a WAL contains details
of which bytes were changed in which disk blocks. This makes replication closely coupled to the
storage engine. If the database changes its storage format from one version to another, it is
typically not possible to run different versions of the database software on the leader and the
followers.</p>

<p>That may seem like a minor implementation detail, but it can have a big operational impact. If the
replication protocol allows the follower to use a newer software version than the leader, you can
perform a zero-downtime upgrade of the database software by first upgrading the followers and then
performing a failover to make one of the upgraded nodes the new leader. If the replication protocol
does not allow this version mismatch, as is often the case with WAL shipping, such upgrades require
downtime.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Logical (row-based) log replication"><div class="sect3" id="idm140417569179968">
<h3>Logical (row-based) log replication</h3>

<p><a data-type="indexterm" data-primary="logs (data structure)" data-secondary="replication" data-tertiary="logical (row-based) replication" id="idm140417569178672"></a>
<a data-type="indexterm" data-primary="row-oriented storage" data-secondary="row-based replication" id="idm140417569177344"></a>
<a data-type="indexterm" data-primary="logical logs" id="idm140417569176240"></a>
An alternative is to use different log formats for replication and for the storage engine, which
allows the replication log to be decoupled from the storage engine internals. This kind of
replication log is called a <em>logical log</em>, to distinguish it from the storage engine’s (<em>physical</em>)
data representation.</p>

<p><a data-type="indexterm" data-primary="relational databases" data-secondary="logical logs" id="idm140417569173984"></a>
A logical log for a relational database is usually a sequence of records describing writes to
database tables at the granularity of a row:</p>

<ul>
<li>
<p>For an inserted row, the log contains the new values of all columns.</p>
</li>
<li>
<p>For a deleted row, the log contains enough information to uniquely identify the row that was
deleted. Typically this would be the primary key, but if there is no primary key on the table, the
old values of all columns need to be logged.</p>
</li>
<li>
<p>For an updated row, the log contains enough information to uniquely identify the updated row, and
the new values of all columns (or at least the new values of all columns that changed).</p>
</li>
</ul>

<p><a data-type="indexterm" data-primary="MySQL (database)" data-secondary="row-based replication" id="idm140417569168880"></a>
A transaction that modifies several rows generates several such log records, followed by a record
indicating that the transaction was committed. MySQL’s binlog (when configured to use row-based
replication) uses this approach
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="MySQLInternals-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#MySQLInternals">17</a>].</p>

<p>Since a logical log is decoupled from the storage engine internals, it can more easily be kept
backward compatible, allowing the leader and the follower to run different versions of the database
software, or even different storage engines.</p>

<p><a data-type="indexterm" data-primary="change data capture" id="idm140417569164736"></a>
A logical log format is also easier for external applications to parse. This aspect is useful if you want
to send the contents of a database to an external system, such as a data warehouse for offline
analysis, or for building custom indexes and caches
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Sharma2015te_ch5-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Sharma2015te_ch5">18</a>].
This technique is called <em>change data capture</em>, and we will return to it in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch11.html#ch_stream">Chapter&nbsp;11</a>.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Trigger-based replication"><div class="sect3" id="sec_replication_trigger">
<h3>Trigger-based replication</h3>

<p><a data-type="indexterm" data-primary="triggers (databases)" data-secondary="implementing replication" id="idm140417569158320"></a>
<a data-type="indexterm" data-primary="logs (data structure)" data-secondary="replication" data-tertiary="trigger-based replication" id="idm140417569157152"></a>
<a data-type="indexterm" data-primary="leader-based replication" data-secondary="implementation of replication logs" data-tertiary="trigger-based replication" id="idm140417569155760"></a>
The replication approaches described so far are implemented by the database system, without
involving any application code. In many cases, that’s what you want—but there are some
circumstances where more flexibility is needed. For example, if you want to only replicate a subset
of the data, or want to replicate from one kind of <span class="keep-together">database</span>
to another, or if you need conflict resolution logic (see <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_write_conflicts">“Handling Write Conflicts”</a>), then
you may need to move replication up to the application layer.</p>

<p><a data-type="indexterm" data-primary="stored procedures" id="idm140417569152144"></a>
<a data-type="indexterm" data-primary="triggers (databases)" id="idm140417569151072"></a>
<a data-type="indexterm" data-primary="Oracle (database)" data-secondary="GoldenGate (change data capture)" id="idm140417569150240"></a>
<a data-type="indexterm" data-primary="GoldenGate (change data capture)" id="idm140417569149168"></a>
Some tools, such as Oracle GoldenGate
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Oracle2013ub-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Oracle2013ub">19</a>],
can make data changes available to an application by reading the database log. An alternative is to use features that are available in
many relational databases: <em>triggers</em> and <em>stored procedures</em>.</p>

<p><a data-type="indexterm" data-primary="LinkedIn" data-secondary="Databus (change data capture)" id="idm140417569145328"></a>
<a data-type="indexterm" data-primary="PostgreSQL (database)" data-secondary="Bucardo (trigger-based replication)" id="idm140417569144208"></a>
A trigger lets you register custom application code that is automatically executed when a data
change (write transaction) occurs in a database system. The trigger has the opportunity to log this
change into a separate table, from which it can be read by an external process. That external
process can then apply any necessary application logic and replicate the data change to another
system. Databus for Oracle
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Das2012uf_ch5-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Das2012uf_ch5">20</a>]
and Bucardo for Postgres [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Mullane2014uy-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Mullane2014uy">21</a>]
work like this, for example.</p>

<p>Trigger-based replication typically has greater overheads than other replication methods, and is
more prone to bugs and limitations than the database’s built-in replication. However, it can
nevertheless be useful due to its flexibility.
<a data-type="indexterm" data-primary="logs (data structure)" data-secondary="replication" data-startref="ix_logsreplica" id="idm140417569137520"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="single-leader" data-tertiary="implementation of replication logs" data-startref="ix_replleadfollog" id="idm140417569136144"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="single-leader" data-startref="ix_replleadfol" id="idm140417569134432"></a>
<a data-type="indexterm" data-primary="leader-based replication" data-startref="ix_leaderrepl" id="idm140417569133056"></a></p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Problems with Replication Lag"><div class="sect1" id="sec_replication_lag">
<h1>Problems with Replication Lag</h1>

<p><a data-type="indexterm" data-primary="concurrency" data-secondary="in replicated systems" id="ix_concrepllag"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="consistency properties" id="ix_replproblag"></a>
<a data-type="indexterm" data-primary="scalability" data-secondary="replication and" id="idm140417569127504"></a>
Being able to tolerate node failures is just one reason for wanting replication. As mentioned
in the introduction to <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/part02.html#part_distributed_data">Part&nbsp;II</a>, other reasons are scalability (processing more
requests than a single machine can handle) and latency (placing replicas geographically closer to
users).</p>

<p><a data-type="indexterm" data-primary="leader-based replication" data-secondary="read-scaling architecture" id="idm140417569125040"></a>
<a data-type="indexterm" data-primary="read-scaling architecture" id="idm140417569123952"></a>
Leader-based replication requires all writes to go through a single node, but read-only queries can
go to any replica. For workloads that consist of mostly reads and only a small percentage of writes
(a common pattern on the web), there is an attractive option: create many followers, and distribute
the read requests across those followers. This removes load from the leader and allows read requests to be
served by nearby replicas.</p>

<p>In this <em>read-scaling</em> architecture, you can increase the capacity for serving read-only requests
simply by adding more followers. However, this approach only realistically works with asynchronous
replication—if you tried to synchronously replicate to all followers, a single node failure or
network outage would make the entire system unavailable for writing. And the more nodes you have,
the likelier it is that one will be down, so a fully synchronous configuration would be very unreliable.</p>

<p><a data-type="indexterm" data-primary="asynchronous replication" data-secondary="reads from asynchronous follower" id="idm140417569121040"></a>
<a data-type="indexterm" data-primary="eventual consistency" id="idm140417569119792"></a>
<a data-type="indexterm" data-primary="consistency" data-secondary="eventual" data-seealso="eventual consistency" id="idm140417569118960"></a>
<a data-type="indexterm" data-primary="relational databases" data-secondary="eventual consistency" id="idm140417569117584"></a>
Unfortunately, if an application reads from an <em>asynchronous</em> follower, it may see outdated
information if the follower has fallen behind. This leads to apparent inconsistencies in the
database: if you run the same query on the leader and a follower at the same time, you may get
different results, because not all writes have been reflected in the follower. This inconsistency is
just a temporary state—if you stop writing to the database and wait a while, the followers will
eventually catch up and become consistent with the leader. For that reason, this effect is known
as <em>eventual consistency</em> [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Vogels2008ey-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Vogels2008ey">22</a>,
<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Terry2011vp-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Terry2011vp">23</a>].<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm140417569110560-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417569110560">iii</a></sup></p>

<p>The term “eventually” is deliberately vague: in general, there is no limit to how far a replica can
fall behind. In normal operation, the delay between a write happening on the leader and being
reflected on a follower—the <em>replication lag</em>—may be only a fraction of a second, and not
noticeable in practice. However, if the system is operating near capacity or if there is a problem
in the network, the lag can easily increase to several seconds or even minutes.</p>

<p>When the lag is so large, the inconsistencies it introduces are not just a theoretical issue but a
real problem for applications. In this section we will highlight three examples of problems that are
likely to occur when there is replication lag and outline some approaches to solving them.</p>








<section data-type="sect2" data-pdf-bookmark="Reading Your Own Writes"><div class="sect2" id="sec_replication_ryw">
<h2>Reading Your Own Writes</h2>

<p><a data-type="indexterm" data-primary="consistency" data-secondary="read-after-write" id="ix_consreadwrite"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="consistency properties" data-tertiary="reading your own writes" id="idm140417569102048"></a>
Many applications let the user submit some data and then view what they have submitted. This might
be a record in a customer database, or a comment on a discussion thread, or something else of that sort.
When new data is submitted, it must be sent to the leader, but when the user views the data, it can
be read from a follower. This is especially appropriate if data is frequently viewed but only
occasionally written.</p>

<p><a data-type="indexterm" data-primary="staleness (old data)" id="idm140417569099984"></a>
With asynchronous replication, there is a problem, illustrated in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_read_your_writes">Figure&nbsp;5-3</a>: if the user views the data shortly after making a write, the
new data may not yet have reached the replica. To the user, it looks as though the data they
submitted was lost, so they will be understandably unhappy.</p>

<figure><div id="fig_replication_read_your_writes" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0503.png" alt="ddia 0503" width="2880" height="1128" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0503.png">
<h6><span class="label">Figure 5-3. </span>A user makes a write, followed by a read from a stale replica. To prevent this anomaly, we need read-after-write consistency.</h6>
</div></figure>

<p><a data-type="indexterm" data-primary="read-after-write consistency" id="idm140417569095728"></a>
In this situation, we need <em>read-after-write consistency</em>, also known as <em>read-your-writes consistency</em>
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Terry1994fp-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Terry1994fp">24</a>].
This is a guarantee that if the user reloads the page, they will always see any updates they
submitted themselves. It makes no promises about other users: other users’ updates may not be
visible until some later time. However, it reassures the user that their own input has been saved
correctly.</p>

<p>How can we implement read-after-write consistency in a system with leader-based replication? There
are various possible techniques. To mention a few:</p>

<ul>
<li>
<p>When reading something that the user may have modified, read it from the leader; otherwise, read it
from a follower. This requires that you have some way of knowing whether something might have been
modified, without actually querying it. For example, user profile information on a social network
is normally only editable by the owner of the profile, not by anybody else. Thus, a simple
rule is: always read the user’s own profile from the leader, and any other users’ profiles from a
follower.</p>
</li>
<li>
<p>If most things in the application are potentially editable by the user, that approach won’t be
effective, as most things would have to be read from the leader (negating the benefit of read
scaling). In that case, other criteria may be used to decide whether to read from the leader. For
example, you could track the time of the last update and, for one minute after the last update, make all
reads from the leader. You could also monitor the replication lag on followers and
prevent queries on any follower that is more than one minute behind the leader.</p>
</li>
<li>
<p><a data-type="indexterm" data-primary="timestamps" data-secondary="for read-after-write consistency" id="idm140417569086272"></a>
The client can remember the timestamp of its most recent write—then the system can ensure that the
replica serving any reads for that user reflects updates at least until that timestamp. If a
replica is not sufficiently up to date, either the read can be handled by another replica or the
query can wait until the replica has caught up.
<a data-type="indexterm" data-primary="logical clocks" data-secondary="for read-after-write consistency" id="idm140417569084752"></a>
The timestamp could be a <em>logical timestamp</em> (something that indicates ordering of writes, such as
the log sequence number) or the actual system clock (in which case clock synchronization becomes
critical; see <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch08.html#sec_distributed_clocks">“Unreliable Clocks”</a>).</p>
</li>
<li>
<p><a data-type="indexterm" data-primary="datacenters" data-secondary="geographically distributed" id="idm140417569081440"></a>
<a data-type="indexterm" data-primary="geographically distributed datacenters" id="idm140417569080272"></a>
If your replicas are distributed across multiple datacenters (for geographical proximity to users
or for availability), there is additional complexity. Any request that needs to be served by the
leader must be routed to the datacenter that contains the leader.</p>
</li>
</ul>

<p><a data-type="indexterm" data-primary="read-after-write consistency" data-secondary="cross-device" id="idm140417569078640"></a>
Another complication arises when the same user is accessing your service from multiple devices, for
example a desktop web browser and a mobile app. In this case you may want to provide <em>cross-device</em>
read-after-write consistency: if the user enters some information on one device and then views it
on another device, they should see the information they just entered.</p>

<p>In this case, there are some additional issues to consider:</p>

<ul>
<li>
<p>Approaches that require remembering the timestamp of the user’s last update become more difficult,
because the code running on one device doesn’t know what updates have happened on the other
device. This metadata will need to be centralized.</p>
</li>
<li>
<p>If your replicas are distributed across different datacenters, there is no guarantee that
  connections from different devices will be routed to the same datacenter. (For example, if the user’s desktop
  computer uses the home broadband connection and their mobile device uses the cellular data network,
  the devices’ network routes may be completely different.) If your approach requires reading from the
  leader, you may first need to route requests from all of a user’s devices to the same datacenter.
<a data-type="indexterm" data-primary="consistency" data-secondary="read-after-write" data-startref="ix_consreadwrite" id="idm140417569073536"></a></p>
</li>
</ul>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Monotonic Reads"><div class="sect2" id="sec_replication_monotonic_reads">
<h2>Monotonic Reads</h2>

<p><a data-type="indexterm" data-primary="consistency" data-secondary="monotonic reads" id="ix_consmonoread"></a>
<a data-type="indexterm" data-primary="monotonic reads" id="idm140417569068960"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="consistency properties" data-tertiary="monotonic reads" id="idm140417569068128"></a>
Our second example of an anomaly that can occur when reading from asynchronous followers is that it’s
possible for a user to see things <em>moving backward in time</em>.</p>

<p>This can happen if a user makes several reads from different replicas. For example,
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_monotonic_reads">Figure&nbsp;5-4</a> shows user 2345 making the same query twice, first to a follower
with little lag, then to a follower with greater lag. (This scenario is quite likely if the user
refreshes a web page, and each request is routed to a random server.) The first query returns a
comment that was recently added by user 1234, but the second query doesn’t return anything because
the lagging follower has not yet picked up that write. In effect, the second query is observing the
system at an earlier point in time than the first query. This wouldn’t be so bad if the first query
hadn’t returned anything, because user 2345 probably wouldn’t know that user 1234 had recently added
a comment. However, it’s very confusing for user 2345 if they first see user 1234’s comment appear,
and then see it disappear again.</p>

<figure><div id="fig_replication_monotonic_reads" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0504.png" alt="ddia 0504" width="2880" height="1474" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0504.png">
<h6><span class="label">Figure 5-4. </span>A user first reads from a fresh replica, then from a stale replica. Time appears to go backward. To prevent this anomaly, we need monotonic reads.</h6>
</div></figure>

<p><em>Monotonic reads</em> [<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Terry2011vp">23</a>] is a guarantee that this
kind of anomaly does not happen. It’s a lesser guarantee than strong consistency, but a stronger
guarantee than eventual consistency. When you read data, you may see an old value; monotonic reads
only means that if one user makes several reads in sequence, they will not see time go
backward—i.e., they will not read older data after having previously read newer data.</p>

<p>One way of achieving monotonic reads is to make sure that each user always makes their reads from
the same replica (different users can read from different replicas). For example, the replica can be
chosen based on a hash of the user ID, rather than randomly. However, if that replica fails, the
user’s queries will need to be rerouted to another replica.
<a data-type="indexterm" data-primary="consistency" data-secondary="monotonic reads" data-startref="ix_consmonoread" id="idm140417569059248"></a></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Consistent Prefix Reads"><div class="sect2" id="sec_replication_consistent_prefix">
<h2>Consistent Prefix Reads</h2>

<p><a data-type="indexterm" data-primary="causality" data-secondary="violations of" id="idm140417569056304"></a>
<a data-type="indexterm" data-primary="consistency" data-secondary="consistent prefix reads" id="ix_consprefix"></a>
<a data-type="indexterm" data-primary="consistent prefix reads" id="idm140417569053824"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="consistency properties" data-tertiary="consistent prefix reads" id="idm140417569052992"></a>
Our third example of replication lag anomalies concerns violation of causality. Imagine the
following short dialog between Mr. Poons and Mrs. Cake:</p>
<dl>
<dt>Mr. Poons</dt>
<dd>
<p>How far into the future can you see, Mrs. Cake?</p>
</dd>
<dt>Mrs. Cake</dt>
<dd>
<p>About ten seconds usually, Mr. Poons.</p>
</dd>
</dl>

<p>There is a causal dependency between those two sentences: Mrs. Cake heard Mr. Poons’s question and
answered it.</p>

<p>Now, imagine a third person is listening to this conversation through followers. The things said by
Mrs. Cake go through a follower with little lag, but the things said by Mr. Poons have a longer
replication lag (see <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_consistent_prefix">Figure&nbsp;5-5</a>). This observer would hear the following:</p>
<dl>
<dt>Mrs. Cake</dt>
<dd>
<p>About ten seconds usually, Mr. Poons.</p>
</dd>
<dt>Mr. Poons</dt>
<dd>
<p>How far into the future can you see, Mrs. Cake?</p>
</dd>
</dl>

<p>To the observer it looks as though Mrs. Cake is answering the question before Mr. Poons has even asked
it. Such psychic powers are impressive, but very confusing
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Pratchett1991wj-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Pratchett1991wj">25</a>].</p>

<figure><div id="fig_replication_consistent_prefix" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0505.png" alt="ddia 0505" width="2880" height="1843" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0505.png">
<h6><span class="label">Figure 5-5. </span>If some partitions are replicated slower than others, an observer may see the answer before they see the question.</h6>
</div></figure>

<p>Preventing this kind of anomaly requires another type of guarantee: <em>consistent prefix reads</em>
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Terry2011vp">23</a>]. This guarantee says that if a sequence of
writes happens in a certain order, then anyone reading those writes will see them appear in the same
order.</p>

<p>This is a particular problem in partitioned (sharded) databases, which we will discuss in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch06.html#ch_partitioning">Chapter&nbsp;6</a>. If the database always applies writes in the same order, reads always see a
consistent prefix, so this anomaly cannot happen. However, in many distributed databases, different
partitions operate independently, so there is no global ordering of writes: when a user reads from
the database, they may see some parts of the database in an older state and some in a newer state.</p>

<p>One solution is to make sure that any writes that are causally related to each other are written to
the same partition—but in some applications that cannot be done efficiently. There are also
algorithms that explicitly keep track of causal dependencies, a topic that we will return to in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_happens_before">“The “happens-before” relationship and concurrency”</a>.
<a data-type="indexterm" data-primary="consistency" data-secondary="consistent prefix reads" data-startref="ix_consprefix" id="idm140417569033664"></a></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Solutions for Replication Lag"><div class="sect2" id="idm140417569057280">
<h2>Solutions for Replication Lag</h2>

<p>When working with an eventually consistent system, it is worth thinking about how the application
behaves if the replication lag increases to several minutes or even hours. If the answer is “no
problem,” that’s great. However, if the result is a bad experience for users, it’s important to
design the system to provide a stronger guarantee, such as read-after-write. Pretending that
replication is synchronous when in fact it is asynchronous is a recipe for problems down the line.</p>

<p>As discussed earlier, there are ways in which an application can provide a stronger guarantee than
the underlying database—for example, by performing certain kinds of reads on the leader. However,
dealing with these issues in application code is complex and easy to get wrong.</p>

<p>It would be better if application developers didn’t have to worry about subtle replication issues
and could just trust their databases to “do the right thing.” This is why <em>transactions</em> exist: they
are a way for a database to provide stronger guarantees so that the application can be simpler.</p>

<p>Single-node transactions have existed for a long time. However, in the move to distributed
(replicated and partitioned) databases, many systems have abandoned them, claiming that transactions
are too expensive in terms of performance and availability, and asserting that eventual consistency
is inevitable in a scalable system. There is some truth in that statement, but it is overly
simplistic, and we will develop a more nuanced view over the course of the rest of this book. We
will return to the topic of transactions in Chapters
<a data-type="xref" data-xrefstyle="select:labelnumber" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch07.html#ch_transactions" class="totri-footnote">7</a>
and <a data-type="xref" data-xrefstyle="select:labelnumber" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch09.html#ch_consistency" class="totri-footnote">9</a>,
and we will discuss some alternative mechanisms in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/part03.html#part_systems">Part&nbsp;III</a>.
<a data-type="indexterm" data-primary="replication" data-secondary="consistency properties" data-startref="ix_replproblag" id="idm140417569024256"></a></p>
</div></section>





</div></section>













<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Multi-Leader Replication"><div class="sect1" id="sec_replication_multi_leader">
<h1>Multi-Leader Replication</h1>

<p><a data-type="indexterm" data-primary="replication" data-secondary="multi-leader" id="ix_replmultilead"></a>
<a data-type="indexterm" data-primary="multi-leader replication" data-seealso="replication" id="ix_multileadrepl"></a>
<a data-type="indexterm" data-primary="master-master replication" data-see="multi-leader replication" id="idm140417569018256"></a>
<a data-type="indexterm" data-primary="active/active replication" data-see="multi-leader replication" id="idm140417569017120"></a>
So far in this chapter we have only considered replication architectures using a single leader.
Although that is a common approach, there are interesting alternatives.</p>

<p>Leader-based replication has one major downside: there is only one leader, and all writes must go
through it.<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm140417569015280-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417569015280">iv</a></sup> If you can’t connect to the leader for any reason, for example due to a network
interruption between you and the leader, you can’t write to the database.</p>

<p>A natural extension of the leader-based replication model is to allow more than one node to accept
writes. Replication still happens in the same way: each node that processes a write must forward
that data change to all the other nodes. We call this a <em>multi-leader</em> configuration (also known as
<em>master–master</em> or <em>active/active replication</em>). In this setup, each leader simultaneously acts as a
follower to the other leaders.</p>








<section data-type="sect2" data-pdf-bookmark="Use Cases for Multi-Leader Replication"><div class="sect2" id="idm140417569011008">
<h2>Use Cases for Multi-Leader Replication</h2>

<p><a data-type="indexterm" data-primary="multi-leader replication" data-secondary="use cases" id="idm140417569009584"></a>
It rarely makes sense to use a multi-leader setup within a single datacenter, because the benefits
rarely outweigh the added complexity. However, there are some situations in which this configuration
is reasonable.</p>










<section data-type="sect3" data-pdf-bookmark="Multi-datacenter operation"><div class="sect3" id="sec_replication_multi_dc">
<h3>Multi-datacenter operation</h3>

<p><a data-type="indexterm" data-primary="coordination" data-secondary="cross-datacenter" id="idm140417569006240"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="multi-leader" data-tertiary="across multiple datacenters" id="idm140417569005136"></a>
<a data-type="indexterm" data-primary="multi-leader replication" data-secondary="use cases" data-tertiary="multi-datacenter replication" id="idm140417569003696"></a>
<a data-type="indexterm" data-primary="datacenters" data-secondary="replication across multiple" data-tertiary="multi-leader replication" id="idm140417569002288"></a>
Imagine you have a database with replicas in several different datacenters (perhaps so that you can
tolerate failure of an entire datacenter, or perhaps in order to be closer to your users). With a
normal leader-based replication setup, the leader has to be in <em>one</em> of the datacenters, and all
writes must go through that datacenter.</p>

<p>In a multi-leader configuration, you can have a leader in <em>each</em> datacenter.
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_multi_dc">Figure&nbsp;5-6</a> shows what this architecture might look like. Within each datacenter,
regular leader–follower replication is used; between datacenters, each datacenter’s leader
replicates its changes to the leaders in other datacenters.</p>

<figure><div id="fig_replication_multi_dc" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0506.png" alt="ddia 0506" width="2880" height="1401" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0506.png">
<h6><span class="label">Figure 5-6. </span>Multi-leader replication across multiple datacenters.</h6>
</div></figure>

<p><a data-type="indexterm" data-primary="datacenters" data-secondary="replication across multiple" id="idm140417568996032"></a>
<a data-type="indexterm" data-primary="distributed systems" data-secondary="multi-datacenter" id="idm140417568994912"></a>
Let’s compare how the single-leader and multi-leader configurations fare in a multi-datacenter
deployment:</p>
<dl>
<dt>Performance</dt>
<dd>
<p>In a single-leader configuration, every write must go over the internet to the datacenter with the
leader.<a data-type="indexterm" data-primary="performance" data-secondary="of multi-leader replication" id="idm140417568991856"></a> This can add significant latency to
writes and might contravene the purpose of having multiple datacenters in the first place. In a
multi-leader configuration, every write can be processed in the local datacenter and is replicated
asynchronously to the other datacenters. Thus, the inter-datacenter network delay is hidden from
users, which means the perceived performance may be better.</p>
</dd>
<dt>Tolerance of datacenter outages</dt>
<dd>
<p>In a single-leader configuration, if the datacenter with the leader fails, failover can promote a
follower in another datacenter to be leader. In a multi-leader configuration, each datacenter can
continue operating independently of the others, and replication catches up when the failed
datacenter comes back online.</p>
</dd>
<dt>Tolerance of network problems</dt>
<dd>
<p>Traffic between datacenters usually goes over the public internet,
<a data-type="indexterm" data-primary="faults" data-secondary="network faults" data-tertiary="tolerance of, in multi-leader replication" id="idm140417568987472"></a>
<a data-type="indexterm" data-primary="networks" data-secondary="faults" data-see="faults" id="idm140417568986048"></a>
which may be less reliable than the local network within a datacenter. A single-leader
configuration is very sensitive to problems in this inter-datacenter link, because writes are made
synchronously over this link. A multi-leader configuration with asynchronous replication can
usually tolerate network problems better: a temporary network interruption does not prevent writes
being processed.</p>
</dd>
</dl>

<p><a data-type="indexterm" data-primary="MySQL (database)" data-secondary="Tungsten Replicator (multi-leader replication)" id="idm140417568983872"></a>
<a data-type="indexterm" data-primary="PostgreSQL (database)" data-secondary="BDR (multi-leader replication)" id="idm140417568982512"></a>
<a data-type="indexterm" data-primary="Oracle (database)" data-secondary="GoldenGate (change data capture)" id="idm140417568981440"></a>
<a data-type="indexterm" data-primary="GoldenGate (change data capture)" id="idm140417568980320"></a>
Some databases support multi-leader configurations by default, but it is also often implemented with
external tools, such as Tungsten Replicator for MySQL
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="TungstenReplicator-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#TungstenReplicator">26</a>], BDR for PostgreSQL
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="PostgresBDR-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#PostgresBDR">27</a>],
and GoldenGate for Oracle [<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Oracle2013ub">19</a>].</p>

<p>Although multi-leader replication has advantages, it also has a big downside: the same data may be
concurrently modified in two different datacenters, and those write conflicts must be resolved
(indicated as “conflict resolution” in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_multi_dc">Figure&nbsp;5-6</a>). We will discuss this issue in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_write_conflicts">“Handling Write Conflicts”</a>.</p>

<p>As multi-leader replication is a somewhat retrofitted feature in many databases, there are often
subtle configuration pitfalls and surprising interactions with other database features. For example,
autoincrementing keys, triggers, and integrity constraints can be problematic. For this reason,
multi-leader replication is often considered dangerous territory that should be avoided if possible
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Hodges2012ue-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Hodges2012ue">28</a>].</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Clients with offline operation"><div class="sect3" id="sec_replication_offline_clients">
<h3>Clients with offline operation</h3>

<p><a data-type="indexterm" data-primary="multi-leader replication" data-secondary="use cases" data-tertiary="clients with offline operation" id="idm140417568967520"></a>
<a data-type="indexterm" data-primary="clients" data-secondary="stateful and offline-capable" id="idm140417568966064"></a>
<a data-type="indexterm" data-primary="offline systems" data-secondary="stateful, offline-capable clients" id="idm140417568964944"></a>
Another situation in which multi-leader replication is appropriate is if you have an application
that needs to continue to work while it is disconnected from the internet.</p>

<p>For example, consider the calendar apps on your mobile phone, your laptop, and other devices. You
need to be able to see your meetings (make read requests) and enter new meetings (make write
requests) at any time, regardless of whether your device currently has an internet connection. If
you make any changes while you are offline, they need to be synced with a server and your other
devices when the device is next online.</p>

<p><a data-type="indexterm" data-primary="locality (data access)" data-secondary="in stateful clients" id="idm140417568962512"></a>
In this case, every device has a local database that acts as a leader (it accepts write requests),
and there is an asynchronous multi-leader replication process (sync) between the replicas of your
calendar on all of your devices. The replication lag may be hours or even days, depending on when
you have internet access available.</p>

<p>From an architectural point of view, this setup is essentially the same as multi-leader replication
between datacenters, taken to the extreme: each device is a “datacenter,” and the network connection
between them is extremely unreliable. As the rich history of broken calendar sync implementations
demonstrates, multi-leader replication is a tricky thing to get right.</p>

<p><a data-type="indexterm" data-primary="CouchDB (database)" data-secondary="replication" id="idm140417568960000"></a>
There are tools that aim to make this kind of multi-leader configuration easier. For example,
CouchDB is designed for this mode of operation
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Anderson2010wj-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Anderson2010wj">29</a>].</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Collaborative editing"><div class="sect3" id="idm140417568957200">
<h3>Collaborative editing</h3>

<p><a data-type="indexterm" data-primary="real-time" data-secondary="collaborative editing" id="idm140417568955792"></a>
<a data-type="indexterm" data-primary="multi-leader replication" data-secondary="use cases" data-tertiary="collaborative editing" id="idm140417568954464"></a>
<a data-type="indexterm" data-primary="collaborative editing" data-secondary="multi-leader replication and" id="idm140417568953120"></a>
<a data-type="indexterm" data-primary="Etherpad (collaborative editor)" id="idm140417568952000"></a>
<a data-type="indexterm" data-primary="Google" data-secondary="Docs (collaborative editor)" id="idm140417568951152"></a>
<em>Real-time collaborative editing</em> applications allow several people to edit a document
simultaneously. For example, Etherpad [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="AppJetInc2011um-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#AppJetInc2011um">30</a>]
and Google Docs [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="DayRichter2010tt-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#DayRichter2010tt">31</a>] allow multiple people to concurrently edit a text document or spreadsheet
(the algorithm is briefly discussed in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sidebar_conflict_resolution">“Automatic Conflict Resolution”</a>).</p>

<p>We don’t usually think of collaborative editing as a database replication problem, but it has a lot
in common with the previously mentioned offline editing use case. When one user edits a document,
the changes are instantly applied to their local replica (the state of the document in their web
browser or client application) and asynchronously replicated to the server and any other users who
are editing the same document.</p>

<p>If you want to guarantee that there will be no editing conflicts, the application must obtain a lock
on the document before a user can edit it. If another user wants to edit the same document, they
first have to wait until the first user has committed their changes and released the lock. This
collaboration model is equivalent to single-leader replication with transactions on the leader.</p>

<p>However, for faster collaboration, you may want to make the unit of change very small (e.g., a single
keystroke) and avoid locking. This approach allows multiple users to edit simultaneously, but it also brings
all the challenges of multi-leader replication, including requiring conflict resolution
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Kleppmann2016ve-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Kleppmann2016ve">32</a>].</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Handling Write Conflicts"><div class="sect2" id="sec_replication_write_conflicts">
<h2>Handling Write Conflicts</h2>

<p><a data-type="indexterm" data-primary="concurrency" data-secondary="conflict resolution" id="idm140417568938128"></a>
<a data-type="indexterm" data-primary="conflicts" data-secondary="in multi-leader replication" id="ix_conflictwrmultilead"></a>
<a data-type="indexterm" data-primary="multi-leader replication" data-secondary="handling write conflicts" id="idm140417568935584"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="multi-leader" data-tertiary="handling write conflicts" id="ix_replmultileadwrconf"></a>
The biggest problem with multi-leader replication is that write conflicts can occur, which means
that conflict resolution is required.</p>

<p>For example, consider a wiki page that is simultaneously being edited by two users, as shown in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_write_conflict">Figure&nbsp;5-7</a>. User 1 changes the title of the page from A to B, and user 2
changes the title from A to C at the same time. Each user’s change is successfully applied to their
local leader. However, when the changes are asynchronously replicated, a conflict is detected
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Clement2011wc-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Clement2011wc">33</a>].
This problem does not occur in a single-leader database.</p>

<figure class="width-75"><div id="fig_replication_write_conflict" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0507.png" alt="ddia 0507" width="2880" height="1488" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0507.png">
<h6><span class="label">Figure 5-7. </span>A write conflict caused by two leaders concurrently updating the same record.</h6>
</div></figure>










<section data-type="sect3" data-pdf-bookmark="Synchronous versus asynchronous conflict detection"><div class="sect3" id="idm140417568926416">
<h3>Synchronous versus asynchronous conflict detection</h3>

<p><a data-type="indexterm" data-primary="synchronous replication" data-secondary="conflict detection" id="idm140417568925184"></a>
<a data-type="indexterm" data-primary="asynchronous replication" data-secondary="conflict detection" id="idm140417568924080"></a>
<a data-type="indexterm" data-primary="conflicts" data-secondary="conflict detection" id="idm140417568922960"></a>
In a single-leader database, the second writer will either block and wait for the first write to
complete, or abort the second write transaction, forcing the user to retry the write. On the other
hand, in a multi-leader setup, both writes are successful, and the conflict is only detected
asynchronously at some later point in time. At that time, it may be too late to ask the user to
resolve the conflict.</p>

<p>In principle, you could make the conflict detection synchronous—i.e., wait for the write to be
replicated to all replicas before telling the user that the write was successful. However, by doing
so, you would lose the main advantage of multi-leader replication: allowing each replica to accept
writes independently. If you want synchronous conflict detection, you might as well just use
single-leader replication.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Conflict avoidance"><div class="sect3" id="idm140417568920368">
<h3>Conflict avoidance</h3>

<p><a data-type="indexterm" data-primary="conflicts" data-secondary="in multi-leader replication" data-tertiary="avoiding conflicts" id="idm140417568919168"></a>
<a data-type="indexterm" data-primary="multi-leader replication" data-secondary="handling write conflicts" data-tertiary="conflict avoidance" id="idm140417568917776"></a>
The simplest strategy for dealing with conflicts is to avoid them: if the application can ensure
that all writes for a particular record go through the same leader, then conflicts cannot occur.
Since many implementations of multi-leader replication handle conflicts quite poorly, avoiding
conflicts is a frequently recommended approach
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Hodges2013vb-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Hodges2013vb">34</a>].</p>

<p>For example, in an application where a user can edit their own data, you can ensure that requests
from a particular user are always routed to the same datacenter and use the leader in that
datacenter for reading and writing. Different users may have different “home” datacenters (perhaps
picked based on geographic proximity to the user), but from any one user’s point of view the
configuration is essentially single-leader.</p>

<p>However, sometimes you might want to change the designated leader for a record—perhaps because
one datacenter has failed and you need to reroute traffic to another datacenter, or perhaps because
a user has moved to a different location and is now closer to a different datacenter. In this
situation, conflict avoidance breaks down, and you have to deal with the possibility of concurrent
writes on different leaders.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Converging toward a consistent state"><div class="sect3" id="idm140417568911536">
<h3>Converging toward a consistent state</h3>

<p><a data-type="indexterm" data-primary="conflicts" data-secondary="conflict resolution" data-tertiary="convergence" id="ix_confconverg"></a>
<a data-type="indexterm" data-primary="convergence (conflict resolution)" id="ix_convergence"></a>
<a data-type="indexterm" data-primary="multi-leader replication" data-secondary="handling write conflicts" data-tertiary="converging toward a consistent state" id="idm140417568907424"></a>
A single-leader database applies writes in a sequential order: if there are several updates to the
same field, the last write determines the final value of the field.</p>

<p>In a multi-leader configuration, there is no defined ordering of writes, so it’s not clear what the
final value should be. In <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_write_conflict">Figure&nbsp;5-7</a>, at leader 1 the title is first updated
to B and then to C; at leader 2 it is first updated to C and then to B. Neither order is “more
correct” than the other.</p>

<p>If each replica simply applied writes in the order that it saw the writes, the database would end up
in an inconsistent state: the final value would be C at leader 1 and B at leader 2. That is not
acceptable—every replication scheme must ensure that the data is eventually the same in all
replicas. Thus, the database must resolve the conflict in a <em>convergent</em> way, which means that all
replicas must arrive at the same final value when all changes have been replicated.</p>

<p>There are various ways of achieving convergent conflict resolution:</p>

<ul>
<li>
<p><a data-type="indexterm" data-primary="winners (conflict resolution)" id="idm140417568901552"></a>
<a data-type="indexterm" data-primary="last write wins (LWW)" id="idm140417568900528"></a>
<a data-type="indexterm" data-primary="incidents" data-secondary="data loss due to last-write-wins" id="idm140417568899696"></a>
Give each write a unique ID (e.g., a timestamp, a long random number, a UUID, or a hash of the key
and value), pick the write with the highest ID as the <em>winner</em>, and throw away the other writes.
If a timestamp is used, this technique is known as <em>last write wins</em> (LWW). Although this approach
is popular, it is dangerously prone to data loss
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Daily2013te_ch5-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Daily2013te_ch5">35</a>].
We will discuss LWW in more detail at the end of this chapter (<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_concurrent">“Detecting Concurrent Writes”</a>).</p>
</li>
<li>
<p>Give each replica a unique ID, and let writes that originated at a higher-numbered replica
always take precedence over writes that originated at a lower-numbered replica. This approach also implies
data loss.</p>
</li>
<li>
<p>Somehow merge the values together—e.g., order them alphabetically and then concatenate them (in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_write_conflict">Figure&nbsp;5-7</a>, the merged title might be something like <span class="keep-together">“B/C”).</span></p>
</li>
<li>
<p>Record the conflict in an explicit data structure that preserves all information, and write
application code that resolves the conflict at some later time (perhaps by prompting the user).</p>
</li>
</ul>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Custom conflict resolution logic"><div class="sect3" id="idm140417568889456">
<h3>Custom conflict resolution logic</h3>

<p><a data-type="indexterm" data-primary="multi-leader replication" data-secondary="handling write conflicts" data-tertiary="custom conflict resolution logic" id="idm140417568888048"></a>
<a data-type="indexterm" data-primary="conflicts" data-secondary="conflict resolution" data-tertiary="using custom logic" id="idm140417568886624"></a>
As the most appropriate way of resolving a conflict may depend on the application, most multi-leader
replication tools let you write conflict resolution logic using application code. That code may be
executed on write or on read:</p>
<dl>
<dt>On write</dt>
<dd>
<p><a data-type="indexterm" data-primary="PostgreSQL (database)" data-secondary="Bucardo (trigger-based replication)" id="idm140417568883664"></a>
As soon as the database system detects a conflict in the log of replicated changes, it calls the
conflict handler. For example, Bucardo allows you to write a snippet of Perl for this purpose.
This handler typically cannot prompt a user—it runs in a background process and it must execute
quickly.</p>
</dd>
<dt>On read</dt>
<dd>
<p><a data-type="indexterm" data-primary="CouchDB (database)" data-secondary="replication" id="idm140417568881072"></a>
When a conflict is detected, all the conflicting writes are stored. The next time the data is
read, these multiple versions of the data are returned to the application. The application may
prompt the user or automatically resolve the conflict, and write the result back to the database.
CouchDB works this way, for example.</p>
</dd>
</dl>

<p class="pagebreak-after">Note that conflict resolution usually applies at the level of an individual row or document, not for
an entire transaction [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Berton2016wh-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Berton2016wh">36</a>].
Thus, if you have a transaction that atomically makes several different writes (see
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch07.html#ch_transactions">Chapter&nbsp;7</a>), each write is still considered separately for the purposes of conflict resolution.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_conflict_resolution">
<h5>Automatic Conflict Resolution</h5>
<p><a data-type="indexterm" data-primary="concurrency" data-secondary="conflict resolution" id="idm140417568873696"></a>
<a data-type="indexterm" data-primary="conflicts" data-secondary="conflict resolution" data-tertiary="automatic conflict resolution" id="idm140417568872592"></a>
<a data-type="indexterm" data-primary="incidents" data-secondary="deleted items reappearing" id="idm140417568871152"></a>
Conflict resolution rules can quickly become complicated, and custom code can be error-prone. Amazon
is a frequently cited example of surprising effects due to a conflict resolution handler: for some
time, the conflict resolution logic on the shopping cart would preserve items added to the cart, but
not items removed from the cart. Thus, customers would sometimes see items reappearing in their
carts even though they had previously been removed
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="DeCandia2007ui_ch5-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#DeCandia2007ui_ch5">37</a>].</p>

<p>There has been some interesting research into automatically resolving conflicts caused by concurrent
data modifications. A few lines of research are worth mentioning:</p>

<ul>
<li>
<p><a data-type="indexterm" data-primary="conflict-free replicated datatypes (CRDTs)" id="idm140417568865792"></a>
<a data-type="indexterm" data-primary="CRDTs" data-see="conflict-free replicated datatypes" id="idm140417568864640"></a>
<a data-type="indexterm" data-primary="Riak (database)" data-secondary="CRDTs" id="idm140417568863568"></a>
<a data-type="indexterm" data-primary="datatypes" data-secondary="conflict-free" id="idm140417568862464"></a>
<em>Conflict-free replicated datatypes</em> (CRDTs)
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Kleppmann2016ve">32</a>,
<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Shapiro2011wy-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Shapiro2011wy">38</a>] are a family of data structures for sets, maps, ordered lists, counters,
etc. that can be concurrently edited by multiple users, and which automatically resolve conflicts
in sensible ways. Some CRDTs have been implemented in Riak 2.0
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Elliott2013ua-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Elliott2013ua">39</a>,
<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Brown2013wy-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Brown2013wy">40</a>].</p>
</li>
<li>
<p><a data-type="indexterm" data-primary="mergeable persistent data structures" id="idm140417568852880"></a>
<a data-type="indexterm" data-primary="Git (version control system)" id="idm140417568852032"></a>
<em>Mergeable persistent data structures</em>
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Farinier2015wj-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Farinier2015wj">41</a>] track history explicitly, similarly to the Git version control
system, and use a three-way merge function (whereas CRDTs use two-way merges).</p>
</li>
<li>
<p><a data-type="indexterm" data-primary="operational transformation" id="idm140417568847600"></a>
<em>Operational transformation</em>
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Sun1998vf-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Sun1998vf">42</a>]
is the conflict resolution algorithm behind collaborative editing applications such as Etherpad
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#AppJetInc2011um">30</a>] and Google Docs
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#DayRichter2010tt">31</a>]. It was designed particularly for
concurrent editing of an ordered list of items, such as the list of characters that constitute a
text document.</p>
</li>
</ul>

<p>Implementations of these algorithms in databases are still young, but it’s likely that they will be
integrated into more replicated data systems in the future. Automatic conflict resolution could make
multi-leader data synchronization much simpler for applications to deal with.
<a data-type="indexterm" data-primary="conflicts" data-secondary="conflict resolution" data-tertiary="convergence" data-startref="ix_confconverg" id="idm140417568841088"></a>
<a data-type="indexterm" data-primary="convergence (conflict resolution)" data-startref="ix_convergence" id="idm140417568839440"></a></p>
</div></aside>
</div></section>













<section data-type="sect3" data-pdf-bookmark="What is a conflict?"><div class="sect3" id="sec_replication_what_is_conflict">
<h3>What is a conflict?</h3>

<p><a data-type="indexterm" data-primary="multi-leader replication" data-secondary="handling write conflicts" data-tertiary="determining what is a conflict" id="idm140417568836688"></a>
<a data-type="indexterm" data-primary="conflicts" data-secondary="determining what is a conflict" id="idm140417568835312"></a>
Some kinds of conflict are obvious. In the example in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_write_conflict">Figure&nbsp;5-7</a>, two writes
concurrently modified the same field in the same record, setting it to two different values. There
is little doubt that this is a conflict.</p>

<p>Other kinds of conflict can be more subtle to detect. For example, consider a meeting room booking
system: it tracks which room is booked by which group of people at which time. This application
needs to ensure that each room is only booked by one group of people at any one time (i.e., there
must not be any overlapping bookings for the same room). In this case, a conflict may arise if two
different bookings are created for the same room at the same time. Even if the application checks
availability before allowing a user to make a booking, there can be a conflict if the two bookings
are made on two different leaders.</p>

<p>There isn’t a quick ready-made answer, but in the following chapters we will trace a path toward a
good understanding of this problem. We will see some more examples of conflicts in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch07.html#ch_transactions">Chapter&nbsp;7</a>, and in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch12.html#ch_future">Chapter&nbsp;12</a> we will discuss scalable approaches for detecting and
resolving conflicts in a replicated system.
<a data-type="indexterm" data-primary="replication" data-secondary="multi-leader" data-tertiary="handling write conflicts" data-startref="ix_replmultileadwrconf" id="idm140417568829712"></a>
<a data-type="indexterm" data-primary="conflicts" data-secondary="in multi-leader replication" data-startref="ix_conflictwrmultilead" id="idm140417568828080"></a></p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Multi-Leader Replication Topologies"><div class="sect2" id="sec_replication_topologies">
<h2>Multi-Leader Replication Topologies</h2>

<p><a data-type="indexterm" data-primary="multi-leader replication" data-secondary="replication topologies" id="ix_multileadrepltopol"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="multi-leader" data-tertiary="replication topologies" id="ix_replmultileadtopol"></a>
A <em>replication topology</em> describes the communication paths along which writes are propagated from
one node to another. If you have two leaders, like in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_write_conflict">Figure&nbsp;5-7</a>, there is
only one plausible topology: leader 1 must send all of its writes to leader 2, and vice versa. With
more than two leaders, various different topologies are possible. Some examples are illustrated in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_topologies">Figure&nbsp;5-8</a>.</p>

<figure><div id="fig_replication_topologies" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0508.png" alt="ddia 0508" width="2880" height="800" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0508.png">
<h6><span class="label">Figure 5-8. </span>Three example topologies in which multi-leader replication can be set up.</h6>
</div></figure>

<p><a data-type="indexterm" data-primary="all-to-all replication topologies" id="idm140417568817344"></a>
<a data-type="indexterm" data-primary="circular replication topologies" id="idm140417568816384"></a>
<a data-type="indexterm" data-primary="star replication topologies" id="idm140417568815536"></a>
<a data-type="indexterm" data-primary="MySQL (database)" data-secondary="circular replication topology" id="idm140417568814688"></a>
The most general topology is <em>all-to-all</em> (<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_topologies">Figure&nbsp;5-8</a> [c]), in which every
leader sends its writes to every other leader. However, more restricted topologies are also used:
for example, MySQL by default supports only a <em>circular topology</em>
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Hodges2013vb">34</a>],
in which each node receives writes from one node and forwards those writes (plus any writes of its
own) to one other node. Another popular topology has the shape of a
<em>star</em>:<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm140417568810256-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417568810256" class="totri-footnote">v</a></sup> one
designated root node forwards writes to all of the other nodes. The star topology can be generalized
to a tree.</p>

<p>In circular and star topologies, a write may need to pass through several nodes before it reaches
all replicas. Therefore, nodes need to forward data changes they receive from other nodes. To
prevent infinite replication loops, each node is given a unique identifier, and in the replication
log, each write is tagged with the identifiers of all the nodes it has passed through
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="HBase7709-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#HBase7709">43</a>].
When a node receives a data change that is tagged with its own identifier, that data change is
ignored, because the node knows that it has already been processed.</p>

<p>A problem with circular and star topologies is that if just one node fails, it can interrupt the
flow of replication messages between other nodes, causing them to be unable to communicate until the
node is fixed. The topology could be reconfigured to work around the failed node, but in most
deployments such reconfiguration would have to be done manually. The fault tolerance of a more
densely connected topology (such as all-to-all) is better because it allows messages to travel
along different paths, avoiding a single point of failure.</p>

<p>On the other hand, all-to-all topologies can have issues too. In particular, some network links may
be faster than others (e.g., due to network congestion), with the result that some replication
messages may “overtake” others, as illustrated in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_causality">Figure&nbsp;5-9</a>.</p>

<figure><div id="fig_replication_causality" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0509.png" alt="ddia 0509" width="2880" height="1602" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0509.png">
<h6><span class="label">Figure 5-9. </span>With multi-leader replication, writes may arrive in the wrong order at some replicas.</h6>
</div></figure>

<p>In <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_causality">Figure&nbsp;5-9</a>, client A inserts a row into a table on leader 1, and client B
updates that row on leader 3. However, leader 2 may receive the writes in a different order: it may
first receive the update (which, from its point of view, is an update to a row that does not exist
in the database) and only later receive the corresponding insert (which should have preceded the
update).</p>

<p><a data-type="indexterm" data-primary="causality" data-secondary="violations of" id="idm140417568798288"></a>
<a data-type="indexterm" data-primary="correctness" data-secondary="of time" id="idm140417568797184"></a>
This is a problem of causality, similar to the one we saw in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_consistent_prefix">“Consistent Prefix Reads”</a>:
the update depends on the prior insert, so we need to make sure that all nodes process the insert
first, and then the update. Simply attaching a timestamp to every write is not sufficient, because
clocks cannot be trusted to be sufficiently in sync to correctly order these events at leader 2 (see
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch08.html#ch_distributed">Chapter&nbsp;8</a>).</p>

<p><a data-type="indexterm" data-primary="version vectors" id="idm140417568793776"></a>
<a data-type="indexterm" data-primary="MySQL (database)" data-secondary="Tungsten Replicator (multi-leader replication)" data-tertiary="conflict detection" id="idm140417568792720"></a>
<a data-type="indexterm" data-primary="PostgreSQL (database)" data-secondary="BDR (multi-leader replication)" data-tertiary="causal ordering of writes" id="idm140417568791312"></a>
To order these events correctly, a technique called <em>version vectors</em> can be used, which we will
discuss later in this chapter (see <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_concurrent">“Detecting Concurrent Writes”</a>). However, conflict detection
techniques are poorly implemented in many multi-leader replication systems. For example, at the time
of writing, PostgreSQL BDR does not provide causal ordering of writes
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#PostgresBDR">27</a>],
and Tungsten Replicator for MySQL doesn’t even try to detect conflicts
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Hodges2013vb">34</a>].</p>

<p>If you are using a system with multi-leader replication, it is worth being aware of these issues,
carefully reading the documentation, and thoroughly testing your database to ensure that it really
does provide the guarantees you believe it to have.
<a data-type="indexterm" data-primary="multi-leader replication" data-secondary="replication topologies" data-startref="ix_multileadrepltopol" id="idm140417568786256"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="multi-leader" data-tertiary="replication topologies" data-startref="ix_replmultileadtopol" id="idm140417568784912"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="multi-leader" data-startref="ix_replmultilead" id="idm140417568783264"></a>
<a data-type="indexterm" data-primary="multi-leader replication" data-startref="ix_multileadrepl" id="idm140417568781888"></a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Leaderless Replication"><div class="sect1" id="sec_replication_leaderless">
<h1>Leaderless Replication</h1>

<p><a data-type="indexterm" data-primary="replication" data-secondary="leaderless" id="ix_replnolead"></a>
<a data-type="indexterm" data-primary="leaderless replication" data-seealso="replication" id="ix_noleadrepl"></a>
The replication approaches we have discussed so far in this chapter—single-leader and
multi-leader replication—are based on the idea that a client sends a write request to one node
(the leader), and the database system takes care of copying that write to the other replicas. A
leader determines the order in which writes should be processed, and followers apply the leader’s
writes in the same order.</p>

<p><a data-type="indexterm" data-primary="Amazon" data-secondary="Dynamo (database)" id="idm140417568775824"></a>
<a data-type="indexterm" data-primary="Dynamo-style databases" data-see="leaderless replication" id="idm140417568774320"></a>
<a data-type="indexterm" data-primary="Cassandra (database)" data-secondary="leaderless replication" id="idm140417568773216"></a>
<a data-type="indexterm" data-primary="Riak (database)" data-secondary="leaderless replication" id="idm140417568772112"></a>
<a data-type="indexterm" data-primary="Voldemort (database)" data-secondary="leaderless replication" id="idm140417568771008"></a>
<a data-type="indexterm" data-primary="LinkedIn" data-secondary="Voldemort (database)" data-see="Voldemort" id="idm140417568769904"></a>
Some data storage systems take a different approach, abandoning the concept of a leader and
allowing any replica to directly accept writes from clients. Some of the earliest replicated data
systems were leaderless [<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Lindsay1979wv_ch5" class="totri-footnote">1</a>,
<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Gifford1979if-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Gifford1979if">44</a>], but the
idea was mostly forgotten during the era of dominance of relational databases. It once again became
a fashionable architecture for databases after Amazon used it for its in-house <em>Dynamo</em> system
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#DeCandia2007ui_ch5">37</a>].<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm140417568763264-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417568763264">vi</a></sup>
Riak, Cassandra, and Voldemort are open source datastores with leaderless replication models inspired
by Dynamo, so this kind of database is also known as <em>Dynamo-style</em>.</p>

<p>In some leaderless implementations, the client directly sends its writes to several replicas, while
in others, a coordinator node does this on behalf of the client. However, unlike a leader database,
that coordinator does not enforce a particular ordering of writes. As we shall see, this difference in design has
profound consequences for the way the database is used.</p>








<section data-type="sect2" data-pdf-bookmark="Writing to the Database When a Node Is Down"><div class="sect2" id="idm140417568760448">
<h2>Writing to the Database When a Node Is Down</h2>

<p>Imagine you have a database with three replicas, and one of the replicas is currently
unavailable—perhaps it is being rebooted to install a system update. In a leader-based
configuration, if you want to continue processing writes, you may need to perform a failover (see
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_failover">“Handling Node Outages”</a>).</p>

<p><a data-type="indexterm" data-primary="failover" data-secondary="in leaderless replication, absence of" id="idm140417568757440"></a>
On the other hand, in a leaderless configuration, failover does not exist.
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_quorum_node_outage">Figure&nbsp;5-10</a> shows what happens: the client (user 1234) sends the write to
all three replicas in parallel, and the two available replicas accept the write but the unavailable
replica misses it. Let’s say that it’s sufficient for two out of three replicas to
acknowledge the write: after user 1234 has received two <em>ok</em> responses, we consider the write to be
successful. The client simply ignores the fact that one of the replicas missed the write.</p>

<figure><div id="fig_replication_quorum_node_outage" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0510.png" alt="ddia 0510" width="2880" height="1572" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0510.png">
<h6><span class="label">Figure 5-10. </span>A quorum write, quorum read, and read repair after a node outage.</h6>
</div></figure>

<p><a data-type="indexterm" data-primary="staleness (old data)" data-secondary="in leaderless databases" id="idm140417568752288"></a>
Now imagine that the unavailable node comes back online, and clients start reading from it. Any
writes that happened while the node was down are missing from that node. Thus, if you read from that
node, you may get <em>stale</em> (outdated) values as responses.</p>

<p>To solve that problem, when a client reads from the database, it doesn’t just send its request to
one replica: <em>read requests are also sent to several nodes in parallel</em>. The client may get
different responses from different nodes; i.e., the up-to-date value from one node and a stale value
from another. Version numbers are used to determine which value is newer (see
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_concurrent">“Detecting Concurrent Writes”</a>).</p>










<section data-type="sect3" data-pdf-bookmark="Read repair and anti-entropy"><div class="sect3" id="sec_replication_read_repair">
<h3>Read repair and anti-entropy</h3>

<p><a data-type="indexterm" data-primary="anti-entropy" id="idm140417568746608"></a>
<a data-type="indexterm" data-primary="read repair (leaderless replication)" id="idm140417568745776"></a>
<a data-type="indexterm" data-primary="leaderless replication" data-secondary="read repair and anti-entropy" id="idm140417568744880"></a>
The replication scheme should ensure that eventually all the data is copied to every replica. After
an unavailable node comes back online, how does it catch up on the writes that it missed?</p>

<p>Two mechanisms are often used in Dynamo-style datastores:</p>
<dl>
<dt>Read repair</dt>
<dd>
<p>When a client makes a read from several nodes in parallel, it can detect any stale responses.
For example, in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_quorum_node_outage">Figure&nbsp;5-10</a>, user 2345 gets a version 6 value from
replica 3 and a version 7 value from replicas 1 and 2. The client sees that replica 3 has a stale
value and writes the newer value back to that replica. This approach works well for values that are
frequently read.</p>
</dd>
<dt>Anti-entropy process</dt>
<dd>
<p>In addition, some datastores have a background process that constantly looks for differences in
the data between replicas and copies any missing data from one replica to another. Unlike the
replication log in leader-based replication, this <em>anti-entropy process</em> does not copy writes in
any particular order, and there may be a significant delay before data is copied.</p>
</dd>
</dl>

<p><a data-type="indexterm" data-primary="Voldemort (database)" data-secondary="reliance on read repair" id="idm140417568737520"></a>
Not all systems implement both of these; for example, Voldemort currently does not have an
anti-entropy process. Note that without an anti-entropy process, values that are rarely read may be
missing from some replicas and thus have reduced durability, because read repair is only performed
when a value is read by the application.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Quorums for reading and writing"><div class="sect3" id="sec_replication_quorum_condition">
<h3>Quorums for reading and writing</h3>

<p><a data-type="indexterm" data-primary="leaderless replication" data-secondary="quorums" id="ix_leaderlessquorums"></a>
<a data-type="indexterm" data-primary="quorums" id="ix_replquorums"></a>
In the example of <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_quorum_node_outage">Figure&nbsp;5-10</a>, we considered the write to be successful
even though it was only processed on two out of three replicas. What if only one out of three
replicas accepted the write? How far can we push this?</p>

<p>If we know that every successful write is guaranteed to be present on at least two out of three
replicas, that means at most one replica can be stale. Thus, if we read from at least two replicas,
we can be sure that at least one of the two is up to date. If the third replica is down or slow to
respond, reads can nevertheless continue returning an up-to-date value.</p>

<p><a data-type="indexterm" data-primary="quorums" data-secondary="for leaderless replication" id="idm140417568729584"></a>
More generally, if there are <em>n</em> replicas, every write must be confirmed by <em>w</em> nodes to be
considered successful, and we must query at least <em>r</em> nodes for each read. (In our example,
<em>n</em>&nbsp;=&nbsp;3, <em>w</em>&nbsp;=&nbsp;2, <em>r</em>&nbsp;=&nbsp;2.) As long as <em>w</em>&nbsp;+&nbsp;<em>r</em> &gt;
<em>n</em>, we expect to get an up-to-date value when reading, because at least one of the <em>r</em> nodes we’re
reading from must be up to date. Reads and writes that obey these <em>r</em> and <em>w</em> values are called
<em>quorum</em> reads and writes
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Gifford1979if">44</a>].<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm140417568721472-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417568721472">vii</a></sup>
You can think of <em>r</em> and <em>w</em> as the minimum number of votes required for the read or write to be
valid.</p>

<p>In Dynamo-style databases, the parameters <em>n</em>, <em>w</em>, and <em>r</em> are typically configurable. A common
choice is to make <em>n</em> an odd number (typically 3 or 5) and to set <em>w</em> = <em>r</em> =
(<em>n</em>&nbsp;+&nbsp;1)&nbsp;/&nbsp;2 (rounded up). However, you can vary the numbers as you see fit.
For example, a workload with few writes and many reads may benefit from setting <em>w</em> = <em>n</em> and
<em>r</em> = 1. This makes reads faster, but has the disadvantage that just one failed node causes all
database writes to fail.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There may be more than <em>n</em> nodes in the cluster, but any given value is stored only on <em>n</em>
nodes. This allows the dataset to be partitioned, supporting datasets that are larger than you can fit
on one node. We will return to partitioning in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch06.html#ch_partitioning">Chapter&nbsp;6</a>.</p>
</div>

<p>The quorum condition, <em>w</em>&nbsp;+&nbsp;<em>r</em> &gt; <em>n</em>, allows the system to tolerate unavailable nodes
as follows:</p>

<ul>
<li>
<p>If <em>w</em>&nbsp;&lt;&nbsp;<em>n</em>, we can still process writes if a node is unavailable.</p>
</li>
<li>
<p>If <em>r</em>&nbsp;&lt;&nbsp;<em>n</em>, we can still process reads if a node is unavailable.</p>
</li>
<li>
<p>With <em>n</em>&nbsp;=&nbsp;3, <em>w</em>&nbsp;=&nbsp;2, <em>r</em>&nbsp;=&nbsp;2 we can tolerate one unavailable node.</p>
</li>
<li>
<p>With <em>n</em>&nbsp;=&nbsp;5, <em>w</em>&nbsp;=&nbsp;3, <em>r</em>&nbsp;=&nbsp;3 we can tolerate two unavailable nodes.
This case is illustrated in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_quorum_overlap">Figure&nbsp;5-11</a>.</p>
</li>
<li>
<p>Normally, reads and writes are always sent to all <em>n</em> replicas in parallel. The parameters <em>w</em> and
<em>r</em> determine how many nodes we wait for—i.e., how many of the <em>n</em> nodes need to report success
before we consider the read or write to be successful.</p>
</li>
</ul>

<figure><div id="fig_replication_quorum_overlap" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0511.png" alt="ddia 0511" width="2880" height="1226" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0511.png">
<h6><span class="label">Figure 5-11. </span>If <em>w</em>&nbsp;+&nbsp;<em>r</em> &gt; <em>n</em>, at least one of the <em>r</em> replicas you read from must have seen the most recent successful write.</h6>
</div></figure>

<p>If fewer than the required <em>w</em> or <em>r</em> nodes are available, writes or reads return an error. A node
could be unavailable for many reasons: because the node is down (crashed, powered down), due to an
error executing the operation (can’t write because the disk is full), due to a network interruption
between the client and the node, or for any number of other reasons. We only care whether the node
returned a successful response and don’t need to distinguish between different kinds of fault.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Limitations of Quorum Consistency"><div class="sect2" id="sec_replication_quorum_limitations">
<h2>Limitations of Quorum Consistency</h2>

<p><a data-type="indexterm" data-primary="consistency" data-secondary="using quorums" id="idm140417568688064"></a>
<a data-type="indexterm" data-primary="leaderless replication" data-secondary="quorums" data-tertiary="consistency limitations" id="ix_noleadrepllimit"></a>
<a data-type="indexterm" data-primary="quorums" data-secondary="limitations of consistency" id="ix_quorumlimit"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="leaderless" data-tertiary="limitations of quorum consistency" id="ix_replnoleadlimits"></a>
If you have <em>n</em> replicas, and you choose <em>w</em> and <em>r</em> such that <em>w</em>&nbsp;+&nbsp;<em>r</em> &gt; <em>n</em>, you can
generally expect every read to return the most recent value written for a key. This is the case because the
set of nodes to which you’ve written and the set of nodes from which you’ve read must overlap. That
is, among the nodes you read there must be at least one node with the latest value (illustrated in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_quorum_overlap">Figure&nbsp;5-11</a>).</p>

<p>Often, <em>r</em> and <em>w</em> are chosen to be a majority (more than <em>n</em>/2) of nodes, because that ensures
<em>w</em>&nbsp;+&nbsp;<em>r</em> &gt; <em>n</em> while still tolerating up to <em>n</em>/2 node failures. But quorums are
not necessarily majorities—it only matters that the sets of nodes used by the read and write
operations overlap in at least one node. Other quorum assignments are possible, which allows some
flexibility in the design of distributed algorithms
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Howard2016tz_ch5-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Howard2016tz_ch5">45</a>].</p>

<p>You may also set <em>w</em> and <em>r</em> to smaller numbers, so that <em>w</em>&nbsp;+&nbsp;<em>r</em> ≤ <em>n</em> (i.e.,
the quorum condition is not satisfied). In this case, reads and writes will still be sent to <em>n</em>
nodes, but a smaller number of successful responses is required for the operation to succeed.</p>

<p>With a smaller <em>w</em> and <em>r</em> you are more likely to read stale values, because it’s more likely that
your read didn’t include the node with the latest value. On the upside, this configuration allows
lower latency and higher availability: if there is a network interruption and many replicas become
unreachable, there’s a higher chance that you can continue processing reads and writes. Only after
the number of reachable replicas falls below <em>w</em> or <em>r</em> does the database become unavailable for
writing or reading, respectively.</p>

<p>However, even with <em>w</em>&nbsp;+&nbsp;<em>r</em> &gt; <em>n</em>, there are likely to be edge cases where stale
values are returned. These depend on the implementation, but possible scenarios include:</p>

<ul>
<li>
<p>If a sloppy quorum is used (see <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_sloppy_quorum">“Sloppy Quorums and Hinted Handoff”</a>), the <em>w</em> writes may end up on
different nodes than the <em>r</em> reads, so there is no longer a guaranteed overlap between the <em>r</em>
nodes and the <em>w</em> nodes [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Blomstedt2012vf-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Blomstedt2012vf">46</a>].</p>
</li>
<li>
<p>If two writes occur concurrently, it is not clear which one happened first. In this case, the only
safe solution is to merge the concurrent writes (see <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_write_conflicts">“Handling Write Conflicts”</a>). If a
winner is picked based on a timestamp (last write wins), writes can be lost due to clock skew
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Daily2013te_ch5">35</a>]. We will return to this topic in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_concurrent">“Detecting Concurrent Writes”</a>.</p>
</li>
<li>
<p>If a write happens concurrently with a read, the write may be reflected on only some of the
replicas. In this case, it’s undetermined whether the read returns the old or the new value.</p>
</li>
<li>
<p>If a write succeeded on some replicas but failed on others (for example because the disks on some
nodes are full), and overall succeeded on fewer than <em>w</em> replicas, it is not rolled back on the
replicas where it succeeded. This means that if a write was reported as failed, subsequent reads
may or may not return the value from that write
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Blomstedt2012vi-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Blomstedt2012vi">47</a>].</p>
</li>
<li>
<p>If a node carrying a new value fails, and its data is restored from a replica carrying an old
value, the number of replicas storing the new value may fall below <em>w</em>, breaking the quorum
condition.</p>
</li>
<li>
<p>Even if everything is working correctly, there are edge cases in which you can get unlucky with
the timing, as we shall see in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch09.html#sec_consistency_quorum_linearizable">“Linearizability and quorums”</a>.</p>
</li>
</ul>

<p>Thus, although quorums appear to guarantee that a read returns the latest written value, in practice
it is not so simple. Dynamo-style databases are generally optimized for use cases that can tolerate
eventual consistency. The parameters <em>w</em> and <em>r</em> allow you to adjust the probability of stale values
being read, but it’s wise to not take them as absolute guarantees.</p>

<p>In particular, you usually do not get the guarantees discussed in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_lag">“Problems with Replication Lag”</a> (reading
your writes, monotonic reads, or consistent prefix reads), so the previously mentioned anomalies can
occur in applications. Stronger guarantees generally require transactions or consensus. We will
return to these topics in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch07.html#ch_transactions">Chapter&nbsp;7</a> and <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch09.html#ch_consistency">Chapter&nbsp;9</a>.
<a data-type="indexterm" data-primary="leaderless replication" data-secondary="quorums" data-startref="ix_leaderlessquorums" id="idm140417568640512"></a>
<a data-type="indexterm" data-primary="quorums" data-startref="ix_replquorums" id="idm140417568639136"></a></p>










<section data-type="sect3" data-pdf-bookmark="Monitoring staleness"><div class="sect3" id="idm140417568638032">
<h3>Monitoring staleness</h3>

<p><a data-type="indexterm" data-primary="quorums" data-secondary="monitoring staleness" id="idm140417568636624"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="monitoring staleness" id="idm140417568635520"></a>
<a data-type="indexterm" data-primary="staleness (old data)" data-secondary="monitoring for" id="idm140417568634416"></a>
From an operational perspective, it’s important to monitor whether your databases are
returning up-to-date results. Even if your application can tolerate stale reads, you need to be
aware of the health of your replication. If it falls behind significantly, it should alert you so
that you can investigate the cause (for example, a problem in the network or an overloaded node).</p>

<p>For leader-based replication, the database typically exposes metrics for the replication lag, which
you can feed into a monitoring system. This is possible because writes are applied to the leader and
to followers in the same order, and each node has a position in the replication log (the number of
writes it has applied locally). By subtracting a follower’s current position from the leader’s
current position, you can measure the amount of replication lag.</p>

<p>However, in systems with leaderless replication, there is no fixed order in which writes are
applied, which makes monitoring more difficult. Moreover, if the database only uses read repair (no
anti-entropy), there is no limit to how old a value might be—if a value is only infrequently
read, the value returned by a stale replica may be ancient.</p>

<p>There has been some research on measuring replica staleness in databases with leaderless
replication and predicting the expected percentage of stale reads depending on the parameters <em>n</em>,
<em>w</em>, and <em>r</em> [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Bailis2014kt-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Bailis2014kt">48</a>].
This is unfortunately not yet common practice, but it would be good to include staleness
measurements in the standard set of metrics for databases. Eventual consistency is a deliberately
vague guarantee, but for operability it’s important to be able to quantify “eventual.”
<a data-type="indexterm" data-primary="leaderless replication" data-secondary="consistency limitations" data-startref="ix_noleadrepllimit" id="idm140417568626048"></a>
<a data-type="indexterm" data-primary="quorums" data-secondary="limitations of consistency" data-startref="ix_quorumlimit" id="idm140417568624704"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="leaderless" data-tertiary="limitations of quorum consistency" data-startref="ix_replnoleadlimits" id="idm140417568623312"></a></p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Sloppy Quorums and Hinted Handoff"><div class="sect2" id="sec_replication_sloppy_quorum">
<h2>Sloppy Quorums and Hinted Handoff</h2>

<p><a data-type="indexterm" data-primary="replication" data-secondary="leaderless" data-tertiary="sloppy quorums and hinted handoff" id="idm140417568620128"></a>
<a data-type="indexterm" data-primary="leaderless replication" data-secondary="quorums" data-tertiary="sloppy quorums and hinted handoff" id="idm140417568618560"></a>
<a data-type="indexterm" data-primary="quorums" data-secondary="sloppy quorums and hinted handoff" id="idm140417568617168"></a>
Databases with appropriately configured quorums can tolerate the failure of individual nodes without
the need for failover. They can also tolerate individual nodes going slow, because requests don’t have
to wait for all <em>n</em> nodes to respond—they can return when <em>w</em> or <em>r</em> nodes have responded. These
characteristics make databases with leaderless replication appealing for use cases that require
high availability and low latency, and that can tolerate occasional stale reads.</p>

<p>However, quorums (as described so far) are not as fault-tolerant as they could be. A network
interruption can easily cut off a client from a large number of database nodes. Although those nodes
are alive, and other clients may be able to connect to them, to a client that is cut off from the
database nodes, they might as well be dead. In this situation, it’s likely that fewer than <em>w</em> or <em>r</em>
reachable nodes remain, so the client can no longer reach a quorum.</p>

<p>In a large cluster (with significantly more than <em>n</em> nodes) it’s likely that the client can connect
to <em>some</em> database nodes during the network interruption, just not to the nodes that it needs to
assemble a quorum for a particular value. In that case, database designers face a trade-off:</p>

<ul>
<li>
<p>Is it better to return errors to all requests for which we cannot reach a quorum of <em>w</em> or <em>r</em>
nodes?</p>
</li>
<li>
<p>Or should we accept writes anyway, and write them to some nodes that are reachable but aren’t
among the <em>n</em> nodes on which the value usually lives?</p>
</li>
</ul>

<p><a data-type="indexterm" data-primary="sloppy quorums" data-seealso="quorums" id="idm140417568607152"></a>
The latter is known as a <em>sloppy quorum</em>
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#DeCandia2007ui_ch5">37</a>]: writes and reads still require <em>w</em>
and <em>r</em> successful responses, but those may include nodes that are not among the designated <em>n</em>
“home” nodes for a value. By analogy, if you lock yourself out of your house, you may knock on the
neighbor’s door and ask whether you may stay on their couch temporarily.</p>

<p><a data-type="indexterm" data-primary="hinted handoff" id="idm140417568602976"></a>
Once the network interruption is fixed, any writes that one node temporarily accepted on behalf of
another node are sent to the appropriate “home” nodes. This is called <em>hinted handoff</em>. (Once you
find the keys to your house again, your neighbor politely asks you to get off their couch and go
home.)</p>

<p>Sloppy quorums are particularly useful for increasing write availability: as long as <em>any</em> <em>w</em> nodes
are available, the database can accept writes. However, this means that even when
<em>w</em>&nbsp;+&nbsp;<em>r</em> &gt; <em>n</em>, you cannot be sure to read the latest value for a key, because the
latest value may have been temporarily written to some nodes outside of <em>n</em>
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Blomstedt2012vi">47</a>].</p>

<p>Thus, a sloppy quorum actually isn’t a quorum at all in the traditional sense. It’s only an
assurance of durability, namely that the data is stored on <em>w</em> nodes somewhere. There is no
guarantee that a read of <em>r</em> nodes will see it until the hinted handoff has completed.</p>

<p><a data-type="indexterm" data-primary="Riak (database)" data-secondary="sloppy quorums" id="idm140417568595424"></a>
<a data-type="indexterm" data-primary="Cassandra (database)" data-secondary="sloppy quorums" id="idm140417568594016"></a>
<a data-type="indexterm" data-primary="Voldemort (database)" data-secondary="sloppy quorums" id="idm140417568592912"></a>
Sloppy quorums are optional in all common Dynamo implementations. In Riak they are enabled by
default, and in Cassandra and Voldemort they are disabled by default
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Blomstedt2012vf">46</a>, <a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Ellis2012wm-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Ellis2012wm">49</a>,
<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="VoldemortWiki-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#VoldemortWiki">50</a>].</p>










<section data-type="sect3" data-pdf-bookmark="Multi-datacenter operation"><div class="sect3" id="idm140417568586416">
<h3>Multi-datacenter operation</h3>

<p><a data-type="indexterm" data-primary="leaderless replication" data-secondary="multi-datacenter" id="idm140417568585216"></a>
<a data-type="indexterm" data-primary="quorums" data-secondary="multi-datacenter replication" id="idm140417568584112"></a>
<a data-type="indexterm" data-primary="datacenters" data-secondary="replication across multiple" data-tertiary="leaderless replication" id="idm140417568583040"></a>
We previously discussed cross-datacenter replication as a use case for multi-leader replication (see
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_multi_leader">“Multi-Leader Replication”</a>). Leaderless replication is also suitable for
multi-datacenter operation, since it is designed to tolerate conflicting concurrent writes, network
interruptions, and latency spikes.</p>

<p><a data-type="indexterm" data-primary="Cassandra (database)" data-secondary="multi-datacenter support" id="idm140417568580320"></a>
<a data-type="indexterm" data-primary="Voldemort (database)" data-secondary="multi-datacenter support" id="idm140417568579056"></a>
Cassandra and Voldemort implement their multi-datacenter support within the normal leaderless model:
the number of replicas <em>n</em> includes nodes in all datacenters, and in the configuration you can
specify how many of the <em>n</em> replicas you want to have in each datacenter. Each write from a client
is sent to all replicas, regardless of datacenter, but the client usually only waits for
acknowledgment from a quorum of nodes within its local datacenter so that it is unaffected by
delays and interruptions on the cross-datacenter link. The higher-latency writes to other
datacenters are often configured to happen asynchronously, although there is some flexibility in the
configuration [<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#VoldemortWiki">50</a>,
<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Cassandra20-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Cassandra20">51</a>].</p>

<p><a data-type="indexterm" data-primary="Riak (database)" data-secondary="multi-datacenter support" id="idm140417568573568"></a>
Riak keeps all communication between clients and database nodes local to one datacenter, so <em>n</em>
describes the number of replicas within one datacenter. Cross-datacenter replication between
database clusters happens asynchronously in the background, in a style that is similar to
multi-leader replication
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Riak2014vb-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Riak2014vb">52</a>].</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Detecting Concurrent Writes"><div class="sect2" id="sec_replication_concurrent">
<h2>Detecting Concurrent Writes</h2>

<p><a data-type="indexterm" data-primary="conflicts" data-secondary="conflict detection" data-tertiary="in leaderless replication" id="idm140417568568032"></a>
<a data-type="indexterm" data-primary="concurrency" data-secondary="detecting concurrent writes" id="ix_concurwrrepl"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="leaderless" data-tertiary="detecting concurrent writes" id="ix_replnoleadconcwr"></a>
<a data-type="indexterm" data-primary="leaderless replication" data-secondary="detecting concurrent writes" id="ix_noleadreplconcwr"></a>
Dynamo-style databases allow several clients to concurrently write to the same key, which means that
conflicts will occur even if strict quorums are used. The situation is similar to multi-leader
replication (see <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_write_conflicts">“Handling Write Conflicts”</a>), although in Dynamo-style databases conflicts
can also arise during read repair or hinted handoff.</p>

<p>The problem is that events may arrive in a different order at different nodes, due to variable
network delays and partial failures. For example, <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_concurrency">Figure&nbsp;5-12</a> shows two clients,
A and B, simultaneously writing to a key <em>X</em> in a three-node datastore:</p>

<ul>
<li>
<p>Node 1 receives the write from A, but never receives the write from B due to a transient
outage.</p>
</li>
<li>
<p>Node 2 first receives the write from A, then the write from B.</p>
</li>
<li>
<p>Node 3 first receives the write from B, then the write from A.</p>
</li>
</ul>

<figure><div id="fig_replication_concurrency" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0512.png" alt="ddia 0512" width="2880" height="1406" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0512.png">
<h6><span class="label">Figure 5-12. </span>Concurrent writes in a Dynamo-style datastore: there is no well-defined ordering.</h6>
</div></figure>

<p>If each node simply overwrote the value for a key whenever it received a write request from a
client, the nodes would become permanently inconsistent, as shown by the final <em>get</em> request in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_concurrency">Figure&nbsp;5-12</a>: node 2 thinks that the final value of <em>X</em> is B, whereas the other
nodes think that the value is A.</p>

<p>In order to become eventually consistent, the replicas should converge toward the same value. How
do they do that? One might hope that replicated databases would handle this automatically, but
unfortunately most implementations are quite poor: if you want to avoid losing data, you—the
application developer—need to know a lot about the internals of your database’s conflict
handling.</p>

<p>We briefly touched on some techniques for conflict resolution in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_write_conflicts">“Handling Write Conflicts”</a>. Before we wrap up this chapter, let’s explore the issue in a
bit more detail.</p>










<section data-type="sect3" data-pdf-bookmark="Last write wins (discarding concurrent writes)"><div class="sect3" id="sec_replication_lww">
<h3>Last write wins (discarding concurrent writes)</h3>

<p><a data-type="indexterm" data-primary="conflicts" data-secondary="conflict resolution" data-tertiary="last write wins (LWW)" id="idm140417568547488"></a>
<a data-type="indexterm" data-primary="last write wins (LWW)" data-secondary="discarding concurrent writes" id="idm140417568546112"></a>
<a data-type="indexterm" data-primary="leaderless replication" data-secondary="detecting concurrent writes" data-tertiary="last write wins" id="idm140417568544992"></a>
<a data-type="indexterm" data-primary="LWW" data-see="last write wins" id="idm140417568543600"></a>
One approach for achieving eventual convergence is to declare that each replica need only store the
most “recent” value and allow “older” values to be overwritten and discarded. Then, as long as we
have some way of unambiguously determining which write is more “recent,” and every write is
eventually copied to every replica, the replicas will eventually converge to the same value.</p>

<p>As indicated by the quotes around “recent,” this idea is actually quite misleading. In the
example of <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_concurrency">Figure&nbsp;5-12</a>, neither client knew about the other one when it sent its
write requests to the database nodes, so it’s not clear which one happened first. In fact, it
doesn’t really make sense to say that either happened “first”: we say the writes are <em>concurrent</em>,
so their order is undefined.</p>

<p><a data-type="indexterm" data-primary="Cassandra (database)" data-secondary="last-write-wins conflict resolution" id="idm140417568539792"></a>
<a data-type="indexterm" data-primary="Riak (database)" data-secondary="last-write-wins conflict resolution" id="idm140417568538624"></a>
Even though the writes don’t have a natural ordering, we can force an arbitrary order on them. For
example, we can attach a timestamp to each write, pick the biggest timestamp as the most “recent,”
and discard any writes with an earlier timestamp. This conflict resolution algorithm, called <em>last
write wins</em> (LWW), is the only supported conflict resolution method in Cassandra
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Ellis2013ug-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Ellis2013ug">53</a>],
and an optional feature in Riak [<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Daily2013te_ch5">35</a>].</p>

<p>LWW achieves the goal of eventual convergence, but at the cost of durability: if there are several
concurrent writes to the same key, even if they were all reported as successful to the client
(because they were written to <em>w</em> replicas), only one of the writes will survive and the others will
be silently discarded. Moreover, LWW may even drop writes that are not concurrent, as we shall
discuss in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch08.html#sec_distributed_lww">“Timestamps for ordering events”</a>.</p>

<p>There are some situations, such as caching, in which lost writes are perhaps acceptable. If losing
data is not acceptable, LWW is a poor choice for conflict resolution.</p>

<p>The only safe way of using a database with LWW is to ensure that a key is only written once and
thereafter treated as immutable, thus avoiding any concurrent updates to the same key. For example,
a recommended way of using Cassandra is to use a UUID as the key, thus giving each write operation a
unique key [<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Ellis2013ug">53</a>].</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="The “happens-before” relationship and concurrency"><div class="sect3" id="sec_replication_happens_before">
<h3>The “happens-before” relationship and concurrency</h3>

<p><a data-type="indexterm" data-primary="leaderless replication" data-secondary="detecting concurrent writes" data-tertiary="happens-before relationship and concurrency" id="idm140417568527472"></a>
<a data-type="indexterm" data-primary="concurrency" data-secondary="happens-before relationship" id="idm140417568525808"></a>
<a data-type="indexterm" data-primary="conflicts" data-secondary="conflict detection" data-tertiary="causal dependencies" id="idm140417568524688"></a>
<a data-type="indexterm" data-primary="causality" data-secondary="happens-before relationship" id="idm140417568523312"></a>
<a data-type="indexterm" data-primary="happens-before relationship" data-secondary="concurrency and" id="idm140417568522192"></a>
<a data-type="indexterm" data-primary="causal dependencies" id="ix_causaldep"></a>
How do we decide whether two operations are concurrent or not? To develop an intuition, let’s look
at some examples:</p>

<ul>
<li>
<p>In <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_causality">Figure&nbsp;5-9</a>, the two writes are not concurrent: A’s insert <em>happens before</em>
B’s increment, because the value incremented by B is the value inserted by A. In other words, B’s
operation builds upon A’s operation, so B’s operation must have happened later.
We also say that B is <em>causally dependent</em> on A.</p>
</li>
<li>
<p>On the other hand, the two writes in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_concurrency">Figure&nbsp;5-12</a> are concurrent: when each
client starts the operation, it does not know that another client is also performing an operation
on the same key. Thus, there is no causal dependency between the operations.</p>
</li>
</ul>

<p>An operation A <em>happens before</em> another operation B if B knows about A, or depends on A, or builds
upon A in some way. Whether one operation happens before another operation is the key to defining
what concurrency means. In fact, we can simply say that two operations are <em>concurrent</em> if neither
happens before the other (i.e., neither knows about the other)
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Lamport1978jq_ch5-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Lamport1978jq_ch5">54</a>].</p>

<p>Thus, whenever you have two operations A and B, there are three possibilities: either A happened
before B, or B happened before A, or A and B are concurrent. What we need is an algorithm to tell us
whether two operations are concurrent or not. If one operation happened before another, the later
operation should overwrite the earlier operation, but if the operations are concurrent, we have a
conflict that needs to be resolved.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_replication_concurrency">
<h5>Concurrency, Time, and Relativity</h5>
<p><a data-type="indexterm" data-primary="time" data-secondary="concurrency and" id="idm140417568507680"></a>
<a data-type="indexterm" data-primary="concurrency" data-secondary="time and relativity" id="idm140417568506576"></a>
It may seem that two operations should be called concurrent if they occur “at the same time”—but
in fact, it is not important whether they literally overlap in time. Because of problems with clocks
in distributed systems, it is actually quite difficult to tell whether two things happened
at exactly the same time—an issue we will discuss in more detail in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch08.html#ch_distributed">Chapter&nbsp;8</a>.</p>

<p>For defining concurrency, exact time doesn’t matter: we simply call two operations concurrent if
they are both unaware of each other, regardless of the physical time at which they occurred. People
sometimes make a connection between this principle and the special theory of relativity in physics
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Lamport1978jq_ch5">54</a>], which introduced the idea that
information cannot travel faster than the speed of light. Consequently, two events that occur some
distance apart cannot possibly affect each other if the time between the events is shorter than the
time it takes light to travel the distance between them.</p>

<p>In computer systems, two operations might be concurrent even though the speed of light would in
principle have allowed one operation to affect the other. For example, if the network was slow or
interrupted at the time, two operations can occur some time apart and still be concurrent, because
the network problems prevented one operation from being able to know about the other.</p>
</div></aside>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Capturing the happens-before relationship"><div class="sect3" id="idm140417568501504">
<h3>Capturing the happens-before relationship</h3>

<p><a data-type="indexterm" data-primary="happens-before relationship" data-secondary="capturing" id="idm140417568499936"></a>
<a data-type="indexterm" data-primary="leaderless replication" data-secondary="detecting concurrent writes" data-tertiary="capturing happens-before relationship" id="idm140417568498864"></a>
Let’s look at an algorithm that determines whether two operations are concurrent, or whether one
happened before another. To keep things simple, let’s start with a database that has only one
replica. Once we have worked out how to do this on a single replica, we can generalize the approach
to a leaderless database with multiple replicas.</p>

<p><a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_causality_single">Figure&nbsp;5-13</a> shows two clients concurrently adding items to the same
shopping cart. (If that example strikes you as too inane, imagine instead two air traffic
controllers concurrently adding aircraft to the sector they are tracking.) Initially, the cart is
empty. Between them, the clients make five writes to the database:</p>
<ol>
<li>
<p>Client 1 adds <code>milk</code> to the cart. This is the first write to that key, so the server successfully
stores it and assigns it version 1. The server also echoes the value back to the client, along
with the version number.</p>
</li>
<li>
<p>Client 2 adds <code>eggs</code> to the cart, not knowing that client 1 concurrently added <code>milk</code> (client 2
thought that its <code>eggs</code> were the only item in the cart). The server assigns version 2 to this
write, and stores <code>eggs</code> and <code>milk</code> as two separate values. It then returns <em>both</em> values to the
client, along with the version number of 2.</p>
</li>
<li>
<p>Client 1, oblivious to client 2’s write, wants to add <code>flour</code> to the cart, so it thinks the
current cart contents should be <code>[milk, flour]</code>. It sends this value to the server, along with
the version number 1 that the server gave client 1 previously. The server can tell from the
version number that the write of <code>[milk, flour]</code> supersedes the prior value of <code>[milk]</code> but that
it is concurrent with <code>[eggs]</code>. Thus, the server assigns version 3 to <code>[milk, flour]</code>, overwrites
the version 1 value <code>[milk]</code>, but keeps the version 2 value <code>[eggs]</code> and returns both remaining
values to the client.</p>
</li>
<li>
<p>Meanwhile, client 2 wants to add <code>ham</code> to the cart, unaware that client 1 just added <code>flour</code>.
Client 2 received the two values <code>[milk]</code> and <code>[eggs]</code> from the server in the last response, so
the client now merges those values and adds <code>ham</code> to form a new value, <code>[eggs, milk, ham]</code>. It
sends that value to the server, along with the previous version number 2. The server detects that
version 2 overwrites <code>[eggs]</code> but is concurrent with <code>[milk, flour]</code>, so the two remaining
values are <code>[milk, flour]</code> with version 3, and <code>[eggs, milk, ham]</code> with version 4.</p>
</li>
<li>
<p>Finally, client 1 wants to add <code>bacon</code>. It previously received <code>[milk, flour]</code> and <code>[eggs]</code> from
the server at version 3, so it merges those, adds <code>bacon</code>, and sends the final value
<code>[milk, flour, eggs, bacon]</code> to the server, along with the version number 3. This overwrites
<code>[milk, flour]</code> (note that <code>[eggs]</code> was already overwritten in the last step) but is concurrent
with <code>[eggs, milk, ham]</code>, so the server keeps those two concurrent values.</p>
</li>

</ol>

<figure><div id="fig_replication_causality_single" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0513.png" alt="ddia 0513" width="2880" height="1633" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0513.png">
<h6><span class="label">Figure 5-13. </span>Capturing causal dependencies between two clients concurrently editing a shopping cart.</h6>
</div></figure>

<p>The dataflow between the operations in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_causality_single">Figure&nbsp;5-13</a> is illustrated
graphically in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_causal_dependencies">Figure&nbsp;5-14</a>. The arrows indicate which operation
<em>happened before</em> which other operation, in the sense that the later operation <em>knew about</em> or
<em>depended on</em> the earlier one. In this example, the clients are never fully up to date with the data
on the server, since there is always another operation going on concurrently. But old versions of
the value do get overwritten eventually, and no writes are lost.</p>

<figure><div id="fig_replication_causal_dependencies" class="figure">
<img src="https://www.safaribooksonline.com/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0514.png" alt="ddia 0514" width="2880" height="718" data-mfp-src="/library/view/designing-data-intensive-applications/9781491903063/assets/ddia_0514.png">
<h6><span class="label">Figure 5-14. </span>Graph of causal dependencies in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_causality_single">Figure&nbsp;5-13</a>.</h6>
</div></figure>

<p>Note that the server can determine whether two operations are concurrent by looking at the version
numbers—it does not need to interpret the value itself (so the value could be any data
structure). The algorithm works as follows:</p>

<ul>
<li>
<p>The server maintains a version number for every key, increments the version number every time that
key is written, and stores the new version number along with the value written.</p>
</li>
<li>
<p>When a client reads a key, the server returns all values that have not been overwritten, as well
as the latest version number. A client must read a key before <span class="keep-together">writing.</span></p>
</li>
<li>
<p>When a client writes a key, it must include the version number from the prior read, and it must
merge together all values that it received in the prior read. (The response from a write request
can be like a read, returning all current values, which allows us to chain several writes like in
the shopping cart example.)</p>
</li>
<li>
<p>When the server receives a write with a particular version number, it can overwrite all values
with that version number or below (since it knows that they have been merged into the new value),
but it must keep all values with a higher version number (because those values are concurrent with
the incoming write).</p>
</li>
</ul>

<p>When a write includes the version number from a prior read, that tells us which previous state the
write is based on. If you make a write without including a version number, it is concurrent with all
other writes, so it will not overwrite anything—it will just be returned as one of the values
on subsequent reads.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Merging concurrently written values"><div class="sect3" id="idm140417568500880">
<h3>Merging concurrently written values</h3>

<p><a data-type="indexterm" data-primary="conflicts" data-secondary="conflict resolution" data-tertiary="in leaderless systems" id="idm140417568457520"></a>
<a data-type="indexterm" data-primary="siblings (concurrent values)" data-seealso="conflicts" id="idm140417568456144"></a>
<a data-type="indexterm" data-primary="leaderless replication" data-secondary="detecting concurrent writes" data-tertiary="merging concurrently written values" id="idm140417568455024"></a>
<a data-type="indexterm" data-primary="Riak (database)" data-secondary="siblings (concurrently written values)" id="idm140417568453616"></a>
This algorithm ensures that no data is silently dropped, but it unfortunately requires that the
clients do some extra work: if several operations happen concurrently, clients have to clean up
afterward by merging the concurrently written values. Riak calls these concurrent values
<em>siblings</em>.</p>

<p>Merging sibling values is essentially the same problem as conflict resolution in multi-leader
replication, which we discussed previously (see <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_write_conflicts">“Handling Write Conflicts”</a>). A simple
approach is to just pick one of the values based on a version number or timestamp (last write wins),
but that implies losing data. So, you may need to do something more intelligent in application code.</p>

<p>With the example of a shopping cart, a reasonable approach to merging siblings is to just take the
union. In <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_causal_dependencies">Figure&nbsp;5-14</a>, the two final siblings are <code>[milk, flour, eggs, bacon]</code>
and <code>[eggs, milk, ham]</code>; note that <code>milk</code> and <code>eggs</code> appear in both, even though they were each only
written once. The merged value might be something like <code>[milk, flour, eggs, bacon, ham]</code>, without
duplicates.</p>

<p>However, if you want to allow people to also <em>remove</em> things from their carts, and not just add
things, then taking the union of siblings may not yield the right result: if you merge two sibling
carts and an item has been removed in only one of them, then the removed item will reappear in the
union of the siblings [<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#DeCandia2007ui_ch5">37</a>]. To prevent
this problem, an item cannot simply be deleted from the database when it is removed; instead, the
system must leave a marker with an appropriate version number to indicate that the item has been
removed when merging siblings. <a data-type="indexterm" data-primary="tombstones" id="idm140417568443952"></a> Such a deletion marker is known as a <em>tombstone</em>.
(We previously saw tombstones in the context of log compaction in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch03.html#sec_storage_hash_index">“Hash Indexes”</a>.)</p>

<p><a data-type="indexterm" data-primary="Riak (database)" data-secondary="CRDTs" id="idm140417568441696"></a>
As merging siblings in application code is complex and error-prone, there are some efforts to design
data structures that can perform this merging automatically, as discussed in
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sidebar_conflict_resolution">“Automatic Conflict Resolution”</a>. For example, Riak’s datatype support uses a family of data
structures called CRDTs [<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Shapiro2011wy">38</a>,
<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Elliott2013ua">39</a>,
<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Jacobson2014wa_ch5-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Jacobson2014wa_ch5">55</a>] that can automatically merge siblings in sensible
ways, including preserving deletions.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Version vectors"><div class="sect3" id="idm140417568435328">
<h3>Version vectors</h3>

<p><a data-type="indexterm" data-primary="causal dependencies" data-secondary="capturing" id="idm140417568433888"></a>
<a data-type="indexterm" data-primary="version vectors" id="idm140417568432784"></a>
<a data-type="indexterm" data-primary="leaderless replication" data-secondary="detecting concurrent writes" data-tertiary="version vectors" id="idm140417568431952"></a>
The example in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_causality_single">Figure&nbsp;5-13</a> used only a single replica. How does the
algorithm change when there are multiple replicas, but no leader?</p>

<p><a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_causality_single">Figure&nbsp;5-13</a> uses a single version number to capture dependencies between
operations, but that is not sufficient when there are multiple replicas accepting writes
concurrently. Instead, we need to use a version number <em>per replica</em> as well as per key. Each
replica increments its own version number when processing a write, and also keeps track of the
version numbers it has seen from each of the other replicas. This information indicates which values
to overwrite and which values to keep as siblings.</p>

<p><a data-type="indexterm" data-primary="Riak (database)" data-secondary="dotted version vectors" id="idm140417568427344"></a>
The collection of version numbers from all the replicas is called a <em>version vector</em>
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="ParkerJr1983jb-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#ParkerJr1983jb">56</a>].
A few variants of this idea are in use, but the most interesting is probably the <em>dotted version
vector</em>
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Preguica2010wu-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Preguica2010wu">57</a>], which is used in Riak 2.0
[<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Cribbs2014wc-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Cribbs2014wc">58</a>, <a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Brown2015wx-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Brown2015wx">59</a>].
We won’t go into the details, but the way it works is quite similar to what we saw in our cart example.</p>

<p><a data-type="indexterm" data-primary="causal context" data-seealso="causal dependencies" id="idm140417568415856"></a>
Like the version numbers in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#fig_replication_causality_single">Figure&nbsp;5-13</a>, version vectors are sent from the
database replicas to clients when values are read, and need to be sent back to the database when a
value is subsequently written. (Riak encodes the version vector as a string that it calls <em>causal
context</em>.) The version vector allows the database to distinguish between overwrites and concurrent
writes.</p>

<p>Also, like in the single-replica example, the application may need to merge
siblings. The version vector structure ensures that it is safe to read from one replica and
subsequently write back to another replica. Doing so may result in siblings being created, but no data
is lost as long as siblings are merged correctly.</p>
<div data-type="note" epub:type="note"><h1>Version vectors and vector clocks</h1>
<p><a data-type="indexterm" data-primary="version vectors" data-secondary="versus vector clocks" id="idm140417568411264"></a>
<a data-type="indexterm" data-primary="vector clocks" data-seealso="version vectors" id="idm140417568409760"></a>
A <em>version vector</em> is sometimes also called a <em>vector clock</em>, even though they are not quite the
same. The difference is subtle—please see the references for details
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Preguica2010wu">57</a>,
<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Baquero2011ud-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Baquero2011ud">60</a>,
<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Schwarz1994gl-marker" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Schwarz1994gl">61</a>]. In brief, when
comparing the state of replicas, version vectors are the right data structure to use.
<a data-type="indexterm" data-primary="concurrency" data-secondary="detecting concurrent writes" data-startref="ix_concurwrrepl" id="idm140417568401552"></a>
<a data-type="indexterm" data-primary="concurrency" data-secondary="in replicated systems" data-startref="ix_concrepllag" id="idm140417568400192"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="leaderless" data-tertiary="detecting concurrent writes" data-startref="ix_replnoleadconcwr" id="idm140417568398816"></a>
<a data-type="indexterm" data-primary="leaderless replication" data-secondary="detecting concurrent writes" data-startref="ix_noleadreplconcwr" id="idm140417568397152"></a>
<a data-type="indexterm" data-primary="replication" data-secondary="leaderless" data-startref="ix_replnolead" id="idm140417568395760"></a>
<a data-type="indexterm" data-primary="leaderless replication" data-startref="ix_noleadrepl" id="idm140417568394384"></a>
<a data-type="indexterm" data-primary="causal dependencies" data-startref="ix_causaldep" id="idm140417568393280"></a></p>
</div>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm140417568569264">
<h1>Summary</h1>

<p>In this chapter we looked at the issue of replication. Replication can serve several purposes:</p>
<dl>
<dt><em>High availability</em></dt>
<dd>
<p>Keeping the system running, even when one machine (or several machines, or an
entire datacenter) goes down</p>
</dd>
<dt><em>Disconnected operation</em></dt>
<dd>
<p>Allowing an application to continue working when there is a network
interruption</p>
</dd>
<dt><em>Latency</em></dt>
<dd>
<p>Placing data geographically close to users, so that users can interact with it faster</p>
</dd>
<dt><em>Scalability</em></dt>
<dd>
<p>Being able to handle a higher volume of reads than a single machine could handle,
by performing reads on replicas</p>
</dd>
</dl>

<p>Despite being a simple goal—keeping a copy of the same data on several machines—replication turns out
to be a remarkably tricky problem. It requires carefully thinking about concurrency and about all
the things that can go wrong, and dealing with the consequences of those faults. At a minimum, we
need to deal with unavailable nodes and network interruptions (and that’s not even considering the
more insidious kinds of fault, such as silent data corruption due to software bugs).</p>

<p>We discussed three main approaches to replication:</p>
<dl>
<dt><em>Single-leader replication</em></dt>
<dd>
<p>Clients send all writes to a single node (the leader), which sends a
stream of data change events to the other replicas (followers). Reads can be performed on any
replica, but reads from followers might be stale.</p>
</dd>
<dt><em>Multi-leader replication</em></dt>
<dd>
<p>Clients send each write to one of several leader nodes, any of which
can accept writes. The leaders send streams of data change events to each other and to any
follower nodes.</p>
</dd>
<dt><em>Leaderless replication</em></dt>
<dd>
<p>Clients send each write to several nodes, and read from several nodes
in parallel in order to detect and correct nodes with stale data.</p>
</dd>
</dl>

<p>Each approach has advantages and disadvantages. Single-leader replication is popular because it is fairly
easy to understand and there is no conflict resolution to worry about. Multi-leader and
leaderless replication can be more robust in the presence of faulty nodes, network interruptions,
and latency spikes—at the cost of being harder to reason about and providing only very weak
consistency guarantees.</p>

<p>Replication can be synchronous or asynchronous, which has a profound effect on the system behavior
when there is a fault. Although asynchronous replication can be fast when the system is running
smoothly, it’s important to figure out what happens when replication lag increases and servers fail.
If a leader fails and you promote an asynchronously updated follower to be the new leader, recently
committed data may be lost.</p>

<p>We looked at some strange effects that can be caused by replication lag, and we discussed a few
consistency models which are helpful for deciding how an application should behave under replication
lag:</p>
<dl>
<dt><em>Read-after-write consistency</em></dt>
<dd>
<p>Users should always see data that they submitted themselves.</p>
</dd>
<dt><em>Monotonic reads</em></dt>
<dd>
<p>After users have seen the data at one point in time, they shouldn’t later see
the data from some earlier point in time.</p>
</dd>
<dt><em>Consistent prefix reads</em></dt>
<dd>
<p>Users should see the data in a state that makes causal sense:
for example, seeing a question and its reply in the correct order.</p>
</dd>
</dl>

<p>Finally, we discussed the concurrency issues that are inherent in multi-leader and leaderless
replication approaches: because they allow multiple writes to happen concurrently, conflicts may
occur. We examined an algorithm that a database might use to determine whether one operation
happened before another, or whether they happened concurrently. We also touched on methods for
resolving conflicts by merging together concurrent updates.</p>

<p>In the next chapter we will continue looking at data that is distributed across multiple machines,
through the counterpart of replication: splitting a large dataset into <em>partitions</em>.
<a data-type="indexterm" data-primary="replication" data-startref="ix_replicate" id="idm140417568367920"></a></p>
</div></section>







<div data-type="footnotes"><h5>Footnotes</h5><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm140417569383648"><sup><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417569383648-marker" class="totri-footnote">i</a></sup> Different people have
different definitions for <em>hot</em>, <em>warm</em>, and <em>cold</em> standby servers. In
PostgreSQL, for example, <em>hot standby</em> is used to refer to a replica that accepts reads
from clients, whereas a <em>warm standby</em> processes changes from the leader but doesn’t
process any queries from clients. For purposes of this book, the difference isn’t
important.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm140417569235216"><sup><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417569235216-marker">ii</a></sup> This approach is known as
<em>fencing</em> or, more emphatically, <em>Shoot The Other Node In The Head</em> (STONITH). We
will discuss fencing in more detail in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch08.html#sec_distributed_lock_fencing">“The leader and the lock”</a>.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm140417569110560"><sup><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417569110560-marker">iii</a></sup> The
term <em>eventual consistency</em> was coined by Douglas Terry et al.
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Terry1994fp">24</a>], popularized by Werner Vogels
[<a data-type="noteref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Vogels2008ey">22</a>], and became the battle cry of many NoSQL
projects. However, not only NoSQL databases are eventually consistent: followers in an
asynchronously replicated relational database have the same characteristics.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm140417569015280"><sup><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417569015280-marker">iv</a></sup> If the database is partitioned (see
<a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch06.html#ch_partitioning">Chapter&nbsp;6</a>), each partition has one leader. Different partitions
may have their leaders on different nodes, but each partition must nevertheless have one leader
node.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm140417568810256"><sup><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417568810256-marker" class="totri-footnote">v</a></sup> Not to be confused with a
<em>star schema</em> (see <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch03.html#sec_storage_analytics_schemas">“Stars and Snowflakes: Schemas for Analytics”</a>), which
describes the structure of a data model, not the communication topology between nodes.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm140417568763264"><sup><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417568763264-marker">vi</a></sup> Dynamo
is not available to users outside of Amazon. Confusingly, AWS offers a hosted database product
called <em>DynamoDB</em>, which uses a completely different architecture: it is based on
single-leader replication.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm140417568721472"><sup><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#idm140417568721472-marker">vii</a></sup> Sometimes
this kind of quorum is called a <em>strict quorum</em>, to contrast with <em>sloppy quorums</em>
(discussed in <a data-type="xref" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#sec_replication_sloppy_quorum">“Sloppy Quorums and Hinted Handoff”</a>).</p></div><div data-type="footnotes"><h5>References</h5><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Lindsay1979wv_ch5">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Lindsay1979wv_ch5-marker" class="totri-footnote">1</a>] Bruce G. Lindsay, Patricia Griffiths Selinger, C. Galtieri, et al.:
“<a href="http://domino.research.ibm.com/library/cyberdig.nsf/papers/A776EC17FC2FCE73852579F100578964/%24File/RJ2571.pdf">Notes
on Distributed Databases</a>,” IBM Research, Research Report RJ2571(33471), July 1979.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Oracle2013uz">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Oracle2013uz-marker" class="totri-footnote">2</a>] “<a href="http://www.oracle.com/technetwork/database/availability/active-data-guard-wp-12c-1896127.pdf">Oracle
Active Data Guard Real-Time Data Protection and Availability</a>,” Oracle White Paper, June 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="AlwaysOn2012">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#AlwaysOn2012-marker" class="totri-footnote">3</a>] “<a href="http://msdn.microsoft.com/en-us/library/hh510230.aspx">AlwaysOn
Availability Groups</a>,” in <em>SQL Server Books Online</em>, Microsoft, 2012.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Qiao2013uv_ch5">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Qiao2013uv_ch5-marker" class="totri-footnote">4</a>] Lin Qiao, Kapil Surlaker, Shirshanka Das, et al.:
“<a href="http://www.slideshare.net/amywtang/espresso-20952131">On Brewing Fresh Espresso:
LinkedIn’s Distributed Data Serving Platform</a>,” at <em>ACM International Conference on
Management of Data</em> (SIGMOD), June 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Rao2013tf">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Rao2013tf-marker" class="totri-footnote">5</a>] Jun Rao:
“<a href="http://www.slideshare.net/junrao/kafka-replication-apachecon2013">Intra-Cluster
Replication for Apache Kafka</a>,” at <em>ApacheCon North America</em>, February 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="RabbitMQ2013">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#RabbitMQ2013-marker" class="totri-footnote">6</a>] “<a href="https://www.rabbitmq.com/ha.html">Highly
Available Queues</a>,” in <em>RabbitMQ Server Documentation</em>, Pivotal Software, Inc., 2014.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Matsunobu2014wu">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Matsunobu2014wu-marker" class="totri-footnote">7</a>] Yoshinori Matsunobu:
“<a href="http://yoshinorimatsunobu.blogspot.co.uk/2014/04/semi-synchronous-replication-at-facebook.html">Semi-Synchronous
Replication at Facebook</a>,” <em>yoshinorimatsunobu.blogspot.co.uk</em>, April 1, 2014.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="vanRenesse2004td_ch5">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#vanRenesse2004td_ch5-marker" class="totri-footnote">8</a>] Robbert van Renesse and Fred B. Schneider:
“<a href="http://static.usenix.org/legacy/events/osdi04/tech/full_papers/renesse/renesse.pdf">Chain
Replication for Supporting High Throughput and Availability</a>,” at <em>6th USENIX Symposium on
Operating System Design and Implementation</em> (OSDI), December 2004.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Terrace2009vx">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Terrace2009vx-marker" class="totri-footnote">9</a>] Jeff Terrace and Michael J. Freedman:
“<a href="https://www.usenix.org/legacy/event/usenix09/tech/full_papers/terrace/terrace.pdf">Object
Storage on CRAQ: High-Throughput Chain Replication for Read-Mostly Workloads</a>,” at <em>USENIX
Annual Technical Conference</em> (ATC), June 2009.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Calder2011to">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Calder2011to-marker">10</a>] Brad Calder, Ju Wang, Aaron Ogus, et al.:
“<a href="http://sigops.org/sosp/sosp11/current/2011-Cascais/printable/11-calder.pdf">Windows Azure
Storage: A Highly Available Cloud Storage Service with Strong Consistency</a>,” at <em>23rd ACM
Symposium on Operating Systems Principles</em> (SOSP), October 2011.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Wang2016vy">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Wang2016vy-marker">11</a>] Andrew Wang:
“<a href="http://umbrant.com/blog/2016/windows_azure_storage.html">Windows Azure Storage</a>,”
<em>umbrant.com</em>, February 4, 2016.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Xtrabackup2014">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Xtrabackup2014-marker">12</a>] “<a href="https://www.percona.com/doc/percona-xtrabackup/2.1/index.html">Percona
Xtrabackup - Documentation</a>,” Percona LLC, 2014.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Newland2012tw">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Newland2012tw-marker">13</a>] Jesse Newland:
“<a href="https://github.com/blog/1261-github-availability-this-week">GitHub Availability This
Week</a>,” <em>github.com</em>, September 14, 2012.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Imbriaco2012tx_ch5">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Imbriaco2012tx_ch5-marker">14</a>] Mark Imbriaco:
“<a href="https://github.com/blog/1364-downtime-last-saturday">Downtime Last Saturday</a>,”
<em>github.com</em>, December 26, 2012.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Hugg2015wp">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Hugg2015wp-marker">15</a>] John Hugg:
“<a href="https://www.youtube.com/watch?v=gJRj3vJL4wE">‘All in’ with Determinism for Performance and
Testing in Distributed Systems</a>,” at <em>Strange Loop</em>, September 2015.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="WALInternalsOfPos2012vf">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#WALInternalsOfPos2012vf-marker">16</a>] Amit Kapila:
“<a href="http://www.pgcon.org/2012/schedule/attachments/258_212_Internals%20Of%20PostgreSQL%20Wal.pdf">WAL
Internals of PostgreSQL</a>,” at <em>PostgreSQL Conference</em> (PGCon), May 2012.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="MySQLInternals">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#MySQLInternals-marker">17</a>] <a href="http://dev.mysql.com/doc/internals/en/index.html"><em>MySQL
Internals Manual</em></a>. Oracle, 2014.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Sharma2015te_ch5">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Sharma2015te_ch5-marker">18</a>] Yogeshwer Sharma, Philippe Ajoux, Petchean Ang, et al.:
“<a href="https://www.usenix.org/system/files/conference/nsdi15/nsdi15-paper-sharma.pdf">Wormhole:
Reliable Pub-Sub to Support Geo-Replicated Internet Services</a>,” at <em>12th USENIX
Symposium on Networked Systems Design and Implementation</em> (NSDI), May 2015.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Oracle2013ub">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Oracle2013ub-marker">19</a>] “<a href="http://www.oracle.com/us/products/middleware/data-integration/oracle-goldengate-realtime-access-2031152.pdf">Oracle
GoldenGate 12c: Real-Time Access to Real-Time Information</a>,” Oracle White Paper, October 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Das2012uf_ch5">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Das2012uf_ch5-marker">20</a>] Shirshanka Das, Chavdar Botev, Kapil Surlaker, et al.:
“<a href="http://www.socc2012.org/s18-das.pdf">All Aboard the Databus!</a>,” at
<em>ACM Symposium on Cloud Computing</em> (SoCC), October 2012.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Mullane2014uy">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Mullane2014uy-marker">21</a>] Greg Sabino Mullane:
“<a href="http://blog.endpoint.com/2014/06/bucardo-5-multimaster-postgres-released.html">Version
5 of Bucardo Database Replication System</a>,” <em>blog.endpoint.com</em>, June 23, 2014.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Vogels2008ey">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Vogels2008ey-marker">22</a>] Werner Vogels:
“<a href="http://queue.acm.org/detail.cfm?id=1466448">Eventually Consistent</a>,”
<em>ACM Queue</em>, volume 6, number 6, pages 14–19, October 2008.
<a href="http://dx.doi.org/10.1145/1466443.1466448">doi:10.1145/1466443.1466448</a></p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Terry2011vp">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Terry2011vp-marker">23</a>] Douglas B. Terry:
“<a href="http://research.microsoft.com/pubs/157411/ConsistencyAndBaseballReport.pdf">Replicated
Data Consistency Explained Through Baseball</a>,” Microsoft Research, Technical Report
MSR-TR-2011-137, October 2011.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Terry1994fp">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Terry1994fp-marker">24</a>] Douglas B. Terry, Alan J. Demers, Karin Petersen, et al.:
“<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.71.2269&amp;rep=rep1&amp;type=pdf">Session
Guarantees for Weakly Consistent Replicated Data</a>,” at <em>3rd International Conference
on Parallel and Distributed Information Systems</em> (PDIS), September 1994.
<a href="http://dx.doi.org/10.1109/PDIS.1994.331722">doi:10.1109/PDIS.1994.331722</a></p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Pratchett1991wj">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Pratchett1991wj-marker">25</a>] Terry Pratchett: <em>Reaper Man: A Discworld
Novel</em>. Victor Gollancz, 1991. ISBN: 978-0-575-04979-6</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="TungstenReplicator">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#TungstenReplicator-marker">26</a>] “<a href="http://tungsten-replicator.org/">Tungsten
Replicator</a>,” Continuent, Inc., 2014.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="PostgresBDR">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#PostgresBDR-marker">27</a>] “<a href="http://bdr-project.org/docs/next/index.html">BDR
0.10.0 Documentation</a>,” The PostgreSQL Global Development Group, <em>bdr-project.org</em>, 2015.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Hodges2012ue">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Hodges2012ue-marker">28</a>] Robert Hodges:
“<a href="http://scale-out-blog.blogspot.co.uk/2012/04/if-you-must-deploy-multi-master.html">If
You *Must* Deploy Multi-Master Replication, Read This First</a>,” <em>scale-out-blog.blogspot.co.uk</em>,
March 30, 2012.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Anderson2010wj">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Anderson2010wj-marker">29</a>] J. Chris Anderson, Jan Lehnardt, and Noah
Slater: <em>CouchDB: The Definitive Guide</em>. O’Reilly Media, 2010.
ISBN: 978-0-596-15589-6</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="AppJetInc2011um">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#AppJetInc2011um-marker">30</a>] AppJet, Inc.:
“<a href="https://github.com/ether/etherpad-lite/blob/e2ce9dc/doc/easysync/easysync-full-description.pdf">Etherpad
and EasySync Technical Manual</a>,” <em>github.com</em>, March 26, 2011.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="DayRichter2010tt">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#DayRichter2010tt-marker">31</a>] John Day-Richter:
“<a href="http://googledrive.blogspot.com/2010/09/whats-different-about-new-google-docs.html">What’s
Different About the New Google Docs: Making Collaboration Fast</a>,” <em>googledrive.blogspot.com</em>,
23 September 2010.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Kleppmann2016ve">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Kleppmann2016ve-marker">32</a>] Martin Kleppmann and Alastair R. Beresford:
“<a href="http://arxiv.org/abs/1608.03960">A Conflict-Free Replicated JSON Datatype</a>,”
arXiv:1608.03960, August 13, 2016.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Clement2011wc">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Clement2011wc-marker">33</a>] Frazer Clement:
“<a href="http://messagepassing.blogspot.co.uk/2011/10/eventual-consistency-detecting.html">Eventual
Consistency – Detecting Conflicts</a>,” <em>messagepassing.blogspot.co.uk</em>, October 20, 2011.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Hodges2013vb">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Hodges2013vb-marker">34</a>] Robert Hodges:
“<a href="https://www.percona.com/live/mysql-conference-2013/sessions/state-art-mysql-multi-master-replication">State
of the Art for MySQL Multi-Master Replication</a>,” at <em>Percona Live: MySQL Conference &amp;
Expo</em>, April 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Daily2013te_ch5">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Daily2013te_ch5-marker">35</a>] John Daily:
“<a href="http://basho.com/clocks-are-bad-or-welcome-to-distributed-systems/">Clocks Are Bad, or,
Welcome to the Wonderful World of Distributed Systems</a>,” <em>basho.com</em>, November 12, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Berton2016wh">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Berton2016wh-marker">36</a>] Riley Berton:
“<a href="http://sdf.org/~riley/blog/2016/01/04/is-bi-directional-replication-bdr-in-postgres-transactional/">Is
Bi-Directional Replication (BDR) in Postgres Transactional?</a>,” <em>sdf.org</em>, January 4, 2016.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="DeCandia2007ui_ch5">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#DeCandia2007ui_ch5-marker">37</a>] Giuseppe DeCandia, Deniz Hastorun, Madan Jampani, et al.:
“<a href="http://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf">Dynamo:
Amazon’s Highly Available Key-Value Store</a>,” at <em>21st ACM Symposium on Operating
Systems Principles</em> (SOSP), October 2007.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Shapiro2011wy">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Shapiro2011wy-marker">38</a>] Marc Shapiro, Nuno Preguiça, Carlos Baquero,
and Marek Zawirski: “<a href="http://hal.inria.fr/inria-00555588/">A Comprehensive Study of
Convergent and Commutative Replicated Data Types</a>,” INRIA Research Report no. 7506,
January 2011.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Elliott2013ua">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Elliott2013ua-marker">39</a>] Sam Elliott:
“<a href="https://speakerdeck.com/lenary/crdts-an-update-or-just-a-put">CRDTs: An UPDATE (or
Maybe Just a PUT)</a>,” at <em>RICON West</em>, October 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Brown2013wy">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Brown2013wy-marker">40</a>] Russell Brown:
“<a href="https://gist.github.com/russelldb/f92f44bdfb619e089a4d">A Bluffers Guide to CRDTs in
Riak</a>,” <em>gist.github.com</em>, October 28, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Farinier2015wj">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Farinier2015wj-marker">41</a>] Benjamin Farinier, Thomas Gazagnaire, and
Anil Madhavapeddy: “<a href="http://gazagnaire.org/pub/FGM15.pdf">Mergeable Persistent Data
Structures</a>,” at <em>26es Journées Francophones des Langages Applicatifs</em> (JFLA),
January 2015.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Sun1998vf">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Sun1998vf-marker">42</a>] Chengzheng Sun and Clarence Ellis:
“<a href="http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.53.933&amp;rep=rep1&amp;type=pdf">Operational
Transformation in Real-Time Group Editors: Issues, Algorithms, and Achievements</a>,” at
<em>ACM Conference on Computer Supported Cooperative Work</em> (CSCW), November 1998.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="HBase7709">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#HBase7709-marker">43</a>] Lars Hofhansl:
“<a href="https://issues.apache.org/jira/browse/HBASE-7709">HBASE-7709: Infinite Loop Possible in
Master/Master Replication</a>,” <em>issues.apache.org</em>, January 29, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Gifford1979if">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Gifford1979if-marker">44</a>] David K. Gifford:
“<a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.84.7698">Weighted Voting for Replicated Data</a>,”
at <em>7th ACM Symposium on Operating Systems Principles</em> (SOSP), December 1979.
<a href="http://dx.doi.org/10.1145/800215.806583">doi:10.1145/800215.806583</a></p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Howard2016tz_ch5">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Howard2016tz_ch5-marker">45</a>] Heidi Howard, Dahlia Malkhi, and Alexander Spiegelman:
“<a href="https://arxiv.org/abs/1608.06696">Flexible Paxos: Quorum Intersection Revisited</a>,”
<em>arXiv:1608.06696</em>, August 24, 2016.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Blomstedt2012vf">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Blomstedt2012vf-marker">46</a>] Joseph Blomstedt:
“<a href="http://lists.basho.com/pipermail/riak-users_lists.basho.com/2012-January/007157.html">Re:
Absolute Consistency</a>,” email to <em>riak-users</em> mailing list, <em>lists.basho.com</em>,
January 11, 2012.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Blomstedt2012vi">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Blomstedt2012vi-marker">47</a>] Joseph Blomstedt:
“<a href="https://vimeo.com/51973001">Bringing Consistency to Riak</a>,” at <em>RICON West</em>,
October 2012.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Bailis2014kt">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Bailis2014kt-marker">48</a>] Peter Bailis, Shivaram Venkataraman,
Michael J. Franklin, et al.:
“<a href="http://www.bailis.org/papers/pbs-cacm2014.pdf">Quantifying Eventual Consistency with PBS</a>,”
<em>Communications of the ACM</em>, volume 57, number 8, pages 93–102, August 2014.
<a href="http://dx.doi.org/10.1145/2632792">doi:10.1145/2632792</a></p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Ellis2012wm">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Ellis2012wm-marker">49</a>] Jonathan Ellis:
“<a href="http://www.datastax.com/dev/blog/modern-hinted-handoff">Modern Hinted Handoff</a>,”
<em>datastax.com</em>, December 11, 2012.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="VoldemortWiki">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#VoldemortWiki-marker">50</a>] “<a href="https://github.com/voldemort/voldemort/wiki">Project
Voldemort Wiki</a>,” <em>github.com</em>, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Cassandra20">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Cassandra20-marker">51</a>] “<a href="http://www.datastax.com/documentation/cassandra/2.0/index.html">Apache
Cassandra 2.0 Documentation</a>,” DataStax, Inc., 2014.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Riak2014vb">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Riak2014vb-marker">52</a>] “<a href="http://basho.com/assets/MultiDatacenter_Replication.pdf">Riak
Enterprise: Multi-Datacenter Replication</a>.” Technical whitepaper, Basho Technologies, Inc.,
September 2014.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Ellis2013ug">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Ellis2013ug-marker">53</a>] Jonathan Ellis:
“<a href="http://www.datastax.com/dev/blog/why-cassandra-doesnt-need-vector-clocks">Why
Cassandra Doesn’t Need Vector Clocks</a>,” <em>datastax.com</em>, September 2, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Lamport1978jq_ch5">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Lamport1978jq_ch5-marker">54</a>] Leslie Lamport:
“<a href="http://research.microsoft.com/en-US/um/people/Lamport/pubs/time-clocks.pdf">Time, Clocks,
and the Ordering of Events in a Distributed System</a>,” <em>Communications of the ACM</em>,
volume 21, number 7, pages 558–565, July 1978.
<a href="http://dx.doi.org/10.1145/359545.359563">doi:10.1145/359545.359563</a></p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Jacobson2014wa_ch5">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Jacobson2014wa_ch5-marker">55</a>] Joel Jacobson:
“<a href="http://blog.joeljacobson.com/riak-2-0-data-types/">Riak 2.0: Data Types</a>,”
<em>blog.joeljacobson.com</em>, March 23, 2014.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="ParkerJr1983jb">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#ParkerJr1983jb-marker">56</a>] D. Stott Parker Jr., Gerald J. Popek, Gerard Rudisin, et al.:
“<a href="http://zoo.cs.yale.edu/classes/cs426/2013/bib/parker83detection.pdf">Detection of Mutual
Inconsistency in Distributed Systems</a>,” <em>IEEE Transactions on Software Engineering</em>,
volume 9, number 3, pages 240–247, May 1983.
<a href="http://dx.doi.org/10.1109/TSE.1983.236733">doi:10.1109/TSE.1983.236733</a></p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Preguica2010wu">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Preguica2010wu-marker">57</a>] Nuno Preguiça, Carlos Baquero, Paulo Sérgio
Almeida, et al.: “<a href="http://arxiv.org/pdf/1011.5808v1.pdf">Dotted
Version Vectors: Logical Clocks for Optimistic Replication</a>,” arXiv:1011.5808, November 26,
2010.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Cribbs2014wc">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Cribbs2014wc-marker">58</a>] Sean Cribbs:
“<a href="https://www.youtube.com/watch?v=HHkKPdOi-ZU">A Brief History of Time in Riak</a>,”
at <em>RICON</em>, October 2014.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Brown2015wx">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Brown2015wx-marker">59</a>] Russell Brown:
“<a href="http://basho.com/posts/technical/vector-clocks-revisited-part-2-dotted-version-vectors/">Vector
Clocks Revisited Part 2: Dotted Version Vectors</a>,” <em>basho.com</em>, November 10, 2015.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Baquero2011ud">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Baquero2011ud-marker">60</a>] Carlos Baquero:
“<a href="https://haslab.wordpress.com/2011/07/08/version-vectors-are-not-vector-clocks/">Version
Vectors Are Not Vector Clocks</a>,” <em>haslab.wordpress.com</em>, July 8, 2011.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Schwarz1994gl">[<a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#Schwarz1994gl-marker">61</a>] Reinhard Schwarz and Friedemann Mattern:
“<a href="http://dcg.ethz.ch/lectures/hs08/seminar/papers/mattern4.pdf">Detecting Causal
Relationships in Distributed Computations: In Search of the Holy Grail</a>,” <em>Distributed
Computing</em>, volume 7, number 3, pages 149–174, March 1994.
<a href="http://dx.doi.org/10.1007/BF02277859">doi:10.1007/BF02277859</a></p></div></div></section><div class="annotator-outer annotator-viewer viewer annotator-hide">
  <ul class="annotator-widget annotator-listing"></ul>
</div><div class="annotator-modal-wrapper annotator-editor-modal annotator-editor annotator-hide">
	<div class="annotator-outer editor">
		<h2 class="title">Highlight</h2>
		<form class="annotator-widget">
			<ul class="annotator-listing">
			<li class="annotator-item"><textarea id="annotator-field-0" placeholder="Add a note using markdown (optional)" class="js-editor" maxlength="750"></textarea></li></ul>
			<div class="annotator-controls">
				<a class="link-to-markdown" href="https://daringfireball.net/projects/markdown/basics" target="_blank">?</a>
				<ul>
					<li class="delete annotator-hide"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#delete" class="annotator-delete-note button positive">Delete Note</a></li>
					<li class="save"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#save" class="annotator-save annotator-focus button positive">Save Note</a></li>
					<li class="cancel"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#cancel" class="annotator-cancel button">Cancel</a></li>
				</ul>
			</div>
		</form>
	</div>
</div><div class="annotator-modal-wrapper annotator-delete-confirm-modal" style="display: none;">
  <div class="annotator-outer">
    <h2 class="title">Highlight</h2>
      <a class="js-close-delete-confirm annotator-cancel close" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#close">Close</a>
      <div class="annotator-widget">
         <div class="delete-confirm">
            Are you sure you want to permanently delete this note?
         </div>
         <div class="annotator-controls">
            <a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#cancel" class="annotator-cancel button js-cancel-delete-confirm">No, I changed my mind</a>
            <a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#delete" class="annotator-delete button positive js-delete-confirm">Yes, delete it</a>
         </div>
       </div>
   </div>
</div><div class="annotator-adder" style="display: none;">
	<ul class="adders ">
		
		<li class="copy"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#">Copy</a></li>
		
		<li class="add-highlight"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#">Add Highlight</a></li>
		<li class="add-note"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#">
			
				Add Note
			
		</a></li>
		
	</ul>
</div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="/site/library/view/designing-data-intensive-applications/9781491903063/part02.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">II. Distributed Data</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch06.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">6. Partitioning</div>
        </a>
    
  
  </div>


        
    </section>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  




    
    
      <div id="js-subscribe-nag" class="subscribe-nag clearfix trial-panel t-subscribe-nag collapsed slideUp">
        
        
          
          
            <p class="usage-data">Find answers on the fly, or master something new. Subscribe today. <a href="https://www.safaribooksonline.com/subscribe/" class="ga-active-trial-subscribe-nag">See pricing options.</a></p>
          

          
        
        

      </div>

    
    



        
      </div>

      




  <footer class="pagefoot t-pagefoot" style="padding-bottom: 69px;">
    <a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#" class="icon-up"><div class="visuallyhidden">Back to top</div></a>
    <ul class="js-footer-nav">
      
        <li><a class="t-recommendations-footer" href="https://www.safaribooksonline.com/r/">Recommended</a></li>
      
      <li>
      <a class="t-queue-footer" href="https://www.safaribooksonline.com/playlists/">Playlists</a>
      </li>
      
        <li><a class="t-recent-footer" href="https://www.safaribooksonline.com/history/">History</a></li>
        <li><a class="t-topics-footer" href="https://www.safaribooksonline.com/topics?q=*&amp;limit=21">Topics</a></li>
      
      
        <li><a class="t-tutorials-footer" href="https://www.safaribooksonline.com/tutorials/">Tutorials</a></li>
      
      <li><a class="t-settings-footer js-settings" href="https://www.safaribooksonline.com/u/preferences/">Settings</a></li>
      <li class="full-support"><a href="https://www.oreilly.com/online-learning/support/">Support</a></li>
      <li><a href="https://www.safaribooksonline.com/apps/">Get the App</a></li>
      <li><a href="https://www.safaribooksonline.com/accounts/logout/">Sign Out</a></li>
    </ul>
    <span class="copyright">© 2018 <a href="https://www.safaribooksonline.com/" target="_blank">Safari</a>.</span>
    <a href="https://www.safaribooksonline.com/terms/">Terms of Service</a> /
    <a href="https://www.safaribooksonline.com/privacy/">Privacy Policy</a>
  </footer>




    
    
      <img src="https://www.oreilly.com/library/view/oreilly_set_cookie/" alt="" style="display:none;">
    
    <div style="width:0px; height:0px; display:none; visibility:hidden;" id="batBeacon0.2683401387441986"><img style="width:0px; height:0px; display:none; visibility:hidden;" id="batBeacon0.8550536587200452" width="0" height="0" alt="" src="https://bat.bing.com/action/0?ti=5794699&amp;Ver=2&amp;mid=8ded66fc-5e07-05c2-ad72-b993dbf75b7d&amp;pi=1200101525&amp;lg=en-US&amp;sw=1440&amp;sh=900&amp;sc=24&amp;tl=5.%20Replication%20-%20Designing%20Data-Intensive%20Applications&amp;p=https%3A%2F%2Fwww.safaribooksonline.com%2Flibrary%2Fview%2Fdesigning-data-intensive-applications%2F9781491903063%2Fch05.html&amp;r=&amp;evt=pageLoad&amp;msclkid=N&amp;rn=33204"></div>
    
  

<div class="annotator-notice"></div><div class="font-flyout" style="top: 201.007px; left: 1356px;"><div class="font-controls-panel">
	<div class="nightmodes">
		<ul>
			<li class="day"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#" id="day-mode" title="Day Mode">
				<i class="fa fa-sun-o"></i>
				<span>Day Mode</span></a></li>
			<li class="cloudy"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#" id="cloudy-mode" title="Cloudy Mode">
				<i class="fa fa-cloud"></i>
				<span>Cloud Mode</span>
			</a></li>
			<li class="night"><a href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#" id="night-mode" title="Night Mode">
				<i class="fa fa-moon-o"></i>
				<span>Night Mode</span>
			</a></li>
		</ul>
	</div>

	<div class="font-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-font left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-font-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-font right"></i>
		</div>
	</div>

	<div class="column-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-compress left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-column-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-expand right"></i>
		</div>
	</div>

	<a id="reset" class="button" href="/site/library/view/designing-data-intensive-applications/9781491903063/ch05.html#">Reset</a>
</div>
</div></body></html>