<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage"" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/clean-code/9780136083238/ch14.html"
data-csrf-cookie="csrfsafari"
data-highlight-privacy=""


  data-user-id="859452"
  data-user-uuid="4d373bec-fada-4717-9823-769db3ed3a36"
  data-username="dchen267"
  data-account-type="B2B"
  
  data-activated-trial-date="04/25/2016"


  data-archive="9780136083238"
  data-publishers="Prentice Hall"



  data-htmlfile-name="ch14.html"
  data-epub-title="Clean Code" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class=" js flexbox flexboxlegacy no-touch websqldatabase indexeddb history csscolumns csstransforms localstorage sessionstorage applicationcache svg inlinesvg zoom gr__safaribooksonline_com" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#" itemscope="" itemtype="http://schema.org/Book http://schema.org/ItemPage" "="" data-login-url="/accounts/login/" data-offline-url="/" data-url="/library/view/clean-code/9780136083238/ch14.html" data-csrf-cookie="csrfsafari" data-highlight-privacy="" data-user-id="859452" data-user-uuid="4d373bec-fada-4717-9823-769db3ed3a36" data-username="dchen267" data-account-type="B2B" data-activated-trial-date="04/25/2016" data-archive="9780136083238" data-publishers="Prentice Hall" data-htmlfile-name="ch14.html" data-epub-title="Clean Code" data-debug="0" data-testing="0"><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="author" content="Safari Books Online"><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://9780136083238"><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"><meta property="twitter:account_id" content="4503599627559754"><link rel="apple-touch-icon" href="https://www.safaribooksonline.com/static/images/apple-touch-icon.8cc2fd27400e.png"><link rel="shortcut icon" href="https://www.safaribooksonline.com/favicon.ico" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic" rel="stylesheet" type="text/css"><title>14. Successive Refinement - Clean Code</title><link rel="stylesheet" href="https://www.safaribooksonline.com/static/CACHE/css/e4b0fef39b55.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://www.safaribooksonline.com/static/css/annotator.min.fd58f69f4908.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book"></style><link rel="canonical" href="/Library/view/clean-code/9780136083238/ch14.html"><meta name="description" content="Chapter&nbsp;14.&nbsp;Successive Refinement Case Study of a Command-Line Argument Parser This chapter is a case study in successive refinement. You will see a module that started well but did ... "><meta property="og:title" content="14. Successive Refinement"><meta itemprop="isPartOf" content="/library/view/clean-code/9780136083238/"><meta itemprop="name" content="14. Successive Refinement"><meta property="og:url" itemprop="url" content="https://www.safaribooksonline.com/library/view/clean-code/9780136083238/ch14.html"><meta property="og:site_name" content="Safari"><meta property="og:image" itemprop="thumbnailUrl" content="https://www.safaribooksonline.com/library/cover/9780136083238/"><meta property="og:description" itemprop="description" content="Chapter&nbsp;14.&nbsp;Successive Refinement Case Study of a Command-Line Argument Parser This chapter is a case study in successive refinement. You will see a module that started well but did ... "><meta itemprop="inLanguage" content="en"><meta itemprop="publisher" content="Prentice Hall"><meta property="og:type" content="book"><meta property="og:book:isbn" itemprop="isbn" content="9780136083238"><meta property="og:book:author" itemprop="author" content="Robert C. Martin"><meta property="og:book:tag" itemprop="about" content="Agile"><meta property="og:book:tag" itemprop="about" content="Core Programming"><meta property="og:book:tag" itemprop="about" content="Lean"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@safari"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><!--[if lt IE 9]><script src="/static/js/src/respond.min.cf5c9b7980e5.js"></script><![endif]--><style id="annotator-dynamic-style">.annotator-adder, .annotator-outer, .annotator-notice {
  z-index: 100019;
}
.annotator-filter {
  z-index: 100009;
}</style></head>


<body class="reading sidenav nav-collapsed  scalefonts library" data-gr-c-s-loaded="true">

    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        




<a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#container" class="skip">Skip to content</a><header class="topbar t-topbar"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li class="t-logo"><a href="https://www.safaribooksonline.com/home/" class="l0 None safari-home nav-icn js-keyboard-nav-home"><svg width="20" height="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" version="1.1" fill="#4A3C31"><desc>Safari Home Icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M4 9.9L4 9.9 4 18 16 18 16 9.9 10 4 4 9.9ZM2.6 8.1L2.6 8.1 8.7 1.9 10 0.5 11.3 1.9 17.4 8.1 18 8.7 18 9.5 18 18.1 18 20 16.1 20 3.9 20 2 20 2 18.1 2 9.5 2 8.7 2.6 8.1Z"></path><rect x="10" y="12" width="3" height="7"></rect><rect transform="translate(18.121320, 10.121320) rotate(-315.000000) translate(-18.121320, -10.121320) " x="16.1" y="9.1" width="4" height="2"></rect><rect transform="translate(2.121320, 10.121320) scale(-1, 1) rotate(-315.000000) translate(-2.121320, -10.121320) " x="0.1" y="9.1" width="4" height="2"></rect></g></svg><span>Safari Home</span></a></li><li><a href="https://www.safaribooksonline.com/r/" class="t-recommendations-nav l0 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>recommendations icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M50 25C50 18.2 44.9 12.5 38.3 11.7 37.5 5.1 31.8 0 25 0 18.2 0 12.5 5.1 11.7 11.7 5.1 12.5 0 18.2 0 25 0 31.8 5.1 37.5 11.7 38.3 12.5 44.9 18.2 50 25 50 31.8 50 37.5 44.9 38.3 38.3 44.9 37.5 50 31.8 50 25ZM25 3.1C29.7 3.1 33.6 6.9 34.4 11.8 30.4 12.4 26.9 15.1 25 18.8 23.1 15.1 19.6 12.4 15.6 11.8 16.4 6.9 20.3 3.1 25 3.1ZM34.4 15.6C33.6 19.3 30.7 22.2 27.1 22.9 27.8 19.2 30.7 16.3 34.4 15.6ZM22.9 22.9C19.2 22.2 16.3 19.3 15.6 15.6 19.3 16.3 22.2 19.2 22.9 22.9ZM3.1 25C3.1 20.3 6.9 16.4 11.8 15.6 12.4 19.6 15.1 23.1 18.8 25 15.1 26.9 12.4 30.4 11.8 34.4 6.9 33.6 3.1 29.7 3.1 25ZM22.9 27.1C22.2 30.7 19.3 33.6 15.6 34.4 16.3 30.7 19.2 27.8 22.9 27.1ZM25 46.9C20.3 46.9 16.4 43.1 15.6 38.2 19.6 37.6 23.1 34.9 25 31.3 26.9 34.9 30.4 37.6 34.4 38.2 33.6 43.1 29.7 46.9 25 46.9ZM27.1 27.1C30.7 27.8 33.6 30.7 34.4 34.4 30.7 33.6 27.8 30.7 27.1 27.1ZM38.2 34.4C37.6 30.4 34.9 26.9 31.3 25 34.9 23.1 37.6 19.6 38.2 15.6 43.1 16.4 46.9 20.3 46.9 25 46.9 29.7 43.1 33.6 38.2 34.4Z" fill="currentColor"></path></g></svg><span>Recommended</span></a></li><li><a href="https://www.safaribooksonline.com/s/" class="t-queue-nav l0 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>queue icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 29.2C25.4 29.2 25.8 29.1 26.1 28.9L48.7 16.8C49.5 16.4 50 15.5 50 14.6 50 13.7 49.5 12.8 48.7 12.4L26.1 0.3C25.4-0.1 24.6-0.1 23.9 0.3L1.3 12.4C0.5 12.8 0 13.7 0 14.6 0 15.5 0.5 16.4 1.3 16.8L23.9 28.9C24.2 29.1 24.6 29.2 25 29.2ZM7.3 14.6L25 5.2 42.7 14.6 25 24 7.3 14.6ZM48.7 22.4L47.7 21.9 25 34.2 2.3 21.9 1.3 22.4C0.5 22.9 0 23.7 0 24.7 0 25.6 0.5 26.5 1.3 26.9L23.9 39.3C24.2 39.5 24.6 39.6 25 39.6 25.4 39.6 25.8 39.5 26.1 39.3L48.7 26.9C49.5 26.5 50 25.6 50 24.7 50 23.7 49.5 22.9 48.7 22.4ZM48.7 32.8L47.7 32.3 25 44.6 2.3 32.3 1.3 32.8C0.5 33.3 0 34.1 0 35.1 0 36 0.5 36.9 1.3 37.3L23.9 49.7C24.2 49.9 24.6 50 25 50 25.4 50 25.8 49.9 26.1 49.7L48.7 37.3C49.5 36.9 50 36 50 35.1 50 34.1 49.5 33.3 48.7 32.8Z" fill="currentColor"></path></g></svg><span>Queue</span></a></li><li class="search"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z" fill="currentColor"></path></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"></path></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li><a href="https://www.safaribooksonline.com/history/" class="t-recent-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>recent items icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 0C11.2 0 0 11.2 0 25 0 38.8 11.2 50 25 50 38.8 50 50 38.8 50 25 50 11.2 38.8 0 25 0ZM6.3 25C6.3 14.6 14.6 6.3 25 6.3 35.4 6.3 43.8 14.6 43.8 25 43.8 35.4 35.4 43.8 25 43.8 14.6 43.8 6.3 35.4 6.3 25ZM31.8 31.5C32.5 30.5 32.4 29.2 31.6 28.3L27.1 23.8 27.1 12.8C27.1 11.5 26.2 10.4 25 10.4 23.9 10.4 22.9 11.5 22.9 12.8L22.9 25.7 28.8 31.7C29.2 32.1 29.7 32.3 30.2 32.3 30.8 32.3 31.3 32 31.8 31.5Z" fill="currentColor"></path></g></svg><span>History</span></a></li><li><a href="https://www.safaribooksonline.com/topics" class="t-topics-link l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 55" version="1.1" fill="#4A3C31"><desc>topics icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 55L50 41.262 50 13.762 25 0 0 13.762 0 41.262 25 55ZM8.333 37.032L8.333 17.968 25 8.462 41.667 17.968 41.667 37.032 25 46.538 8.333 37.032Z" fill="currentColor"></path></g></svg><span>Topics</span></a></li><li><a href="https://www.safaribooksonline.com/tutorials/" class="l1 nav-icn t-tutorials-nav js-toggle-menu-item None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" version="1.1" fill="#4A3C31"><desc>tutorials icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M15.8 18.2C15.8 18.2 15.9 18.2 16 18.2 16.1 18.2 16.2 18.2 16.4 18.2 16.5 18.2 16.7 18.1 16.9 18 17 17.9 17.1 17.8 17.2 17.7 17.3 17.6 17.4 17.5 17.4 17.4 17.5 17.2 17.6 16.9 17.6 16.7 17.6 16.6 17.6 16.5 17.6 16.4 17.5 16.2 17.5 16.1 17.4 15.9 17.3 15.8 17.2 15.6 17 15.5 16.8 15.3 16.6 15.3 16.4 15.2 16.2 15.2 16 15.2 15.8 15.2 15.7 15.2 15.5 15.3 15.3 15.4 15.2 15.4 15.1 15.5 15 15.7 14.9 15.8 14.8 15.9 14.7 16 14.7 16.1 14.6 16.3 14.6 16.4 14.6 16.5 14.6 16.6 14.6 16.6 14.6 16.7 14.6 16.9 14.6 17 14.6 17.1 14.7 17.3 14.7 17.4 14.8 17.6 15 17.7 15.1 17.9 15.2 18 15.3 18 15.5 18.1 15.5 18.1 15.6 18.2 15.7 18.2 15.7 18.2 15.7 18.2 15.8 18.2L15.8 18.2ZM9.4 11.5C9.5 11.5 9.5 11.5 9.6 11.5 9.7 11.5 9.9 11.5 10 11.5 10.2 11.5 10.3 11.4 10.5 11.3 10.6 11.2 10.8 11.1 10.9 11 10.9 10.9 11 10.8 11.1 10.7 11.2 10.5 11.2 10.2 11.2 10 11.2 9.9 11.2 9.8 11.2 9.7 11.2 9.5 11.1 9.4 11 9.2 10.9 9.1 10.8 8.9 10.6 8.8 10.5 8.7 10.3 8.6 10 8.5 9.9 8.5 9.7 8.5 9.5 8.5 9.3 8.5 9.1 8.6 9 8.7 8.8 8.7 8.7 8.8 8.6 9 8.5 9.1 8.4 9.2 8.4 9.3 8.2 9.5 8.2 9.8 8.2 10 8.2 10.1 8.2 10.2 8.2 10.3 8.2 10.5 8.3 10.6 8.4 10.7 8.5 10.9 8.6 11.1 8.7 11.2 8.9 11.3 9 11.4 9.1 11.4 9.2 11.4 9.3 11.5 9.3 11.5 9.3 11.5 9.4 11.5 9.4 11.5L9.4 11.5ZM3 4.8C3.1 4.8 3.1 4.8 3.2 4.8 3.4 4.8 3.5 4.8 3.7 4.8 3.8 4.8 4 4.7 4.1 4.6 4.3 4.5 4.4 4.4 4.5 4.3 4.6 4.2 4.6 4.1 4.7 4 4.8 3.8 4.8 3.5 4.8 3.3 4.8 3.1 4.8 3 4.8 2.9 4.7 2.8 4.7 2.6 4.6 2.5 4.5 2.3 4.4 2.2 4.2 2.1 4 1.9 3.8 1.9 3.6 1.8 3.5 1.8 3.3 1.8 3.1 1.8 2.9 1.8 2.7 1.9 2.6 2 2.4 2.1 2.3 2.2 2.2 2.3 2.1 2.4 2 2.5 2 2.6 1.8 2.8 1.8 3 1.8 3.3 1.8 3.4 1.8 3.5 1.8 3.6 1.8 3.8 1.9 3.9 2 4 2.1 4.2 2.2 4.4 2.4 4.5 2.5 4.6 2.6 4.7 2.7 4.7 2.8 4.7 2.9 4.8 2.9 4.8 3 4.8 3 4.8 3 4.8L3 4.8ZM13.1 15.2C13.2 15.1 13.2 15.1 13.2 15.1 13.3 14.9 13.4 14.7 13.6 14.5 13.8 14.2 14.1 14 14.4 13.8 14.7 13.6 15.1 13.5 15.5 13.4 15.9 13.4 16.3 13.4 16.7 13.5 17.2 13.5 17.6 13.7 17.9 13.9 18.2 14.1 18.5 14.4 18.7 14.7 18.9 15 19.1 15.3 19.2 15.6 19.3 15.9 19.4 16.1 19.4 16.4 19.4 17 19.3 17.5 19.1 18.1 19 18.3 18.9 18.5 18.7 18.7 18.5 19 18.3 19.2 18 19.4 17.7 19.6 17.3 19.8 16.9 19.9 16.6 20 16.3 20 16 20 15.8 20 15.6 20 15.4 19.9 15.4 19.9 15.4 19.9 15.4 19.9 15.2 19.9 15 19.8 14.9 19.8 14.8 19.7 14.7 19.7 14.6 19.7 14.4 19.6 14.3 19.5 14.1 19.3 13.7 19.1 13.4 18.7 13.2 18.4 13.1 18.1 12.9 17.8 12.9 17.5 12.8 17.3 12.8 17.1 12.8 16.9L3.5 14.9C3.3 14.9 3.1 14.8 3 14.8 2.7 14.7 2.4 14.5 2.1 14.3 1.7 14 1.4 13.7 1.2 13.3 1 13 0.9 12.6 0.8 12.3 0.7 12 0.7 11.7 0.7 11.4 0.7 11 0.8 10.5 1 10.1 1.1 9.8 1.3 9.5 1.6 9.2 1.8 8.9 2.1 8.7 2.4 8.5 2.8 8.3 3.2 8.1 3.6 8.1 3.9 8 4.2 8 4.5 8 4.6 8 4.8 8 4.9 8.1L6.8 8.5C6.8 8.4 6.8 8.4 6.8 8.4 6.9 8.2 7.1 8 7.2 7.8 7.5 7.5 7.7 7.3 8 7.1 8.4 6.9 8.7 6.8 9.1 6.7 9.5 6.7 10 6.7 10.4 6.8 10.8 6.8 11.2 7 11.5 7.2 11.8 7.5 12.1 7.7 12.4 8 12.6 8.3 12.7 8.6 12.8 8.9 12.9 9.2 13 9.4 13 9.7 13 9.7 13 9.8 13 9.8 13.6 9.9 14.2 10.1 14.9 10.2 15 10.2 15 10.2 15.1 10.2 15.3 10.2 15.4 10.2 15.6 10.2 15.8 10.1 16 10 16.2 9.9 16.4 9.8 16.5 9.6 16.6 9.5 16.8 9.2 16.9 8.8 16.9 8.5 16.9 8.3 16.9 8.2 16.8 8 16.8 7.8 16.7 7.7 16.6 7.5 16.5 7.3 16.3 7.2 16.2 7.1 16 7 15.9 6.9 15.8 6.9 15.7 6.9 15.6 6.8 15.5 6.8L6.2 4.8C6.2 5 6 5.2 5.9 5.3 5.7 5.6 5.5 5.8 5.3 6 4.9 6.2 4.5 6.4 4.1 6.5 3.8 6.6 3.5 6.6 3.2 6.6 3 6.6 2.8 6.6 2.7 6.6 2.6 6.6 2.6 6.5 2.6 6.5 2.5 6.5 2.3 6.5 2.1 6.4 1.8 6.3 1.6 6.1 1.3 6 1 5.7 0.7 5.4 0.5 5 0.3 4.7 0.2 4.4 0.1 4.1 0 3.8 0 3.6 0 3.3 0 2.8 0.1 2.2 0.4 1.7 0.5 1.5 0.7 1.3 0.8 1.1 1.1 0.8 1.3 0.6 1.6 0.5 2 0.3 2.3 0.1 2.7 0.1 3.1 0 3.6 0 4 0.1 4.4 0.2 4.8 0.3 5.1 0.5 5.5 0.8 5.7 1 6 1.3 6.2 1.6 6.3 1.9 6.4 2.3 6.5 2.5 6.6 2.7 6.6 3 6.6 3 6.6 3.1 6.6 3.1 9.7 3.8 12.8 4.4 15.9 5.1 16.1 5.1 16.2 5.2 16.4 5.2 16.7 5.3 16.9 5.5 17.2 5.6 17.5 5.9 17.8 6.2 18.1 6.5 18.3 6.8 18.4 7.2 18.6 7.5 18.6 7.9 18.7 8.2 18.7 8.6 18.7 9 18.6 9.4 18.4 9.8 18.3 10.1 18.2 10.3 18 10.6 17.8 10.9 17.5 11.1 17.3 11.3 16.9 11.6 16.5 11.8 16 11.9 15.7 12 15.3 12 15 12 14.8 12 14.7 12 14.5 11.9 13.9 11.8 13.3 11.7 12.6 11.5 12.5 11.7 12.4 11.9 12.3 12 12.1 12.3 11.9 12.5 11.7 12.7 11.3 12.9 10.9 13.1 10.5 13.2 10.2 13.3 9.9 13.3 9.6 13.3 9.4 13.3 9.2 13.3 9 13.2 9 13.2 9 13.2 9 13.2 8.8 13.2 8.7 13.2 8.5 13.1 8.2 13 8 12.8 7.7 12.6 7.4 12.4 7.1 12 6.8 11.7 6.7 11.4 6.6 11.1 6.5 10.8 6.4 10.6 6.4 10.4 6.4 10.2 5.8 10.1 5.2 9.9 4.5 9.8 4.4 9.8 4.4 9.8 4.3 9.8 4.1 9.8 4 9.8 3.8 9.8 3.6 9.9 3.4 10 3.2 10.1 3 10.2 2.9 10.4 2.8 10.5 2.6 10.8 2.5 11.1 2.5 11.5 2.5 11.6 2.5 11.8 2.6 12 2.6 12.1 2.7 12.3 2.8 12.5 2.9 12.6 3.1 12.8 3.2 12.9 3.3 13 3.5 13.1 3.6 13.1 3.7 13.1 3.8 13.2 3.9 13.2L13.1 15.2 13.1 15.2Z" fill="currentColor"></path></g></svg><span>Tutorials</span></a></li><li class="nav-offers flyout-parent"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#" class="l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>offers icon</desc><path d="M10.8 43.7L0 39 0 10.2 13.6 4.6 23.3 8.7 11.5 13.5C11 13.6 10.8 13.9 10.8 14.3L10.8 43.7 10.8 43.7Z"></path><polygon points="12.3 44.4 25 50 38 44.3 38 14.7 25.2 9.4 12.3 14.7 12.3 44.4"></polygon><path d="M36.6 4.7L50 10.2 50 39 39.5 43.6 39.5 14.3C39.5 13.8 39.2 13.6 38.8 13.5L27 8.7 36.6 4.7 36.6 4.7Z"></path><polygon points="34.8 4 25 0 15.4 3.9 25.2 7.9 34.8 4"></polygon></svg><span>Offers</span></a><ul class="flyout"><li><a href="https://www.safaribooksonline.com/oreilly-conferences/" class="l2 nav-icn"><span>Conferences</span></a></li><li><a href="https://www.safaribooksonline.com/oreilly-newsletters/" class="l2 nav-icn"><span>Newsletter</span></a></li></ul></li><li class="nav-highlights"><a href="https://www.safaribooksonline.com/u/003o000000t5q9fAAA/" class="t-highlights-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 35" version="1.1" fill="#4A3C31"><desc>highlights icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M13.325 18.071L8.036 18.071C8.036 11.335 12.36 7.146 22.5 5.594L22.5 0C6.37 1.113 0 10.632 0 22.113 0 29.406 3.477 35 10.403 35 15.545 35 19.578 31.485 19.578 26.184 19.578 21.556 17.211 18.891 13.325 18.071L13.325 18.071ZM40.825 18.071L35.565 18.071C35.565 11.335 39.86 7.146 50 5.594L50 0C33.899 1.113 27.5 10.632 27.5 22.113 27.5 29.406 30.977 35 37.932 35 43.045 35 47.078 31.485 47.078 26.184 47.078 21.556 44.74 18.891 40.825 18.071L40.825 18.071Z" fill="currentColor"></path></g></svg><span>Highlights</span></a></li><li><a href="https://www.safaribooksonline.com/u/" class="t-settings-nav l1 js-settings nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z" fill="currentColor"></path></g></svg><span>Settings</span></a></li><li><a href="https://community.safaribooksonline.com/" class="l1 no-icon">Feedback</a></li><li><a href="https://www.safaribooksonline.com/accounts/logout/" class="l1 no-icon">Sign Out</a></li></ul><ul class="profile"><li><a href="https://www.safaribooksonline.com/u/" class="l2 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z" fill="currentColor"></path></g></svg><span>Settings</span></a></li><li><a href="https://community.safaribooksonline.com/" class="l2">Feedback</a></li><li><a href="https://www.safaribooksonline.com/accounts/logout/" class="l2">Sign Out</a></li></ul></div></li></ul></nav></header>


      </div>
      <div id="container" class="application">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Clean Code
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#" title="Search in archive" class="js-search-controls search-controls"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><button type="button" class="rec-fav ss-queue js-queue js-current-chapter-queue" data-queue-endpoint="/api/v1/book/9780136083238/chapter/ch14.html" data-for-analytics="9780136083238:ch14.html"><span>Add to Queue</span></button></li><li class="js-font-control-panel font-control-activator"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a class="twitter share-button t-twitter" target="_blank" aria-label="Share this section on Twitter" title="Share this section on Twitter" href="https://twitter.com/share?url=https://www.safaribooksonline.com/library/view/clean-code/9780136083238/ch14.html&amp;text=Clean%20Code&amp;via=safari"><span>Twitter</span></a></li><li><a class="facebook share-button t-facebook" target="_blank" aria-label="Share this section on Facebook" title="Share this section on Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://www.safaribooksonline.com/library/view/clean-code/9780136083238/ch14.html"><span>Facebook</span></a></li><li><a class="googleplus share-button t-googleplus" target="_blank" aria-label="Share this secton on Google Plus" title="Share this secton on Google Plus" href="https://plus.google.com/share?url=https://www.safaribooksonline.com/library/view/clean-code/9780136083238/ch14.html"><span>Google Plus</span></a></li><li><a class="email share-button t-email" aria-label="Share this section via email" title="Share this section via email" href="mailto:?subject=Safari:%2014.%20Successive%20Refinement&amp;body=https://www.safaribooksonline.com/library/view/clean-code/9780136083238/ch14.html%0D%0Afrom%20Clean%20Code%0D%0A"><span>Email</span></a></li></ul></li>
      </ul>
    </div>

    <section role="document">
      
	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="/Library/view/clean-code/9780136083238/ch13.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">13. Concurrency</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="/Library/view/clean-code/9780136083238/ch15.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">15. JUnit Internals</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div class="annotator-wrapper"><div class="chapter"><div class="titlepage"><div><div><h1 class="title"><a id="ch14"></a>Chapter&nbsp;14.&nbsp;Successive Refinement</h1></div></div></div><p><a id="iddle1241" class="indexterm"></a>Case Study of a Command-Line Argument Parser</p><div class="mediaobject"><a id="f193fig01"></a><img src="https://www.safaribooksonline.com/library/view/clean-code/9780136083238/graphics/14_1fig_martin.jpg" width="404" alt="Successive Refinement" height="354" data-mfp-src="/library/view/clean-code/9780136083238/graphics/14_1fig_martin.jpg"></div><p>This chapter is a case study in successive refinement. You will see a module that started well but did not scale. Then you will see how the module was refactored and cleaned.</p><p>Most of us have had to parse command-line arguments from time to time. If we don’t have a convenient utility, then we simply walk the array of strings that is passed into the <code class="literal">main</code> function. There are several good utilities available from various sources, <a id="iddle1054" class="indexterm"></a><a id="iddle1055" class="indexterm"></a><a id="iddle1117" class="indexterm"></a><a id="iddle1527" class="indexterm"></a><a id="iddle1700" class="indexterm"></a><a id="iddle2092" class="indexterm"></a><a id="iddle2208" class="indexterm"></a>but none of them do exactly what I want. So, of course, I decided to write my own. I call it: <code class="literal">Args</code>.</p><p><code class="literal">Args</code> is very simple to use. You simply construct the <code class="literal">Args</code> class with the input arguments and a format string, and then query the <code class="literal">Args</code> instance for the values of the arguments. Consider the following simple example:</p><div class="example"><a id="ch14ex01"></a><p class="title"><strong>Example&nbsp;14-1.&nbsp;<code class="literal">Simple use of Args</code></strong></p><div class="example-contents"><pre class="programlisting">  public static void main(String[] args) {
    try {
      Args arg = new Args("l,p#,d*", args);
      boolean logging = arg.getBoolean('l');
      int port = arg.getInt('p');
      String directory = arg.getString('d');
      executeApplication(logging, port, directory);
    } catch (ArgsException e) {
      System.out.printf("Argument error: %s\n", e.errorMessage());
    }
  }</pre></div></div><p>You can see how simple this is. We just create an instance of the <code class="literal">Args</code> class with two parameters. The first parameter is the format, or <span class="emphasis"><em>schema,</em></span> string: <code class="literal">"l,p#,d*</code>.<code class="literal">"</code> It defines three command-line arguments. The first, <code class="literal">–l</code>, is a boolean argument. The second, <code class="literal">-p</code>, is an integer argument. The third, <code class="literal">-d</code>, is a string argument. The second parameter to the <code class="literal">Args</code> constructor is simply the array of command-line argument passed into <code class="literal">main</code>.</p><p>If the constructor returns without throwing an <code class="literal">ArgsException</code>, then the incoming command-line was parsed, and the <code class="literal">Args</code> instance is ready to be queried. Methods like <code class="literal">getBoolean</code>, <code class="literal">getInteger</code>, and <code class="literal">getString</code> allow us to access the values of the arguments by their names.</p><p>If there is a problem, either in the format string or in the command-line arguments themselves, an <code class="literal">ArgsException</code> will be thrown. A convenient description of what went wrong can be retrieved from the <code class="literal">errorMessage</code> method of the exception.</p><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lev1sec1"></a>Args Implementation</h1></div></div></div><p><a class="link" href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ch14ex02">Listing 14-2</a> is the implementation of the <code class="literal">Args</code> class. Please read it very carefully. I worked hard on the style and structure and hope it is worth emulating.</p><div class="example"><a id="ch14ex02"></a><p class="title"><strong>Example&nbsp;14-2.&nbsp;<code class="literal">Args.java</code></strong></p><div class="example-contents"><pre class="programlisting">package com.objectmentor.utilities.args;

import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;
import java.util.*;

public class Args {
  private Map&lt;Character, ArgumentMarshaler&gt; marshalers;
  private Set&lt;Character&gt; argsFound;
  private ListIterator&lt;String&gt; currentArgument;

  public Args(String schema, String[] args) throws ArgsException {
    marshalers = new HashMap&lt;Character, ArgumentMarshaler&gt;();
    argsFound = new HashSet&lt;Character&gt;();

    parseSchema(schema);
    parseArgumentStrings(Arrays.asList(args));
  }

  private void parseSchema(String schema) throws ArgsException {
    for (String element : schema.split(","))
      if (element.length() &gt; 0)
        parseSchemaElement(element.trim());
  }

  private void parseSchemaElement(String element) throws ArgsException {
    char elementId = element.charAt(0);
    String elementTail = element.substring(1);
    validateSchemaElementId(elementId);
    if (elementTail.length() == 0)
      marshalers.put(elementId, new BooleanArgumentMarshaler());
    else if (elementTail.equals("*"))
      marshalers.put(elementId, new StringArgumentMarshaler());
    else if (elementTail.equals("#"))
      marshalers.put(elementId, new IntegerArgumentMarshaler());
    else if (elementTail.equals("##"))
      marshalers.put(elementId, new DoubleArgumentMarshaler());
    else if (elementTail.equals("[*]"))
      marshalers.put(elementId, new StringArrayArgumentMarshaler());
    else
      throw new ArgsException(INVALID_ARGUMENT_FORMAT, elementId, elementTail);
  }

  private void validateSchemaElementId(char elementId) throws ArgsException {
    if (!Character.isLetter(elementId))
      throw new ArgsException(INVALID_ARGUMENT_NAME, elementId, null);
  }

  private void parseArgumentStrings(List&lt;String&gt; argsList) throws ArgsException
  {
    for (currentArgument = argsList.listIterator(); currentArgument.hasNext();)
    {
      String argString = currentArgument.next();
      if (argString.startsWith("-")) {
        parseArgumentCharacters(argString.substring(1));
      } else {
        currentArgument.previous();
        break;
      }
    }
  }
  private void parseArgumentCharacters(String argChars) throws ArgsException {
    for (int i = 0; i &lt; argChars.length(); i++)
      parseArgumentCharacter(argChars.charAt(i));
  }

  private void parseArgumentCharacter(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null) {
      throw new ArgsException(UNEXPECTED_ARGUMENT, argChar, null);
    } else {
      argsFound.add(argChar);
      try {
        m.set(currentArgument);
      } catch (ArgsException e) {
        e.setErrorArgumentId(argChar);
        throw e;
      }
    }
  }

  public boolean has(char arg) {
    return argsFound.contains(arg);
  }

  public int nextArgument() {
    return currentArgument.nextIndex();
  }

  public boolean getBoolean(char arg) {
    return BooleanArgumentMarshaler.getValue(marshalers.get(arg));
  }

  public String getString(char arg) {
    return StringArgumentMarshaler.getValue(marshalers.get(arg));
  }

  public int getInt(char arg) {
    return IntegerArgumentMarshaler.getValue(marshalers.get(arg));
  }

  public double getDouble(char arg) {
    return DoubleArgumentMarshaler.getValue(marshalers.get(arg));
  }

  public String[] getStringArray(char arg) {
    return StringArrayArgumentMarshaler.getValue(marshalers.get(arg));
  }
}</pre></div></div><p>Notice that you can read this code from the top to the bottom without a lot of jumping around or looking ahead. The one thing you may have had to look ahead for is the definition of <code class="literal">ArgumentMarshaler</code>, which I left out intentionally. Having read this code carefully, you should understand what the <code class="literal">ArgumentMarshaler</code> interface is and what its derivatives do. I’ll show a few of them to you now (<a class="link" href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ch14ex03">Listing 14-3</a> through <a class="link" href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ch14ex06">Listing 14-6</a>).<a id="iddle1072" class="indexterm"></a></p><div class="example"><a id="ch14ex03"></a><p class="title"><strong>Example&nbsp;14-3.&nbsp;<code class="literal">ArgumentMarshaler.java</code></strong></p><div class="example-contents"><pre class="programlisting">public interface ArgumentMarshaler {
  void set(Iterator&lt;String&gt; currentArgument) throws ArgsException;
}</pre></div></div><div class="example"><a id="ch14ex04"></a><p class="title"><strong>Example&nbsp;14-4.&nbsp;<code class="literal">BooleanArgumentMarshaler.java</code></strong></p><div class="example-contents"><pre class="programlisting">public class BooleanArgumentMarshaler implements ArgumentMarshaler {
  private boolean booleanValue = false;

  public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {
    booleanValue = true;
  }

  public static boolean getValue(ArgumentMarshaler am) {
    if (am != null &amp;&amp; am instanceof BooleanArgumentMarshaler)
      return ((BooleanArgumentMarshaler) am).booleanValue;
    else
      return false;
  }
}</pre></div></div><div class="example"><a id="ch14ex05"></a><p class="title"><strong>Example&nbsp;14-5.&nbsp;<code class="literal">StringArgumentMarshaler.java</code></strong></p><div class="example-contents"><pre class="programlisting">import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;

public class StringArgumentMarshaler implements ArgumentMarshaler {
  private String stringValue = "";

  public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {
    try {
      stringValue = currentArgument.next();
    } catch (NoSuchElementException e) {
      throw new ArgsException(MISSING_STRING);
    }
  }

  public static String getValue(ArgumentMarshaler am) {
    if (am != null &amp;&amp; am instanceof StringArgumentMarshaler)
      return ((StringArgumentMarshaler) am).stringValue;
    else
      return "";
  }
}</pre></div></div><p></p><div class="example"><a id="ch14ex06"></a><p class="title"><strong>Example&nbsp;14-6.&nbsp;<code class="literal">IntegerArgumentMarshaler.java</code></strong></p><div class="example-contents"><pre class="programlisting">import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;

public class IntegerArgumentMarshaler implements ArgumentMarshaler {
  private int intValue = 0;

  public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {
    String parameter = null;
    try {
      parameter = currentArgument.next();
      intValue = Integer.parseInt(parameter);
    } catch (NoSuchElementException e) {
      throw new ArgsException(MISSING_INTEGER);
    } catch (NumberFormatException e) {
      throw new ArgsException(INVALID_INTEGER, parameter);
    }
  }

  public static int getValue(ArgumentMarshaler am) {
    if (am != null &amp;&amp; am instanceof IntegerArgumentMarshaler)
      return ((IntegerArgumentMarshaler) am).intValue;
    else
      return 0;
  }
}</pre></div></div><p><a id="iddle1058" class="indexterm"></a><a id="iddle1498" class="indexterm"></a>The other <code class="literal">ArgumentMarshaler</code> derivatives simply replicate this pattern for <code class="literal">doubles</code> and <code class="literal">String</code> arrays and would serve to clutter this chapter. I’ll leave them to you as an exercise.</p><p>One other bit of information might be troubling you: the definition of the error code constants. They are in the <code class="literal">ArgsException</code> class (<a class="link" href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ch14ex07">Listing 14-7</a>).</p><div class="example"><a id="ch14ex07"></a><p class="title"><strong>Example&nbsp;14-7.&nbsp;<code class="literal">ArgsException.java</code></strong></p><div class="example-contents"><pre class="programlisting">import static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;

public class ArgsException extends Exception {
  private char errorArgumentId = '\0';
  private String errorParameter = null;
  private ErrorCode errorCode = OK;

  public ArgsException() {}

  public ArgsException(String message) {super(message);}

  public ArgsException(ErrorCode errorCode) {
    this.errorCode = errorCode;
  }

  public ArgsException(ErrorCode errorCode, String errorParameter) {
    this.errorCode = errorCode;
    this.errorParameter = errorParameter;
  }
  public ArgsException(ErrorCode errorCode,
                       char errorArgumentId, String errorParameter) {
    this.errorCode = errorCode;
    this.errorParameter = errorParameter;
    this.errorArgumentId = errorArgumentId;
  }

  public char getErrorArgumentId() {
    return errorArgumentId;
  }

  public void setErrorArgumentId(char errorArgumentId) {
    this.errorArgumentId = errorArgumentId;
  }

  public String getErrorParameter() {
    return errorParameter;
  }

  public void setErrorParameter(String errorParameter) {
    this.errorParameter = errorParameter;
  }

  public ErrorCode getErrorCode() {
    return errorCode;
  }

  public void setErrorCode(ErrorCode errorCode) {
    this.errorCode = errorCode;
  }

  public String errorMessage() {
    switch (errorCode) {
      case OK:
        return "TILT: Should not get here.";
      case UNEXPECTED_ARGUMENT:
        return String.format("Argument -%c unexpected.", errorArgumentId);
      case MISSING_STRING:
        return String.format("Could not find string parameter for -%c.",
                             errorArgumentId);
      case INVALID_INTEGER:
        return String.format("Argument -%c expects an integer but was '%s'.",
                             errorArgumentId, errorParameter);
      case MISSING_INTEGER:
        return String.format("Could not find integer parameter for -%c.",
                             errorArgumentId);
      case INVALID_DOUBLE:
        return String.format("Argument -%c expects a double but was '%s'.",
                             errorArgumentId, errorParameter);
      case MISSING_DOUBLE:
        return String.format("Could not find double parameter for -%c.",
                             errorArgumentId);
      case INVALID_ARGUMENT_NAME:
        return String.format("'%c' is not a valid argument name.",
                             errorArgumentId);
      case INVALID_ARGUMENT_FORMAT:
        return String.format("'%s' is not a valid argument format.",
                             errorParameter);
    }
    return "";
  }

  public enum ErrorCode {
    OK, INVALID_ARGUMENT_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,
    MISSING_STRING,
    MISSING_INTEGER, INVALID_INTEGER,
    MISSING_DOUBLE, INVALID_DOUBLE}
}</pre></div></div><p><a id="iddle1067" class="indexterm"></a><a id="iddle1448" class="indexterm"></a><a id="iddle1731" class="indexterm"></a><a id="iddle2084" class="indexterm"></a>It’s remarkable how much code is required to flesh out the details of this simple concept. One of the reasons for this is that we are using a particularly wordy language. Java, being a statically typed language, requires a lot of words in order to satisfy the type system. In a language like Ruby, Python, or Smalltalk, this program is much smaller.<a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ftn.ch14fn01" class="footnote" id="ch14fn01"><sup class="footnote">[1]</sup></a></p><p>Please read the code over one more time. Pay special attention to the way things are named, the size of the functions, and the formatting of the code. If you are an experienced programmer, you may have some quibbles here and there with various parts of the style or structure. Overall, however, I hope you conclude that this program is nicely written and has a clean structure.</p><p>For example, it should be obvious how you would add a new argument type, such as a date argument or a complex number argument, and that such an addition would require a trivial amount of effort. In short, it would simply require a new derivative of <code class="literal">ArgumentMarshaler</code>, a new <code class="literal">getXXX</code> function, and a new case statement in the <code class="literal">parseSchemaElement</code> function. There would also probably be a new <code class="literal">ArgsException.ErrorCode</code> and a new error message.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lev2sec1"></a>How Did I Do This?</h2></div></div></div><p>Let me set your mind at rest. I did not simply write this program from beginning to end in its current form. More importantly, I am not expecting you to be able to write clean and elegant programs in one pass. If we have learned anything over the last couple of decades, it is that programming is a craft more than it is a science. To write clean code, you must first write dirty code <span class="emphasis"><em>and then clean it</em></span>.</p><p>This should not be a surprise to you. We learned this truth in grade school when our teachers tried (usually in vain) to get us to write rough drafts of our compositions. The process, they told us, was that we should write a rough draft, then a second draft, then several subsequent drafts until we had our final version. Writing clean compositions, they tried to tell us, is a matter of successive refinement.</p><p><a id="iddle1056" class="indexterm"></a><a id="iddle2029" class="indexterm"></a><a id="iddle2421" class="indexterm"></a>Most freshman programmers (like most grade-schoolers) don’t follow this advice particularly well. They believe that the primary goal is to get the program working. Once it’s “working,” they move on to the next task, leaving the “working” program in whatever state they finally got it to “work.” Most seasoned programmers know that this is professional suicide.</p></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lev1sec2"></a>Args: The Rough Draft</h1></div></div></div><p><a class="link" href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ch14ex08">Listing 14-8</a> shows an earlier version of the <code class="literal">Args</code> class. It “works.” And it’s messy.</p><div class="example"><a id="ch14ex08"></a><p class="title"><strong>Example&nbsp;14-8.&nbsp;<code class="literal">Args.java (first draft)</code></strong></p><div class="example-contents"><pre class="programlisting">import java.text.ParseException;
import java.util.*;

public class Args {
  private String schema;
  private String[] args;
  private boolean valid = true;
  private Set&lt;Character&gt; unexpectedArguments = new TreeSet&lt;Character&gt;();
  private Map&lt;Character, Boolean&gt; booleanArgs =
    new HashMap&lt;Character, Boolean&gt;();
  private Map&lt;Character, String&gt; stringArgs = new HashMap&lt;Character, String&gt;();
  private Map&lt;Character, Integer&gt; intArgs = new HashMap&lt;Character, Integer&gt;();
  private Set&lt;Character&gt; argsFound = new HashSet&lt;Character&gt;();
  private int currentArgument;
  private char errorArgumentId = '\0';
  private String errorParameter = "TILT";
  private ErrorCode errorCode = ErrorCode.OK;

  private enum ErrorCode {
    OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT}

  public Args(String schema, String[] args) throws ParseException {
    this.schema = schema;
    this.args = args;
    valid = parse();
  }

  private boolean parse() throws ParseException {
    if (schema.length() == 0 &amp;&amp; args.length == 0)
      return true;
    parseSchema();
    try {
      parseArguments();
    } catch (ArgsException e) {
    }
    return valid;
  }

  private boolean parseSchema() throws ParseException {
    for (String element : schema.split(",")) {
      if (element.length() &gt; 0) {
        String trimmedElement = element.trim();
        parseSchemaElement(trimmedElement);
      }
    }
    return true;
  }

  private void parseSchemaElement(String element) throws ParseException {
    char elementId = element.charAt(0);
    String elementTail = element.substring(1);
    validateSchemaElementId(elementId);
    if (isBooleanSchemaElement(elementTail))
      parseBooleanSchemaElement(elementId);
    else if (isStringSchemaElement(elementTail))
      parseStringSchemaElement(elementId);
    else if (isIntegerSchemaElement(elementTail)) {
      parseIntegerSchemaElement(elementId);
    } else {
      throw new ParseException(
        String.format("Argument: %c has invalid format: %s.",
                      elementId, elementTail), 0);
    }
  }

  private void validateSchemaElementId(char elementId) throws ParseException {
    if (!Character.isLetter(elementId)) {
      throw new ParseException(
        "Bad character:" + elementId + "in Args format: " + schema, 0);
    }
  }

  private void parseBooleanSchemaElement(char elementId) {
    booleanArgs.put(elementId, false);
  }

  private void parseIntegerSchemaElement(char elementId) {
    intArgs.put(elementId, 0);
  }

  private void parseStringSchemaElement(char elementId) {
    stringArgs.put(elementId, "");
  }

  private boolean isStringSchemaElement(String elementTail) {
    return elementTail.equals("*");
  }

  private boolean isBooleanSchemaElement(String elementTail) {
    return elementTail.length() == 0;
  }

  private boolean isIntegerSchemaElement(String elementTail) {
    return elementTail.equals("#");
  }
  private boolean parseArguments() throws ArgsException {
    for (currentArgument = 0; currentArgument &lt; args.length; currentArgument++)
    {
      String arg = args[currentArgument];
      parseArgument(arg);
    }
    return true;
  }

  private void parseArgument(String arg) throws ArgsException {
    if (arg.startsWith("-"))
      parseElements(arg);
  }

  private void parseElements(String arg) throws ArgsException {
    for (int i = 1; i &lt; arg.length(); i++)
      parseElement(arg.charAt(i));
  }

  private void parseElement(char argChar) throws ArgsException {
    if (setArgument(argChar))
      argsFound.add(argChar);
    else {
      unexpectedArguments.add(argChar);
      errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
      valid = false;
    }
  }

  private boolean setArgument(char argChar) throws ArgsException {
    if (isBooleanArg(argChar))
      setBooleanArg(argChar, true);
    else if (isStringArg(argChar))
      setStringArg(argChar);
    else if (isIntArg(argChar))
      setIntArg(argChar);
    else
      return false;

    return true;
  }

  private boolean isIntArg(char argChar) {return intArgs.containsKey(argChar);}

  private void setIntArg(char argChar) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
      parameter = args[currentArgument];
      intArgs.put(argChar, new Integer(parameter));
    } catch (ArrayIndexOutOfBoundsException e) {
      valid = false;
      errorArgumentId = argChar;
      errorCode = ErrorCode.MISSING_INTEGER;
      throw new ArgsException();
    } catch (NumberFormatException e) {
      valid = false;
      errorArgumentId = argChar;
      errorParameter = parameter;
      errorCode = ErrorCode.INVALID_INTEGER;
      throw new ArgsException();
    }
  }

  private void setStringArg(char argChar) throws ArgsException {
    currentArgument++;
    try {
      stringArgs.put(argChar, args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
      valid = false;
      errorArgumentId = argChar;
      errorCode = ErrorCode.MISSING_STRING;
      throw new ArgsException();
    }
  }

  private boolean isStringArg(char argChar) {
    return stringArgs.containsKey(argChar);
  }

  private void setBooleanArg(char argChar, boolean value) {
    booleanArgs.put(argChar, value);
  }

  private boolean isBooleanArg(char argChar) {
    return booleanArgs.containsKey(argChar);
  }

  public int cardinality() {
    return argsFound.size();
  }

  public String usage() {
    if (schema.length() &gt; 0)
      return "-[" + schema + "]";
    else
      return "";
  }

  public String errorMessage() throws Exception {
    switch (errorCode) {
      case OK:
        throw new Exception("TILT: Should not get here.");
      case UNEXPECTED_ARGUMENT:
        return unexpectedArgumentMessage();
      case MISSING_STRING:
        return String.format("Could not find string parameter for -%c.",
                             errorArgumentId);
      case INVALID_INTEGER:
        return String.format("Argument -%c expects an integer but was '%s'.",
                             errorArgumentId, errorParameter);
      case MISSING_INTEGER:
        return String.format("Could not find integer parameter for -%c.",
                             errorArgumentId);
    }
    return "";
  }

  private String unexpectedArgumentMessage() {
    StringBuffer message = new StringBuffer("Argument(s) -");
    for (char c : unexpectedArguments) {
      message.append(c);
    }
    message.append(" unexpected.");

    return message.toString();
  }

  private boolean falseIfNull(Boolean b) {
    return b != null &amp;&amp; b;
  }

  private int zeroIfNull(Integer i) {
    return i == null ? 0 : i;
  }

  private String blankIfNull(String s) {
    return s == null ? "" : s;
  }

  public String getString(char arg) {
    return blankIfNull(stringArgs.get(arg));
  }

  public int getInt(char arg) {
    return zeroIfNull(intArgs.get(arg));
  }

  public boolean getBoolean(char arg) {
    return falseIfNull(booleanArgs.get(arg));
  }

  public boolean has(char arg) {
    return argsFound.contains(arg);
  }

  public boolean isValid() {
    return valid;
  }

  private class ArgsException extends Exception {
  }
}</pre></div></div><p>I hope your initial reaction to this mass of code is “I’m certainly glad he didn’t leave it like that!” If you feel like this, then remember that’s how other people are going to feel about code that you leave in rough-draft form.</p><p>Actually “rough draft” is probably the kindest thing you can say about this code. It’s clearly a work in progress. The sheer number of instance variables is daunting. The odd strings like <code class="literal">"TILT</code>,<code class="literal">"</code> the <code class="literal">HashSets</code> and <code class="literal">TreeSets</code>, and the <code class="literal">try-catch-catch</code> blocks all add up to a festering pile.</p><p>I had not wanted to write a festering pile. Indeed, I was trying to keep things reasonably well organized. You can probably tell that from my choice of function and variable names and the fact that there is a crude structure to the program. But, clearly, I had let the problem get away from me.</p><p>The mess built gradually. Earlier versions had not been nearly so nasty. For example, <a class="link" href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ch14ex09">Listing 14-9</a> shows an earlier version in which only <code class="literal">Boolean</code> arguments were working.</p><div class="example"><a id="ch14ex09"></a><p class="title"><strong>Example&nbsp;14-9.&nbsp;<code class="literal">Args.java (Boolean only)</code></strong></p><div class="example-contents"><pre class="programlisting">package com.objectmentor.utilities.getopts;

import java.util.*;

public class Args {
  private String schema;
  private String[] args;
  private boolean valid;
  private Set&lt;Character&gt; unexpectedArguments = new TreeSet&lt;Character&gt;();
  private Map&lt;Character, Boolean&gt; booleanArgs =
    new HashMap&lt;Character, Boolean&gt;();
  private int numberOfArguments = 0;

  public Args(String schema, String[] args) {
    this.schema = schema;
    this.args = args;
    valid = parse();
  }

  public boolean isValid() {
    return valid;
  }

  private boolean parse() {
    if (schema.length() == 0 &amp;&amp; args.length == 0)
      return true;
    parseSchema();
    parseArguments();
    return unexpectedArguments.size() == 0;
  }

  private boolean parseSchema() {
    for (String element : schema.split(",")) {
      parseSchemaElement(element);
    }
    return true;
  }

  private void parseSchemaElement(String element) {
    if (element.length() == 1) {
      parseBooleanSchemaElement(element);
    }
  }

  private void parseBooleanSchemaElement(String element) {
    char c = element.charAt(0);
    if (Character.isLetter(c)) {
      booleanArgs.put(c, false);
    }
  }

  private boolean parseArguments() {
    for (String arg : args)
      parseArgument(arg);
    return true;
  }

  private void parseArgument(String arg) {
    if (arg.startsWith("-"))
      parseElements(arg);
  }

  private void parseElements(String arg) {
    for (int i = 1; i &lt; arg.length(); i++)
      parseElement(arg.charAt(i));
  }

  private void parseElement(char argChar) {
    if (isBoolean(argChar)) {
      numberOfArguments++;
      setBooleanArg(argChar, true);
    } else
      unexpectedArguments.add(argChar);
  }

  private void setBooleanArg(char argChar, boolean value) {
    booleanArgs.put(argChar, value);
  }

  private boolean isBoolean(char argChar) {
    return booleanArgs.containsKey(argChar);
  }

  public int cardinality() {
    return numberOfArguments;
  }

  public String usage() {
    if (schema.length() &gt; 0)
       return "-["+schema+"]";
    else
      return "";
  }

  public String errorMessage() {
    if (unexpectedArguments.size() &gt; 0) {
      return unexpectedArgumentMessage();
    } else
      return "";
  }

  private String unexpectedArgumentMessage() {
    StringBuffer message = new StringBuffer("Argument(s) -");
    for (char c : unexpectedArguments) {
      message.append(c);
    }
    message.append(" unexpected.");

    return message.toString();
  }

  public boolean getBoolean(char arg) {
    return booleanArgs.get(arg);
  }
}</pre></div></div><p><a id="iddle1069" class="indexterm"></a><a id="iddle2209" class="indexterm"></a>Although you can find plenty to complain about in this code, it’s really not that bad. It’s compact and simple and easy to understand. However, within this code it is easy to see the seeds of the later festering pile. It’s quite clear how this grew into the latter mess.</p><p>Notice that the latter mess has only two more argument types than this: <code class="literal">String</code> and <code class="literal">integer</code>. The addition of just two more argument types had a massively negative impact on the code. It converted it from something that would have been reasonably maintainable into something that I would expect to become riddled with bugs and warts.</p><p>I added the two argument types incrementally. First, I added the <code class="literal">String</code> argument, which yielded this:</p><div class="example"><a id="ch14ex10"></a><p class="title"><strong>Example&nbsp;14-10.&nbsp;<code class="literal">Args.java (Boolean and String)</code></strong></p><div class="example-contents"><pre class="programlisting">package com.objectmentor.utilities.getopts;

import java.text.ParseException;
import java.util.*;

public class Args {
  private String schema;
  private String[] args;
  private boolean valid = true;
  private Set&lt;Character&gt; unexpectedArguments = new TreeSet&lt;Character&gt;();
  private Map&lt;Character, Boolean&gt; booleanArgs =
    new HashMap&lt;Character, Boolean&gt;();
  private Map&lt;Character, String&gt; stringArgs =
    new HashMap&lt;Character, String&gt;();
  private Set&lt;Character&gt; argsFound = new HashSet&lt;Character&gt;();
  private int currentArgument;
  private char errorArgument = '\0';

  enum ErrorCode {
    OK, MISSING_STRING}

  private ErrorCode errorCode = ErrorCode.OK;

  public Args(String schema, String[] args) throws ParseException {
    this.schema = schema;
    this.args = args;
    valid = parse();
  }

  private boolean parse() throws ParseException {
    if (schema.length() == 0 &amp;&amp; args.length == 0)
      return true;
    parseSchema();
    parseArguments();
    return valid;
  }

  private boolean parseSchema() throws ParseException {
    for (String element : schema.split(",")) {
      if (element.length() &gt; 0) {
        String trimmedElement = element.trim();
        parseSchemaElement(trimmedElement);
      }
    }
    return true;
  }

  private void parseSchemaElement(String element) throws ParseException {
    char elementId = element.charAt(0);
    String elementTail = element.substring(1);
    validateSchemaElementId(elementId);
    if (isBooleanSchemaElement(elementTail))
      parseBooleanSchemaElement(elementId);
    else if (isStringSchemaElement(elementTail))
      parseStringSchemaElement(elementId);
  }

  private void validateSchemaElementId(char elementId) throws ParseException {
    if (!Character.isLetter(elementId)) {
      throw new ParseException(
        "Bad character:" + elementId + "in Args format: " + schema, 0);
    }

  }

  private void parseStringSchemaElement(char elementId) {
    stringArgs.put(elementId, "");
  }
  private boolean isStringSchemaElement(String elementTail) {
    return elementTail.equals("*");
  }

  private boolean isBooleanSchemaElement(String elementTail) {
    return elementTail.length() == 0;
  }

  private void parseBooleanSchemaElement(char elementId) {
    booleanArgs.put(elementId, false);
  }

  private boolean parseArguments() {
    for (currentArgument = 0; currentArgument &lt; args.length; currentArgument++)
    {
      String arg = args[currentArgument];
      parseArgument(arg);
    }
    return true;
  }

  private void parseArgument(String arg) {
    if (arg.startsWith("-"))
      parseElements(arg);
  }

  private void parseElements(String arg) {
    for (int i = 1; i &lt; arg.length(); i++)
      parseElement(arg.charAt(i));
  }

  private void parseElement(char argChar) {
    if (setArgument(argChar))
      argsFound.add(argChar);
    else {
      unexpectedArguments.add(argChar);
      valid = false;
    }
  }

  private boolean setArgument(char argChar) {
    boolean set = true;
    if (isBoolean(argChar))
      setBooleanArg(argChar, true);
    else if (isString(argChar))
      setStringArg(argChar, "");
    else
      set = false;

    return set;
  }

  private void setStringArg(char argChar, String s) {
    currentArgument++;
    try {
      stringArgs.put(argChar, args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
      valid = false;
      errorArgument = argChar;
      errorCode = ErrorCode.MISSING_STRING;
    }
  }

  private boolean isString(char argChar) {
    return stringArgs.containsKey(argChar);
  }

  private void setBooleanArg(char argChar, boolean value) {
    booleanArgs.put(argChar, value);
  }

  private boolean isBoolean(char argChar) {
    return booleanArgs.containsKey(argChar);
  }

  public int cardinality() {
    return argsFound.size();
  }

  public String usage() {
    if (schema.length() &gt; 0)
      return "-[" + schema + "]";
    else
      return "";
  }

  public String errorMessage() throws Exception {
    if (unexpectedArguments.size() &gt; 0) {
      return unexpectedArgumentMessage();
    } else
      switch (errorCode) {
        case MISSING_STRING:
          return String.format("Could not find string parameter for -%c.",
                               errorArgument);
        case OK:
          throw new Exception("TILT: Should not get here.");
      }
    return "";
  }

  private String unexpectedArgumentMessage() {
    StringBuffer message = new StringBuffer("Argument(s) -");
    for (char c : unexpectedArguments) {
      message.append(c);
    }
    message.append(" unexpected.");

    return message.toString();
  }
  public boolean getBoolean(char arg) {
    return falseIfNull(booleanArgs.get(arg));
  }

  private boolean falseIfNull(Boolean b) {
    return b == null ? false : b;
  }

  public String getString(char arg) {
    return blankIfNull(stringArgs.get(arg));
  }

  private String blankIfNull(String s) {
    return s == null ? "" : s;
  }

  public boolean has(char arg) {
    return argsFound.contains(arg);
  }

  public boolean isValid() {
    return valid;
  }
}</pre></div></div><p><a id="iddle1071" class="indexterm"></a><a id="iddle1681" class="indexterm"></a><a id="iddle1703" class="indexterm"></a><a id="iddle2060" class="indexterm"></a><a id="iddle2217" class="indexterm"></a>You can see that this is starting to get out of hand. It’s still not horrible, but the mess is certainly starting to grow. It’s a pile, but it’s not festering quite yet. It took the addition of the integer argument type to get this pile really fermenting and festering.</p><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lev2sec2"></a>So I Stopped</h2></div></div></div><p>I had at least two more argument types to add, and I could tell that they would make things much worse. If I bulldozed my way forward, I could probably get them to work, but I’d leave behind a mess that was too large to fix. If the structure of this code was ever going to be maintainable, now was the time to fix it.</p><p>So I stopped adding features and started refactoring. Having just added the <code class="literal">String</code> and <code class="literal">integer</code> arguments, I knew that each argument type required new code in three major places. First, each argument type required some way to parse its schema element in order to select the <code class="literal">HashMap</code> for that type. Next, each argument type needed to be parsed in the command-line strings and converted to its true type. Finally, each argument type needed a <code class="literal">getXXX</code> method so that it could be returned to the caller as its true type.</p><p>Many different types, all with similar methods—that sounds like a class to me. And so the <code class="literal">ArgumentMarshaler</code> concept was born.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title"><a id="ch14lev2sec3"></a>On Incrementalism</h2></div></div></div><p>One of the best ways to ruin a program is to make massive changes to its structure in the name of improvement. Some programs never recover from such “improvements.” The problem is that it’s very hard to get the program working the same way it worked before the “improvement.”</p><p><a id="iddle1070" class="indexterm"></a><a id="iddle1155" class="indexterm"></a><a id="iddle2239" class="indexterm"></a><a id="iddle2248" class="indexterm"></a><a id="iddle2273" class="indexterm"></a><a id="iddle2278" class="indexterm"></a><a id="iddle2283" class="indexterm"></a><a id="iddle2309" class="indexterm"></a>To avoid this, I use the discipline of Test-Driven Development (TDD). One of the central doctrines of this approach is to keep the system running at all times. In other words, using TDD, I am not allowed to make a change to the system that breaks that system. Every change I make must keep the system working as it worked before.</p><p>To achieve this, I need a suite of automated tests that I can run on a whim and that verifies that the behavior of the system is unchanged. For the <code class="literal">Args</code> class I had created a suite of unit and acceptance tests while I was building the festering pile. The unit tests were written in <code class="literal">Java</code> and administered by <code class="literal">JUnit</code>. The acceptance tests were written as wiki pages in <code class="literal">FitNesse</code>. I could run these tests any time I wanted, and if they passed, I was confident that the system was working as I specified.</p><p>So I proceeded to make a large number of very tiny changes. Each change moved the structure of the system toward the <code class="literal">ArgumentMarshaler</code> concept. And yet each change kept the system working. The first change I made was to add the skeleton of the <code class="literal">ArgumentMarshaller</code> to the end of the festering pile (<a class="link" href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ch14ex11">Listing 14-11</a>).</p><div class="example"><a id="ch14ex11"></a><p class="title"><strong>Example&nbsp;14-11.&nbsp;<code class="literal">ArgumentMarshaller appended to Args.java</code></strong></p><div class="example-contents"><pre class="programlisting">private class ArgumentMarshaler {
    private boolean booleanValue = false;

    public void setBoolean(boolean value) {
      booleanValue = value;
    }

    public boolean getBoolean() {return booleanValue;}
  }

  private class BooleanArgumentMarshaler extends ArgumentMarshaler {
  }

  private class StringArgumentMarshaler extends ArgumentMarshaler {
  }

  private class IntegerArgumentMarshaler extends ArgumentMarshaler {
  }
}</pre></div></div><p>Clearly, this wasn’t going to break anything. So then I made the simplest modification I could, one that would break as little as possible. I changed the <code class="literal">HashMap</code> for the <code class="literal">Boolean</code> arguments to take an <code class="literal">ArgumentMarshaler</code>.</p><div class="informalexample"><pre class="programlisting">  private Map&lt;Character, <span class="strong"><strong>ArgumentMarshaler</strong></span>&gt; booleanArgs =
    new HashMap&lt;Character, <span class="strong"><strong>ArgumentMarshaler</strong></span>&gt;();</pre></div><p>This broke a few statements, which I quickly fixed.</p><div class="informalexample"><pre class="programlisting">...
  private void parseBooleanSchemaElement(char elementId) {
    booleanArgs.put(elementId, <span class="strong"><strong>new BooleanArgumentMarshaler()</strong></span>);
  }
..
  private void setBooleanArg(char argChar, boolean value) {
    booleanArgs.<span class="strong"><strong>get</strong></span>(argChar)<span class="strong"><strong>.setBoolean</strong></span>(value);
  }
...
  public boolean getBoolean(char arg) {
    return falseIfNull(booleanArgs.get(arg).<span class="strong"><strong>getBoolean()</strong></span>);
  }</pre></div><p><a id="iddle1817" class="indexterm"></a><a id="iddle1909" class="indexterm"></a><a id="iddle2210" class="indexterm"></a>Notice how these changes are in exactly the areas that I mentioned before: the <code class="literal">parse</code>, <code class="literal">set</code>, and <code class="literal">get</code> for the argument type. Unfortunately, small as this change was, some of the tests started failing. If you look carefully at <code class="literal">getBoolean</code>, you’ll see that if you call it with <code class="literal">'y</code>,<code class="literal">'</code> but there is no <code class="literal">y</code> argument, then <code class="literal">booleanArgs.get('y')</code> will return <code class="literal">null</code>, and the function will throw a <code class="literal">NullPointerException</code>. The <code class="literal">falseIfNull</code> function had been used to protect against this, but the change I made caused that function to become irrelevant.</p><p>Incrementalism demanded that I get this working quickly before making any other changes. Indeed, the fix was not too difficult. I just had to move the check for <code class="literal">null</code>. It was no longer the <code class="literal">boolean</code> being <code class="literal">null</code> that I needed to check; it was the <code class="literal">ArgumentMarshaller</code>.</p><p>First, I removed the <code class="literal">falseIfNull</code> call in the <code class="literal">getBoolean</code> function. It was useless now, so I also eliminated the function itself. The tests still failed in the same way, so I was confident that I hadn’t introduced any new errors.</p><div class="informalexample"><pre class="programlisting">  public boolean getBoolean(char arg) {
    return booleanArgs.get(arg).getBoolean();
  }</pre></div><p>Next, I split the function into two lines and put the <code class="literal">ArgumentMarshaller</code> into its own variable named <code class="literal">argumentMarshaller</code>. I didn’t care for the long variable name; it was badly redundant and cluttered up the function. So I shortened it to <code class="literal">am</code> [N5].</p><div class="informalexample"><pre class="programlisting">  public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler <span class="strong"><strong>am</strong></span> = booleanArgs.get(arg);
    return <span class="strong"><strong>am</strong></span>.getBoolean();
  }</pre></div><p>And then I put in the null detection logic.</p><div class="informalexample"><pre class="programlisting">  public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = booleanArgs.get(arg);
    return <span class="strong"><strong>am != null &amp;&amp;</strong></span> am.getBoolean();
  }</pre></div></div></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lev1sec3"></a>String Arguments</h1></div></div></div><p>Adding <code class="literal">String</code> arguments was very similar to adding <code class="literal">boolean</code> arguments. I had to change the <code class="literal">HashMap</code> and get the <code class="literal">parse</code>, <code class="literal">set</code>, and <code class="literal">get</code> functions working. There shouldn’t be any surprises in what follows except, perhaps, that I seem to be putting all the marshalling implementation in the <code class="literal">ArgumentMarshaller</code> base class instead of distributing it to the derivatives.</p><div class="informalexample"><pre class="programlisting">  private Map&lt;Character<span class="strong"><strong>, ArgumentMarshaler</strong></span>&gt; stringArgs =
      new HashMap&lt;Character<span class="strong"><strong>, ArgumentMarshaler</strong></span>&gt;();
...
  private void parseStringSchemaElement(char elementId) {
    stringArgs.put(elementId<span class="strong"><strong>, new StringArgumentMarshaler()</strong></span>);
  }
...
  private void setStringArg(char argChar) throws ArgsException {
    currentArgument++;
    try {
      stringArgs<span class="strong"><strong>.get</strong></span>(argChar)<span class="strong"><strong>.setString</strong></span>(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
      valid = false;
      errorArgumentId = argChar;
      errorCode = ErrorCode.MISSING_STRING;
      throw new ArgsException();
    }
  }
...
  public String getString(char arg) {
    <span class="strong"><strong>Args.ArgumentMarshaler am =</strong></span> stringArgs.get(arg);
    return <span class="strong"><strong>am == null ? ""</strong></span> : am.getString();
  }
...
  private class ArgumentMarshaler {
    private boolean booleanValue = false;
    <span class="strong"><strong>private String stringValue;</strong></span>

    public void setBoolean(boolean value) {
      booleanValue = value;
    }

    public boolean getBoolean() {
      return booleanValue;
    }

    <span class="strong"><strong>public void setString(String s) {</strong></span>
      <span class="strong"><strong>stringValue = s;</strong></span>
    <span class="strong"><strong>}</strong></span>

    <span class="strong"><strong>public String getString() {</strong></span>
      <span class="strong"><strong>return stringValue == null ? "" : stringValue;</strong></span>
    <span class="strong"><strong>}</strong></span>
  }</pre></div><p><a id="iddle1702" class="indexterm"></a>Again, these changes were made one at a time and in such a way that the tests kept running, if not passing. When a test broke, I made sure to get it passing again before continuing with the next change.</p><p>By now you should be able to see my intent. Once I get all the current marshalling behavior into the <code class="literal">ArgumentMarshaler</code> base class, I’m going to start pushing that behavior down into the derivatives. This will allow me to keep everything running while I gradually change the shape of this program.</p><p>The obvious next step was to move the <code class="literal">int</code> argument functionality into the <code class="literal">ArgumentMarshaler</code>. Again, there weren’t any surprises.</p><div class="informalexample"><pre class="programlisting">private Map&lt;Character<span class="strong"><strong>, ArgumentMarshaler</strong></span>&gt; intArgs =
     new HashMap&lt;Character<span class="strong"><strong>, ArgumentMarshaler</strong></span>&gt;();
...
  private void parseIntegerSchemaElement(char elementId) {
    intArgs.put(elementId, <span class="strong"><strong>new IntegerArgumentMarshaler()</strong></span>);
  }
...
  private void setIntArg(char argChar) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
      parameter = args[currentArgument];
      intArgs<span class="strong"><strong>.get</strong></span>(argChar)<span class="strong"><strong>.setInteger</strong></span>(Integer.parseInt(parameter));
    } catch (ArrayIndexOutOfBoundsException e) {
      valid = false;
      errorArgumentId = argChar;
      errorCode = ErrorCode.MISSING_INTEGER;
      throw new ArgsException();
    } catch (NumberFormatException e) {
      valid = false;
      errorArgumentId = argChar;
      errorParameter = parameter;
      errorCode = ErrorCode.INVALID_INTEGER;
      throw new ArgsException();
    }
  }
...
  public int getInt(char arg) {
    <span class="strong"><strong>Args.ArgumentMarshaler am =</strong></span> intArgs.get(arg);
    return <span class="strong"><strong>am == null ? 0</strong></span> : am.getInteger();
  }
...
  private class ArgumentMarshaler {
    private boolean booleanValue = false;
    private String stringValue;
    <span class="strong"><strong>private int integerValue;</strong></span>

    public void setBoolean(boolean value) {
      booleanValue = value;
    }

    public boolean getBoolean() {
      return booleanValue;
    }

    public void setString(String s) {
      stringValue = s;
    }

    public String getString() {
      return stringValue == null ? "" : stringValue;
    }

    <span class="strong"><strong>public void setInteger(int i) {</strong></span>
      <span class="strong"><strong>integerValue = i;</strong></span>
    <span class="strong"><strong>}</strong></span>

    <span class="strong"><strong>public int getInteger() {</strong></span>
      <span class="strong"><strong>return integerValue;</strong></span>
    <span class="strong"><strong>}</strong></span>
  }</pre></div><p><a id="iddle1431" class="indexterm"></a><a id="iddle2129" class="indexterm"></a>With all the marshalling moved to the <code class="literal">ArgumentMarshaler</code>, I started pushing functionality into the derivatives. The first step was to move the <code class="literal">setBoolean</code> function into the <code class="literal">BooleanArgumentMarshaller</code> and make sure it got called correctly. So I created an abstract <code class="literal">set</code> method.</p><div class="informalexample"><pre class="programlisting">  private <span class="strong"><strong>abstract</strong></span> class ArgumentMarshaler {
    <span class="strong"><strong>protected</strong></span> boolean booleanValue = false;
    private String stringValue;
    private int integerValue;

    public void setBoolean(boolean value) {
      booleanValue = value;
    }

    public boolean getBoolean() {
      return booleanValue;
    }

    public void setString(String s) {
      stringValue = s;
    }

    public String getString() {
      return stringValue == null ? "" : stringValue;
    }

    public void setInteger(int i) {
      integerValue = i;
    }

    public int getInteger() {
      return integerValue;
    }

    <span class="strong"><strong>public abstract void set(String s);</strong></span>
  <span class="strong"><strong>}</strong></span></pre></div><p>Then I implemented the <code class="literal">set</code> method in <code class="literal">BooleanArgumentMarshaller</code>.</p><div class="informalexample"><pre class="programlisting">  private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    <span class="strong"><strong>public void set(String s) {</strong></span>
      <span class="strong"><strong>booleanValue = true;</strong></span>
    <span class="strong"><strong>}</strong></span>
     }</pre></div><p>And finally I replaced the call to <code class="literal">setBoolean</code> with a call to <code class="literal">set</code>.</p><div class="informalexample"><pre class="programlisting">private void setBooleanArg(char argChar, boolean value) {
    booleanArgs.get(argChar)<span class="strong"><strong>.set("true");</strong></span>
}</pre></div><p>The tests all still passed. Because this change caused <code class="literal">set</code> to be deployed to the <code class="literal">BooleanArgumentMarshaler</code>, I removed the <code class="literal">setBoolean</code> method from the <code class="literal">ArgumentMarshaler</code> base class.</p><p>Notice that the abstract <code class="literal">set</code> function takes a <code class="literal">String</code> argument, but the implementation in the <code class="literal">BooleanArgumentMarshaller</code> does not use it. I put that argument in there because I knew that the <code class="literal">StringArgumentMarshaller</code> and <code class="literal">IntegerArgumentMarshaller</code> <span class="emphasis"><em>would</em></span> use it.</p><p><a id="iddle1617" class="indexterm"></a>Next, I wanted to deploy the <code class="literal">get</code> method into <code class="literal">BooleanArgumentMarshaler</code>. Deploying <code class="literal">get</code> functions is always ugly because the return type has to be <code class="literal">Object</code>, and in this case needs to be cast to a <code class="literal">Boolean</code>.</p><div class="informalexample"><pre class="programlisting">public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = booleanArgs.get(arg);
    return am != null &amp;&amp; <span class="strong"><strong>(Boolean)</strong></span>am.<span class="strong"><strong>get</strong></span>();
  }</pre></div><p>Just to get this to compile, I added the <code class="literal">get</code> function to the <code class="literal">ArgumentMarshaler</code>.</p><div class="informalexample"><pre class="programlisting">private abstract class ArgumentMarshaler {
    ...

    <span class="strong"><strong>public Object get() {</strong></span>
      <span class="strong"><strong>return null;</strong></span>
    <span class="strong"><strong>}</strong></span>
  }</pre></div><p>This compiled and obviously failed the tests. Getting the tests working again was simply a matter of making <code class="literal">get</code> abstract and implementing it in <code class="literal">BooleanAgumentMarshaler</code>.</p><div class="informalexample"><pre class="programlisting">private abstract class ArgumentMarshaler {
    protected boolean booleanValue = false;
    ...

    public <span class="strong"><strong>abstract</strong></span> Object get();
  }

  private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    public void set(String s) {
      booleanValue = true;
    }

    <span class="strong"><strong>public Object get() {</strong></span>
      <span class="strong"><strong>return booleanValue;</strong></span>
    <span class="strong"><strong>}</strong></span>
  }</pre></div><p>Once again the tests passed. So both <code class="literal">get</code> and <code class="literal">set</code> deploy to the <code class="literal">BooleanArgumentMarshaler</code>! This allowed me to remove the old <code class="literal">getBoolean</code> function from <code class="literal">ArgumentMarshaler</code>, move the protected <code class="literal">booleanValue</code> variable down to <code class="literal">BooleanArgumentMarshaler</code>, and make it <code class="literal">private</code>.</p><p>I did the same pattern of changes for <code class="literal">Strings</code>. I deployed both <code class="literal">set</code> and <code class="literal">get</code>, deleted the unused functions, and moved the variables.</p><div class="informalexample"><pre class="programlisting">  private void setStringArg(char argChar) throws ArgsException {
    currentArgument++;
    try {
      stringArgs.get(argChar).<span class="strong"><strong>set</strong></span>(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
      valid = false;
      errorArgumentId = argChar;
      errorCode = ErrorCode.MISSING_STRING;
      throw new ArgsException();
    }
  }
...
  public String getString(char arg) {
    Args.ArgumentMarshaler am = stringArgs.get(arg);
    return am == null ? "" : <span class="strong"><strong>(String)</strong></span> am.<span class="strong"><strong>get</strong></span>();
  }
...
  private abstract class ArgumentMarshaler {
    private int integerValue;

    public void setInteger(int i) {
      integerValue = i;
    }

    public int getInteger() {
      return integerValue;
    }

    public abstract void set(String s);

    public abstract Object get();
  }

  private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    <span class="strong"><strong>private boolean booleanValue = false;</strong></span>

    public void set(String s) {
      booleanValue = true;
    }

    public Object get() {
      return booleanValue;
    }
  }

  private class StringArgumentMarshaler extends ArgumentMarshaler {
    <span class="strong"><strong>private String stringValue = "";</strong></span>

    public void set(String s) {
      <span class="strong"><strong>stringValue = s;</strong></span>
    }

    public Object get() {
      <span class="strong"><strong>return stringValue;</strong></span>
    }
  }

  private class IntegerArgumentMarshaler extends ArgumentMarshaler {

    public void set(String s) {

    }

    public Object get() {
      return null;
    }
  }
}</pre></div><p><a id="iddle1704" class="indexterm"></a><a id="iddle1957" class="indexterm"></a>Finally, I repeated the process for <code class="literal">integers</code>. This was just a little more complicated because <code class="literal">integers</code> needed to be parsed, and the <code class="literal">parse</code> operation can throw an exception. But the result is better because the whole concept of <code class="literal">NumberFormatException</code> got buried in the <code class="literal">IntegerArgumentMarshaler</code>.</p><div class="informalexample"><pre class="programlisting">private boolean isIntArg(char argChar) {return intArgs.containsKey(argChar);}

  private void setIntArg(char argChar) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
      parameter = args[currentArgument];
      intArgs.get(argChar).<span class="strong"><strong>set</strong></span>(parameter);
    } catch (ArrayIndexOutOfBoundsException e) {
      valid = false;
      errorArgumentId = argChar;
      errorCode = ErrorCode.MISSING_INTEGER;
      throw new ArgsException();
    } catch (<span class="strong"><strong>ArgsException</strong></span> e) {
      valid = false;
      errorArgumentId = argChar;
      errorParameter = parameter;
      errorCode = ErrorCode.INVALID_INTEGER;
      throw <span class="strong"><strong>e</strong></span>;
    }
  }
...
  private void setBooleanArg(char argChar) {
    <span class="strong"><strong>try {</strong></span>
      booleanArgs.get(argChar).set("true");
    <span class="strong"><strong>} catch (ArgsException e) {</strong></span>
    <span class="strong"><strong>}</strong></span>
  }
...
  public int getInt(char arg) {
    Args.ArgumentMarshaler am = intArgs.get(arg);
    return am == null ? 0 : <span class="strong"><strong>(Integer)</strong></span> am.<span class="strong"><strong>get</strong></span>();
  }
...
  private abstract class ArgumentMarshaler {
    public abstract void set(String s) throws ArgsException;
    public abstract Object get();
  }
...
  private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    <span class="strong"><strong>private int intValue = 0;</strong></span>

    public void set(String s) <span class="strong"><strong>throws ArgsException {</strong></span>
      <span class="strong"><strong>try {</strong></span>
        <span class="strong"><strong>intValue = Integer.parseInt(s);</strong></span>
      <span class="strong"><strong>} catch (NumberFormatException e) {</strong></span>
        <span class="strong"><strong>throw new ArgsException();</strong></span>
      <span class="strong"><strong>}</strong></span>
    }

    public Object get() {
      <span class="strong"><strong>return intValue;</strong></span>
    }
  }</pre></div><p><a id="iddle1726" class="indexterm"></a><a id="iddle1814" class="indexterm"></a>Of course, the tests continued to pass. Next, I got rid of the three different maps up at the top of the algorithm. This made the whole system much more generic. However, I couldn’t get rid of them just by deleting them because that would break the system. Instead, I added a new <code class="literal">Map</code> for the <code class="literal">ArgumentMarshaler</code> and then one by one changed the methods to use it instead of the three original maps.</p><div class="informalexample"><pre class="programlisting">public class Args {
...
  private Map&lt;Character, ArgumentMarshaler&gt; booleanArgs =
    new HashMap&lt;Character, ArgumentMarshaler&gt;();
  private Map&lt;Character, ArgumentMarshaler&gt; stringArgs =
    new HashMap&lt;Character, ArgumentMarshaler&gt;();
  private Map&lt;Character, ArgumentMarshaler&gt; intArgs =
    new HashMap&lt;Character, ArgumentMarshaler&gt;();
  <span class="strong"><strong>private Map&lt;Character, ArgumentMarshaler&gt; marshalers =</strong></span>
    <span class="strong"><strong>new HashMap&lt;Character, ArgumentMarshaler&gt;();</strong></span>
...
  private void parseBooleanSchemaElement(char elementId) {
    <span class="strong"><strong>ArgumentMarshaler m = new BooleanArgumentMarshaler();</strong></span>
    booleanArgs.put(elementId, m);
    <span class="strong"><strong>marshalers.put(elementId, m);</strong></span>
  }

  private void parseIntegerSchemaElement(char elementId) {
    <span class="strong"><strong>ArgumentMarshaler m = new IntegerArgumentMarshaler();</strong></span>
    intArgs.put(elementId, m);
    <span class="strong"><strong>marshalers.put(elementId, m);</strong></span>
  }

  private void parseStringSchemaElement(char elementId) {
    <span class="strong"><strong>ArgumentMarshaler m = new StringArgumentMarshaler();</strong></span>
    stringArgs.put(elementId, m);
    <span class="strong"><strong>marshalers.put(elementId, m);</strong></span>
  }</pre></div><p>Of course the tests all still passed. Next, I changed <code class="literal">isBooleanArg</code> from this:</p><div class="informalexample"><pre class="programlisting">  private boolean isBooleanArg(char argChar) {
    return booleanArgs.containsKey(argChar);
  }</pre></div><p>to this:</p><div class="informalexample"><pre class="programlisting">  private boolean isBooleanArg(char argChar) {
    <span class="strong"><strong>ArgumentMarshaler m = marshalers.get(argChar);</strong></span>
    <span class="strong"><strong>return m instanceof BooleanArgumentMarshaler;</strong></span>
  }</pre></div><p>The tests still passed. So I made the same change to <code class="literal">isIntArg</code> and <code class="literal">isStringArg</code>.</p><div class="informalexample"><pre class="programlisting">  private boolean isIntArg(char argChar) {
    <span class="strong"><strong>ArgumentMarshaler m = marshalers.get(argChar);</strong></span>
    <span class="strong"><strong>return m instanceof IntegerArgumentMarshaler;</strong></span>
  }

  private boolean isStringArg(char argChar) {
    <span class="strong"><strong>ArgumentMarshaler m = marshalers.get(argChar);</strong></span>
    <span class="strong"><strong>return m instanceof StringArgumentMarshaler;</strong></span>
  }</pre></div><p><a id="iddle1816" class="indexterm"></a>The tests still passed. So I eliminated all the duplicate calls to <code class="literal">marshalers.get</code> as follows:</p><div class="informalexample"><pre class="programlisting">  private boolean setArgument(char argChar) throws ArgsException {
    <span class="strong"><strong>ArgumentMarshaler m = marshalers.get(argChar);</strong></span>
    if (isBooleanArg(<span class="strong"><strong>m</strong></span>))
      setBooleanArg(argChar);
    else if (isStringArg(<span class="strong"><strong>m</strong></span>))
      setStringArg(argChar);
    else if (isIntArg(<span class="strong"><strong>m</strong></span>))
      setIntArg(argChar);
    else
      return false;

    return true;
  }

  private boolean isIntArg(<span class="strong"><strong>ArgumentMarshaler m</strong></span>) {
    return m instanceof IntegerArgumentMarshaler;
  }

  private boolean isStringArg(<span class="strong"><strong>ArgumentMarshaler m</strong></span>) {
    return m instanceof StringArgumentMarshaler;
  }

  private boolean isBooleanArg(<span class="strong"><strong>ArgumentMarshaler m</strong></span>) {
    return m instanceof BooleanArgumentMarshaler;
  }</pre></div><p>This left no good reason for the three <code class="literal">isxxxArg</code> methods. So I inlined them:</p><div class="informalexample"><pre class="programlisting">  private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (<span class="strong"><strong>m instanceof BooleanArgumentMarshaler</strong></span>)
      setBooleanArg(argChar);
    else if (<span class="strong"><strong>m instanceof StringArgumentMarshaler</strong></span>)
      setStringArg(argChar);
    else if (<span class="strong"><strong>m instanceof IntegerArgumentMarshaler</strong></span>)
      setIntArg(argChar);
    else
      return false;

    return true;
  }</pre></div><p>Next, I started using the <code class="literal">marshalers</code> map in the <code class="literal">set</code> functions, breaking the use of the other three maps. I started with the <code class="literal">booleans</code>.</p><div class="informalexample"><pre class="programlisting">  private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m instanceof BooleanArgumentMarshaler)
      setBooleanArg(<span class="strong"><strong>m</strong></span>);
    else if (m instanceof StringArgumentMarshaler)
      setStringArg(argChar);
    else if (m instanceof IntegerArgumentMarshaler)
      setIntArg(argChar);
    else
      return false;
    return true;
  }
...
  private void setBooleanArg(<span class="strong"><strong>ArgumentMarshaler m</strong></span>) {
    try {
      <span class="strong"><strong>m</strong></span>.set("true"); <span class="strong"><strong>// was: booleanArgs.get(argChar).set("true");</strong></span>
    } catch (ArgsException e) {
    }
  }</pre></div><p><a id="iddle1520" class="indexterm"></a>The tests still passed, so I did the same with <code class="literal">Strings</code> and <code class="literal">Integers</code>. This allowed me to integrate some of the ugly exception management code into the <code class="literal">setArgument</code> function.</p><div class="informalexample"><pre class="programlisting">  private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    <span class="strong"><strong>try {</strong></span>
      if (m instanceof BooleanArgumentMarshaler)
        setBooleanArg(m);
      else if (m instanceof StringArgumentMarshaler)
        setStringArg(<span class="strong"><strong>m</strong></span>);
      else if (m instanceof IntegerArgumentMarshaler)
        setIntArg(<span class="strong"><strong>m</strong></span>);
      else
        return false;
    <span class="strong"><strong>} catch (ArgsException e) {</strong></span>
      <span class="strong"><strong>valid = false;</strong></span>
      <span class="strong"><strong>errorArgumentId = argChar;</strong></span>
      <span class="strong"><strong>throw e;</strong></span>
    <span class="strong"><strong>}</strong></span>
    return true;
  }

  private void setIntArg(<span class="strong"><strong>ArgumentMarshaler m</strong></span>) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
      parameter = args[currentArgument];
      <span class="strong"><strong>m</strong></span>.set(parameter);
    } catch (ArrayIndexOutOfBoundsException e) {
      errorCode = ErrorCode.MISSING_INTEGER;
      throw new ArgsException();
    } catch (ArgsException e) {
      errorParameter = parameter;
      errorCode = ErrorCode.INVALID_INTEGER;
      throw e;
    }
  }

  private void setStringArg(<span class="strong"><strong>ArgumentMarshaler m</strong></span>) throws ArgsException {
    currentArgument++;
    try {
      <span class="strong"><strong>m</strong></span>.set(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
      errorCode = ErrorCode.MISSING_STRING;
      throw new ArgsException();
    }
  }</pre></div><p><a id="iddle1119" class="indexterm"></a><a id="iddle1563" class="indexterm"></a><a id="iddle1618" class="indexterm"></a><a id="iddle1701" class="indexterm"></a>I was close to being able to remove the three old maps. First, I needed to change the <code class="literal">getBoolean</code> function from this:</p><div class="informalexample"><pre class="programlisting">  public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = booleanArgs.get(arg);
    return am != null &amp;&amp; (Boolean) am.get();
  }</pre></div><p class="continued">to this:</p><div class="informalexample"><pre class="programlisting">public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = marshalers.get(arg);
    <span class="strong"><strong>boolean b = false;</strong></span>
    <span class="strong"><strong>try {</strong></span>
      <span class="strong"><strong>b =</strong></span> am != null &amp;&amp; (Boolean) am.get();
    <span class="strong"><strong>} catch (ClassCastException e) {</strong></span>
      <span class="strong"><strong>b = false;</strong></span>
    <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>return b;</strong></span>
  }</pre></div><p>This last change might have been a surprise. Why did I suddenly decide to deal with the <code class="literal">ClassCastException</code>? The reason is that I have a set of unit tests and a separate set of acceptance tests written in FitNesse. It turns out that the FitNesse tests made sure that if you called <code class="literal">getBoolean</code> on a nonboolean argument, you got a <code class="literal">false</code>. The unit tests did not. Up to this point I had only been running the unit tests.<a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ftn.ch14fn02" class="footnote" id="ch14fn02"><sup class="footnote">[2]</sup></a></p><p>This last change allowed me to pull out another use of the <code class="literal">boolean</code> map:</p><div class="informalexample"><pre class="programlisting">  private void parseBooleanSchemaElement(char elementId) {
    ArgumentMarshaler m = new BooleanArgumentMarshaler();
<span class="strike">    <span class="strong"><strong>booleanArgs.put(elementId, m);</strong></span></span>
    marshalers.put(elementId, m);
  }</pre></div><p>And now we can delete the <code class="literal">boolean</code> map.</p><div class="informalexample"><pre class="programlisting">public class Args {
...
<span class="strike">  <span class="strong"><strong>private Map&lt;Character, ArgumentMarshaler&gt; booleanArgs =</strong></span></span>
  <span class="strike"><span class="strong"><strong>new HashMap&lt;Character, ArgumentMarshaler&gt;();</strong></span></span>
  private Map&lt;Character, ArgumentMarshaler&gt; stringArgs =
  new HashMap&lt;Character, ArgumentMarshaler&gt;();
  private Map&lt;Character, ArgumentMarshaler&gt; intArgs =
  new HashMap&lt;Character, ArgumentMarshaler&gt;();
  private Map&lt;Character, ArgumentMarshaler&gt; marshalers =
  new HashMap&lt;Character, ArgumentMarshaler&gt;();
...</pre></div><p>Next, I migrated the <code class="literal">String</code> and <code class="literal">Integer</code> arguments in the same manner and did a little cleanup with the <code class="literal">booleans</code>.</p><div class="informalexample"><pre class="programlisting">  private void parseBooleanSchemaElement(char elementId) {
    marshalers.put(elementId, <span class="strong"><strong>new BooleanArgumentMarshaler()</strong></span>);
  }
  private void parseIntegerSchemaElement(char elementId) {
    marshalers.put(elementId, <span class="strong"><strong>new IntegerArgumentMarshaler()</strong></span>);
  }

  private void parseStringSchemaElement(char elementId) {
    marshalers.put(elementId, <span class="strong"><strong>new StringArgumentMarshaler()</strong></span>);
  }
...
  public String getString(char arg) {
    Args.ArgumentMarshaler am = <span class="strong"><strong>marshalers</strong></span>.get(arg);
    <span class="strong"><strong>try {</strong></span>
      return am == null ? "" : (String) am.get();
    <span class="strong"><strong>} catch (ClassCastException e) {</strong></span>
      <span class="strong"><strong>return "";</strong></span>
    <span class="strong"><strong>}</strong></span>
  }

  public int getInt(char arg) {
    Args.ArgumentMarshaler am = <span class="strong"><strong>marshalers</strong></span>.get(arg);
    <span class="strong"><strong>try {</strong></span>
      return am == null ? 0 : (Integer) am.get();
    <span class="strong"><strong>} catch (Exception e) {</strong></span>
      <span class="strong"><strong>return 0;</strong></span>
    <span class="strong"><strong>}</strong></span>
  }
...
public class Args {
...
<span class="strike">  <span class="strong"><strong>private Map&lt;Character, ArgumentMarshaler&gt; stringArgs =</strong></span></span>
  <span class="strong"><strong><span class="strike">new HashMap&lt;Character, ArgumentMarshaler&gt;();</span></strong></span>
<span class="strike">  <span class="strong"><strong>private Map&lt;Character, ArgumentMarshaler&gt; intArgs =</strong></span></span>
  <span class="strong"><strong><span class="strike">new HashMap&lt;Character, ArgumentMarshaler&gt;();</span></strong></span>
  private Map&lt;Character, ArgumentMarshaler&gt; marshalers =
  new HashMap&lt;Character, ArgumentMarshaler&gt;();
...</pre></div><p>Next, I inlined the three <code class="literal">parse</code> methods because they didn’t do much anymore:</p><div class="informalexample"><pre class="programlisting">  private void parseSchemaElement(String element) throws ParseException {
    char elementId = element.charAt(0);
    String elementTail = element.substring(1);
    validateSchemaElementId(elementId);
    if (isBooleanSchemaElement(elementTail))
      <span class="strong"><strong>marshalers.put(elementId, new BooleanArgumentMarshaler());</strong></span>
    else if (isStringSchemaElement(elementTail))
      <span class="strong"><strong>marshalers.put(elementId, new StringArgumentMarshaler());</strong></span>
    else if (isIntegerSchemaElement(elementTail)) {
      <span class="strong"><strong>marshalers.put(elementId, new IntegerArgumentMarshaler());</strong></span>
    } else {
      throw new ParseException(String.format(
      "Argument: %c has invalid format: %s.", elementId, elementTail), 0);
    }
  }</pre></div><p>Okay, so now let’s look at the whole picture again. <a class="link" href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ch14ex12">Listing 14-12</a> shows the current form of the <code class="literal">Args</code> class.<a id="iddle1057" class="indexterm"></a></p><p></p><div class="example"><a id="ch14ex12"></a><p class="title"><strong>Example&nbsp;14-12.&nbsp;<code class="literal">Args.java (After first refactoring)</code></strong></p><div class="example-contents"><pre class="programlisting">package com.objectmentor.utilities.getopts;

import java.text.ParseException;
import java.util.*;

public class Args {
  private String schema;
  private String[] args;
  private boolean valid = true;
  private Set&lt;Character&gt; unexpectedArguments = new TreeSet&lt;Character&gt;();
  private Map&lt;Character, ArgumentMarshaler&gt; marshalers =
  new HashMap&lt;Character, ArgumentMarshaler&gt;();
  private Set&lt;Character&gt; argsFound = new HashSet&lt;Character&gt;();
  private int currentArgument;
  private char errorArgumentId = '\0';
  private String errorParameter = "TILT";
  private ErrorCode errorCode = ErrorCode.OK;

  private enum ErrorCode {
    OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT}

  public Args(String schema, String[] args) throws ParseException {
    this.schema = schema;
    this.args = args;
    valid = parse();
  }

  private boolean parse() throws ParseException {
    if (schema.length() == 0 &amp;&amp; args.length == 0)
      return true;
    parseSchema();
    try {
      parseArguments();
    } catch (ArgsException e) {
    }
    return valid;
  }

  private boolean parseSchema() throws ParseException {
    for (String element : schema.split(",")) {
      if (element.length() &gt; 0) {
        String trimmedElement = element.trim();
        parseSchemaElement(trimmedElement);
      }
    }
    return true;
  }

  private void parseSchemaElement(String element) throws ParseException {
    char elementId = element.charAt(0);
    String elementTail = element.substring(1);
    validateSchemaElementId(elementId);
    if (isBooleanSchemaElement(elementTail))
      marshalers.put(elementId, new BooleanArgumentMarshaler());
    else if (isStringSchemaElement(elementTail))
      marshalers.put(elementId, new StringArgumentMarshaler());
    else if (isIntegerSchemaElement(elementTail)) {
      marshalers.put(elementId, new IntegerArgumentMarshaler());
    } else {
      throw new ParseException(String.format(
      "Argument: %c has invalid format: %s.", elementId, elementTail), 0);
    }
  }

  private void validateSchemaElementId(char elementId) throws ParseException {
    if (!Character.isLetter(elementId)) {
      throw new ParseException(
      "Bad character:" + elementId + "in Args format: " + schema, 0);
    }
  }

  private boolean isStringSchemaElement(String elementTail) {
    return elementTail.equals("*");
  }

  private boolean isBooleanSchemaElement(String elementTail) {
    return elementTail.length() == 0;
  }

  private boolean isIntegerSchemaElement(String elementTail) {
    return elementTail.equals("#");
  }

  private boolean parseArguments() throws ArgsException {
    for (currentArgument=0; currentArgument&lt;args.length; currentArgument++) {
      String arg = args[currentArgument];
      parseArgument(arg);
    }
    return true;
  }

  private void parseArgument(String arg) throws ArgsException {
    if (arg.startsWith("-"))
      parseElements(arg);
  }

  private void parseElements(String arg) throws ArgsException {
    for (int i = 1; i &lt; arg.length(); i++)
      parseElement(arg.charAt(i));
  }

  private void parseElement(char argChar) throws ArgsException {
    if (setArgument(argChar))
      argsFound.add(argChar);
    else {
      unexpectedArguments.add(argChar);
      errorCode = ErrorCode.UNEXPECTED_ARGUMENT;
      valid = false;
    }
  }
  private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    try {
      if (m instanceof BooleanArgumentMarshaler)
        setBooleanArg(m);
      else if (m instanceof StringArgumentMarshaler)
        setStringArg(m);
      else if (m instanceof IntegerArgumentMarshaler)
        setIntArg(m);
      else
        return false;
    } catch (ArgsException e) {
      valid = false;
      errorArgumentId = argChar;
      throw e;
    }
    return true;
  }

  private void setIntArg(ArgumentMarshaler m) throws ArgsException {
    currentArgument++;
    String parameter = null;
    try {
      parameter = args[currentArgument];
      m.set(parameter);
    } catch (ArrayIndexOutOfBoundsException e) {
      errorCode = ErrorCode.MISSING_INTEGER;
      throw new ArgsException();
    } catch (ArgsException e) {
      errorParameter = parameter;
      errorCode = ErrorCode.INVALID_INTEGER;
      throw e;
    }
  }

  private void setStringArg(ArgumentMarshaler m) throws ArgsException {
    currentArgument++;
    try {
      m.set(args[currentArgument]);
    } catch (ArrayIndexOutOfBoundsException e) {
      errorCode = ErrorCode.MISSING_STRING;
      throw new ArgsException();
    }
  }

  private void setBooleanArg(ArgumentMarshaler m) {
    try {
      m.set("true");
    } catch (ArgsException e) {
    }
  }

  public int cardinality() {
    return argsFound.size();
  }
  public String usage() {
    if (schema.length() &gt; 0)
      return "-[" + schema + "]";
    else
      return "";
  }

  public String errorMessage() throws Exception {
    switch (errorCode) {
      case OK:
        throw new Exception("TILT: Should not get here.");
      case UNEXPECTED_ARGUMENT:
        return unexpectedArgumentMessage();
      case MISSING_STRING:
        return String.format("Could not find string parameter for -%c.",
                             errorArgumentId);
      case INVALID_INTEGER:
        return String.format("Argument -%c expects an integer but was '%s'.",
                             errorArgumentId, errorParameter);
      case MISSING_INTEGER:
        return String.format("Could not find integer parameter for -%c.",
                             errorArgumentId);
    }
    return "";
  }

  private String unexpectedArgumentMessage() {
    StringBuffer message = new StringBuffer("Argument(s) -");
    for (char c : unexpectedArguments) {
      message.append(c);
    }
    message.append(" unexpected.");

    return message.toString();
  }

  public boolean getBoolean(char arg) {
    Args.ArgumentMarshaler am = marshalers.get(arg);
    boolean b = false;
    try {
      b = am != null &amp;&amp; (Boolean) am.get();
    } catch (ClassCastException e) {
      b = false;
    }
    return b;
  }

  public String getString(char arg) {
    Args.ArgumentMarshaler am = marshalers.get(arg);
    try {
      return am == null ? "" : (String) am.get();
    } catch (ClassCastException e) {
      return "";
    }
  }
  public int getInt(char arg) {
    Args.ArgumentMarshaler am = marshalers.get(arg);
    try {
      return am == null ? 0 : (Integer) am.get();
    } catch (Exception e) {
      return 0;
    }
  }

  public boolean has(char arg) {
    return argsFound.contains(arg);
  }

  public boolean isValid() {
    return valid;
  }

  private class ArgsException extends Exception {
  }

  private abstract class ArgumentMarshaler {
    public abstract void set(String s) throws ArgsException;
    public abstract Object get();
  }

  private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    private boolean booleanValue = false;

    public void set(String s) {
      booleanValue = true;
    }

    public Object get() {
      return booleanValue;
    }
  }

  private class StringArgumentMarshaler extends ArgumentMarshaler {
    private String stringValue = "";

    public void set(String s) {
      stringValue = s;
    }

    public Object get() {
      return stringValue;
    }
  }

  private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    private int intValue = 0;

    public void set(String s) throws ArgsException {
      try {
        intValue = Integer.parseInt(s);
      } catch (NumberFormatException e) {
        throw new ArgsException();
      }
    }

    public Object get() {
      return intValue;
    }
  }
}</pre></div></div><p><a id="iddle1053" class="indexterm"></a><a id="iddle1696" class="indexterm"></a>After all that work, this is a bit disappointing. The structure is a bit better, but we still have all those variables up at the top; there’s still a horrible type-case in <code class="literal">setArgument</code>; and all those <code class="literal">set</code> functions are really ugly. Not to mention all the error processing. We still have a lot of work ahead of us.</p><p>I’d really like to get rid of that type-case up in <code class="literal">setArgument</code> [G23]. What I’d like in <code class="literal">setArgument</code> is a single call to <code class="literal">ArgumentMarshaler.set</code>. This means I need to push <code class="literal">setIntArg</code>, <code class="literal">setStringArg</code>, and <code class="literal">setBooleanArg</code> down into the appropriate <code class="literal">ArgumentMarshaler</code> derivatives. But there is a problem.</p><p>If you look closely at <code class="literal">setIntArg</code>, you’ll notice that it uses two instance variables: <code class="literal">args</code> and <code class="literal">currentArg</code>. To move <code class="literal">setIntArg</code> down into <code class="literal">BooleanArgumentMarshaler</code>, I’ll have to pass both <code class="literal">args</code> and <code class="literal">currentArgs</code> as function arguments. That’s dirty [F1]. I’d rather pass one argument instead of two. Fortunately, there is a simple solution. We can convert the <code class="literal">args</code> array into a <code class="literal">list</code> and pass an <code class="literal">Iterator</code> down to the <code class="literal">set</code> functions. The following took me ten steps, passing all the tests after each. But I’ll just show you the result. You should be able to figure out what most of the tiny little steps were.</p><div class="informalexample"><pre class="programlisting">public class Args {
  private String schema;
<span class="strike">  <span class="strong"><strong>private String[] args;</strong></span></span>
  private boolean valid = true;
  private Set&lt;Character&gt; unexpectedArguments = new TreeSet&lt;Character&gt;();
  private Map&lt;Character, ArgumentMarshaler&gt; marshalers =
  new HashMap&lt;Character, ArgumentMarshaler&gt;();
  private Set&lt;Character&gt; argsFound = new HashSet&lt;Character&gt;();
  private <span class="strong"><strong>Iterator&lt;String&gt;</strong></span> currentArgument;
  private char errorArgumentId = '\0';
  private String errorParameter = "TILT";
  private ErrorCode errorCode = ErrorCode.OK;
  <span class="strong"><strong>private List&lt;String&gt; argsList;</strong></span>

  private enum ErrorCode {
    OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT}

  public Args(String schema, String[] args) throws ParseException {
    this.schema = schema;
    <span class="strong"><strong>argsList = Arrays.asList(args);</strong></span>
    valid = parse();
  }
  private boolean parse() throws ParseException {
    if (schema.length() == 0 &amp;&amp; <span class="strong"><strong>argsList.size()</strong></span> == 0)
      return true;
    parseSchema();
    try {
      parseArguments();
    } catch (ArgsException e) {
    }
    return valid;
  }
---
  private boolean parseArguments() throws ArgsException {
    for (currentArgument = <span class="strong"><strong>argsList.iterator()</strong></span>; currentArgument.<span class="strong"><strong>hasNext()</strong></span>;) {
      String arg = currentArgument.<span class="strong"><strong>next()</strong></span>;
      parseArgument(arg);
    }

    return true;
  }
---
  private void setIntArg(ArgumentMarshaler m) throws ArgsException {
    String parameter = null;
    try {
      parameter = currentArgument.<span class="strong"><strong>next()</strong></span>;
      m.set(parameter);
    } catch (<span class="strong"><strong>NoSuchElementException</strong></span> e) {
      errorCode = ErrorCode.MISSING_INTEGER;
      throw new ArgsException();
    } catch (ArgsException e) {
      errorParameter = parameter;
      errorCode = ErrorCode.INVALID_INTEGER;
      throw e;
    }
  }

  private void setStringArg(ArgumentMarshaler m) throws ArgsException {
    try {
      m.set(currentArgument<span class="strong"><strong>.next()</strong></span>);
    } catch (<span class="strong"><strong>NoSuchElementException</strong></span> e) {
      errorCode = ErrorCode.MISSING_STRING;
      throw new ArgsException();
    }
  }</pre></div><p><a id="iddle1429" class="indexterm"></a><a id="iddle2126" class="indexterm"></a><a id="iddle2128" class="indexterm"></a>These were simple changes that kept all the tests passing. Now we can start moving the <code class="literal">set</code> functions down into the appropriate derivatives. First, I need to make the following change in <code class="literal">setArgument</code>:</p><div class="informalexample"><pre class="programlisting">  private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    <span class="strong"><strong>if (m == null)</strong></span>
      <span class="strong"><strong>return false;</strong></span>
    try {
      if (m instanceof BooleanArgumentMarshaler)
        setBooleanArg(m);
      else if (m instanceof StringArgumentMarshaler)
        setStringArg(m);
      else if (m instanceof IntegerArgumentMarshaler)
        setIntArg(m);
<span class="strike">      <span class="strong"><strong>else</strong></span></span>
<span class="strike">        <span class="strong"><strong>return false;</strong></span></span>
    } catch (ArgsException e) {
      valid = false;
      errorArgumentId = argChar;
      throw e;
    }
    return true;
  }</pre></div><p><a id="iddle1430" class="indexterm"></a><a id="iddle1661" class="indexterm"></a><a id="iddle2063" class="indexterm"></a><a id="iddle2127" class="indexterm"></a>This change is important because we want to completely eliminate the <code class="literal">if-else</code> chain. Therefore, we needed to get the error condition out of it.</p><p>Now we can start to move the <code class="literal">set</code> functions. The <code class="literal">setBooleanArg</code> function is trivial, so we’ll prepare that one first. Our goal is to change the <code class="literal">setBooleanArg</code> function to simply forward to the <code class="literal">BooleanArgumentMarshaler</code>.</p><div class="informalexample"><pre class="programlisting">private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
      return false;
    try {
      if (m instanceof BooleanArgumentMarshaler)
        setBooleanArg(m, <span class="strong"><strong>currentArgument</strong></span>);
      else if (m instanceof StringArgumentMarshaler)
        setStringArg(m);
      else if (m instanceof IntegerArgumentMarshaler)
        setIntArg(m);

    } catch (ArgsException e) {
      valid = false;
      errorArgumentId = argChar;
      throw e;
    }
    return true;
  }
---
  private void setBooleanArg(ArgumentMarshaler m,
                             <span class="strong"><strong>Iterator&lt;String&gt; currentArgument)</strong></span>
                             throws ArgsException {
  <span class="strong"><strong><span class="strike">try {</span></strong></span>
      m.set("true");
  <span class="strong"><strong><span class="strike">catch (ArgsException e) {</span></strong></span>
   <span class="strong"><strong><span class="strike">}</span></strong></span>
  }</pre></div><p>Didn’t we just put that exception processing in? Putting things in so you can take them out again is pretty common in refactoring. The smallness of the steps and the need to keep the tests running means that you move things around a lot. Refactoring is a lot like solving a Rubik’s cube. There are lots of little steps required to achieve a large goal. Each step enables the next.</p><p>Why did we pass that <code class="literal">iterator</code> when <code class="literal">setBooleanArg</code> certainly doesn’t need it? Because <code class="literal">setIntArg</code> and <code class="literal">setStringArg</code> will! And because I want to deploy all three of these functions through an abstract method in <code class="literal">ArgumentMarshaller</code>, I need to pass it to <code class="literal">setBooleanArg</code>.</p><p><a id="iddle1013" class="indexterm"></a>So now <code class="literal">setBooleanArg</code> is useless. If there were a <code class="literal">set</code> function in <code class="literal">ArgumentMarshaler</code>, we could call it directly. So it’s time to make that function! The first step is to add the new abstract method to <code class="literal">ArgumentMarshaler</code>.</p><div class="informalexample"><pre class="programlisting">  private abstract class ArgumentMarshaler {
    <span class="strong"><strong>public abstract void set(Iterator&lt;String&gt; currentArgument)</strong></span>
                         <span class="strong"><strong>throws ArgsException;</strong></span>
    public abstract void set(String s) throws ArgsException;
    public abstract Object get();
  }</pre></div><p>Of course this breaks all the derivatives. So let’s implement the new method in each.</p><div class="informalexample"><pre class="programlisting">  private class BooleanArgumentMarshaler extends ArgumentMarshaler {
    private boolean booleanValue = false;

    <span class="strong"><strong>public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {</strong></span>
      <span class="strong"><strong>booleanValue = true;</strong></span>
    }

    public void set(String s) {
<span class="strike">      <span class="strong"><strong>booleanValue = true;</strong></span></span>
    }

    public Object get() {
      return booleanValue;
    }
  }

  private class StringArgumentMarshaler extends ArgumentMarshaler {
    private String stringValue = "";

    <span class="strong"><strong>public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {</strong></span>
    <span class="strong"><strong>}</strong></span>

    public void set(String s) {
      stringValue = s;
    }

    public Object get() {
      return stringValue;
    }
  }

  private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    private int intValue = 0;

    <span class="strong"><strong>public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {</strong></span>
    <span class="strong"><strong>}</strong></span>

    public void set(String s) throws ArgsException {
      try {
        intValue = Integer.parseInt(s);
      } catch (NumberFormatException e) {
        throw new ArgsException();
      }
    }
    public Object get() {
      return intValue;
    }
  }</pre></div><p>And now we can eliminate <code class="literal">setBooleanArg</code>!</p><div class="informalexample"><pre class="programlisting">private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
      return false;
    try {
      if (m instanceof BooleanArgumentMarshaler)
        <span class="strong"><strong>m.set</strong></span>(currentArgument);
      else if (m instanceof StringArgumentMarshaler)
        setStringArg(m);
      else if (m instanceof IntegerArgumentMarshaler)
        setIntArg(m);

    } catch (ArgsException e) {
      valid = false;
      errorArgumentId = argChar;
      throw e;
    }
    return true;
  }</pre></div><p>The tests all pass, and the <code class="literal">set</code> function is deploying to <code class="literal">BooleanArgumentMarshaler</code>!</p><p>Now we can do the same for <code class="literal">Strings</code> and <code class="literal">Integers</code>.</p><div class="informalexample"><pre class="programlisting">  private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
      return false;
    try {
      if (m instanceof BooleanArgumentMarshaler)
        m.set(currentArgument);
      else if (m instanceof StringArgumentMarshaler)
        <span class="strong"><strong>m.set(currentArgument);</strong></span>
      else if (m instanceof IntegerArgumentMarshaler)
        <span class="strong"><strong>m.set(currentArgument);</strong></span>

    } catch (ArgsException e) {
      valid = false;
      errorArgumentId = argChar;
      throw e;
    }
    return true;
  }
---
  private class StringArgumentMarshaler extends ArgumentMarshaler {
    private String stringValue = "";

    public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {
      <span class="strong"><strong>try {</strong></span>
        <span class="strong"><strong>stringValue = currentArgument.next();</strong></span>
      <span class="strong"><strong>} catch (NoSuchElementException e) {</strong></span>
        <span class="strong"><strong>errorCode = ErrorCode.MISSING_STRING;</strong></span>
        <span class="strong"><strong>throw new ArgsException();</strong></span>
      <span class="strong"><strong>}</strong></span>
    }

    public void set(String s) {
    }

    public Object get() {
      return stringValue;
    }
  }

  private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    private int intValue = 0;

  public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {
    <span class="strong"><strong>String parameter = null;</strong></span>
    <span class="strong"><strong>try {</strong></span>
      <span class="strong"><strong>parameter = currentArgument.next();</strong></span>
      <span class="strong"><strong>set(parameter);</strong></span>
    <span class="strong"><strong>} catch (NoSuchElementException e) {</strong></span>
      <span class="strong"><strong>errorCode = ErrorCode.MISSING_INTEGER;</strong></span>
      <span class="strong"><strong>throw new ArgsException();</strong></span>
    <span class="strong"><strong>} catch (ArgsException e) {</strong></span>
      <span class="strong"><strong>errorParameter = parameter;</strong></span>
      <span class="strong"><strong>errorCode = ErrorCode.INVALID_INTEGER;</strong></span>
      <span class="strong"><strong>throw e;</strong></span>
    <span class="strong"><strong>}</strong></span>
  }

    public void set(String s) throws ArgsException {
      try {
        intValue = Integer.parseInt(s);
      } catch (NumberFormatException e) {
        throw new ArgsException();
      }
    }

    public Object get() {
      return intValue;
    }
  }</pre></div><p>And so the <span class="emphasis"><em>coup de grace</em></span>: The type-case can be removed! Touche!</p><div class="informalexample"><pre class="programlisting">  private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
      return false;
    try {
      m.set(currentArgument);
      return true;
    } catch (ArgsException e) {
      valid = false;
      errorArgumentId = argChar;
      throw e;
    }
  }</pre></div><p><a id="iddle1001" class="indexterm"></a><a id="iddle1068" class="indexterm"></a><a id="iddle1715" class="indexterm"></a><a id="iddle2265" class="indexterm"></a>Now we can get rid of some crufty functions in <code class="literal">IntegerArgumentMarshaler</code> and clean it up a bit.</p><div class="informalexample"><pre class="programlisting">  private class IntegerArgumentMarshaler extends ArgumentMarshaler {
    private int intValue = 0

    public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {
      String parameter = null;
      try {
        parameter = currentArgument.next();
        <span class="strong"><strong>intValue = Integer.parseInt</strong></span>(parameter);
      } catch (NoSuchElementException e) {
        errorCode = ErrorCode.MISSING_INTEGER;
        throw new ArgsException();
      } catch (<span class="strong"><strong>NumberFormatException</strong></span> e) {
        errorParameter = parameter;
        errorCode = ErrorCode.INVALID_INTEGER;
        throw new ArgsException();
      }
    }

    public Object get() {
      return intValue;
    }
  }</pre></div><p>We can also turn <span class="strong"><strong><code class="literal">ArgumentMarshaler</code></strong></span> into an interface.</p><div class="informalexample"><pre class="programlisting">  private <span class="strong"><strong>interface</strong></span> ArgumentMarshaler {
    void set(Iterator&lt;String&gt; currentArgument) throws ArgsException;
    Object get();
  }</pre></div><p>So now let’s see how easy it is to add a new argument type to our structure. It should require very few changes, and those changes should be isolated. First, we begin by adding a new test case to check that the <code class="literal">double</code> argument works correctly.</p><div class="informalexample"><pre class="programlisting">  public void testSimpleDoublePresent() throws Exception {
    Args args = new Args("x##", new String[] {"-x","42.3"});
    assertTrue(args.isValid());
    assertEquals(1, args.cardinality());
    assertTrue(args.has('x'));
    assertEquals(42.3, args.getDouble('x'), .001);
  }</pre></div><p>Now we clean up the schema parsing code and add the <code class="literal">##</code> detection for the <code class="literal">double</code> argument type.</p><div class="informalexample"><pre class="programlisting">  private void parseSchemaElement(String element) throws ParseException {
    char elementId = element.charAt(0);
    String elementTail = element.substring(1);
    validateSchemaElementId(elementId);
    if (elementTail.<span class="strong"><strong>length() == 0</strong></span>)
      marshalers.put(elementId, new BooleanArgumentMarshaler());
    else if (elementTail.<span class="strong"><strong>equals("*")</strong></span>)
      marshalers.put(elementId, new StringArgumentMarshaler());
    else if (elementTail.<span class="strong"><strong>equals("#")</strong></span>)
      marshalers.put(elementId, new IntegerArgumentMarshaler());
    <span class="strong"><strong>else if (elementTail.equals("##"))</strong></span>
      <span class="strong"><strong>marshalers.put(elementId, new DoubleArgumentMarshaler());</strong></span>
    else
      throw new ParseException(String.format(
        "Argument: %c has invalid format: %s.", elementId, elementTail), 0);
  }</pre></div><p><a id="iddle1455" class="indexterm"></a><a id="iddle1510" class="indexterm"></a>Next, we write the <code class="literal">DoubleArgumentMarshaler</code> class.</p><div class="informalexample"><pre class="programlisting">  <span class="strong"><strong>private class DoubleArgumentMarshaler implements ArgumentMarshaler {</strong></span>
    <span class="strong"><strong>private double doubleValue = 0;</strong></span>

    <span class="strong"><strong>public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {</strong></span>
      <span class="strong"><strong>String parameter = null;</strong></span>
      <span class="strong"><strong>try {</strong></span>
        <span class="strong"><strong>parameter = currentArgument.next();</strong></span>
        <span class="strong"><strong>doubleValue = Double.parseDouble(parameter);</strong></span>
      <span class="strong"><strong>} catch (NoSuchElementException e) {</strong></span>
        <span class="strong"><strong>errorCode = ErrorCode.MISSING_DOUBLE;</strong></span>
        <span class="strong"><strong>throw new ArgsException();</strong></span>
      <span class="strong"><strong>} catch (NumberFormatException e) {</strong></span>
        <span class="strong"><strong>errorParameter = parameter;</strong></span>
        <span class="strong"><strong>errorCode = ErrorCode.INVALID_DOUBLE;</strong></span>
        <span class="strong"><strong>throw new ArgsException();</strong></span>
      <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>}</strong></span>

    <span class="strong"><strong>public Object get() {</strong></span>
      <span class="strong"><strong>return doubleValue;</strong></span>
    <span class="strong"><strong>}</strong></span>
  <span class="strong"><strong>}</strong></span></pre></div><p>This forces us to add a new <code class="literal">ErrorCode</code>.</p><div class="informalexample"><pre class="programlisting">private enum ErrorCode {
    OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT,
    <span class="strong"><strong>MISSING_DOUBLE, INVALID_DOUBLE</strong></span>}</pre></div><p>And we need a <code class="literal">getDouble</code> function.</p><div class="informalexample"><pre class="programlisting">  <span class="strong"><strong>public double getDouble(char arg) {</strong></span>
    <span class="strong"><strong>Args.ArgumentMarshaler am = marshalers.get(arg);</strong></span>
    <span class="strong"><strong>try {</strong></span>
      <span class="strong"><strong>return am == null ? 0 : (Double) am.get();</strong></span>
    <span class="strong"><strong>} catch (Exception e) {</strong></span>
      <span class="strong"><strong>return 0.0;</strong></span>
    <span class="strong"><strong>}</strong></span>
  <span class="strong"><strong>}</strong></span></pre></div><p>And all the tests pass! That was pretty painless. So now let’s make sure all the error processing works correctly. The next test case checks that an error is declared if an unparseable string is fed to a <code class="literal">##</code> argument.</p><div class="informalexample"><pre class="programlisting">  public void testInvalidDouble() throws Exception {
    Args args = new Args("x##", new String[] {"-x","Forty two"});
    assertFalse(args.isValid());
    assertEquals(0, args.cardinality());
    assertFalse(args.has('x'));
    assertEquals(0, args.getInt('x'));
    assertEquals("Argument -x expects a double but was 'Forty two'.",
                 args.errorMessage());
  }
---
  public String errorMessage() throws Exception {
    switch (errorCode) {
      case OK:
        throw new Exception("TILT: Should not get here.");
      case UNEXPECTED_ARGUMENT:
        return unexpectedArgumentMessage();
      case MISSING_STRING:
        return String.format("Could not find string parameter for -%c.",
                             errorArgumentId);
      case INVALID_INTEGER:
        return String.format("Argument -%c expects an integer but was '%s'.",
                             errorArgumentId, errorParameter);
      case MISSING_INTEGER:
        return String.format("Could not find integer parameter for -%c.",
                             errorArgumentId);
      <span class="strong"><strong>case INVALID_DOUBLE:</strong></span>
        <span class="strong"><strong>return String.format("Argument -%c expects a double but was '%s'.",</strong></span>
                             <span class="strong"><strong>errorArgumentId, errorParameter);</strong></span>
      <span class="strong"><strong>case MISSING_DOUBLE:</strong></span>
        <span class="strong"><strong>return String.format("Could not find double parameter for -%c.",</strong></span>
                             <span class="strong"><strong>errorArgumentId);</strong></span>
    }
    return "";
  }</pre></div><p><a id="iddle1059" class="indexterm"></a>And the tests pass. The next test makes sure we detect a missing <code class="literal">double</code> argument properly.</p><div class="informalexample"><pre class="programlisting">  <span class="strong"><strong>public void testMissingDouble() throws Exception {</strong></span>
    <span class="strong"><strong>Args args = new Args("x##", new String[]{"-x"});</strong></span>
    <span class="strong"><strong>assertFalse(args.isValid());</strong></span>
    <span class="strong"><strong>assertEquals(0, args.cardinality());</strong></span>
    <span class="strong"><strong>assertFalse(args.has('x'));</strong></span>
    <span class="strong"><strong>assertEquals(0.0, args.getDouble('x'), 0.01);</strong></span>
    <span class="strong"><strong>assertEquals("Could not find double parameter for -x.",</strong></span>
                 <span class="strong"><strong>args.errorMessage());</strong></span>
  <span class="strong"><strong>}</strong></span></pre></div><p>This passes as expected. We wrote it simply for completeness.</p><p>The exception code is pretty ugly and doesn’t really belong in the <code class="literal">Args</code> class. We are also throwing out <code class="literal">ParseException</code>, which doesn’t really belong to us. So let’s merge all the exceptions into a single <code class="literal">ArgsException</code> class and move it into its own module.</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>public class ArgsException extends Exception {</strong></span>
  <span class="strong"><strong>private char errorArgumentId = '\0';</strong></span>
  <span class="strong"><strong>private String errorParameter = "TILT";</strong></span>
  <span class="strong"><strong>private ErrorCode errorCode = ErrorCode.OK;</strong></span>

  <span class="strong"><strong>public ArgsException() {}</strong></span>

  <span class="strong"><strong>public ArgsException(String message) {super(message);}</strong></span>

  <span class="strong"><strong>public enum ErrorCode {</strong></span>
    <span class="strong"><strong>OK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT,</strong></span>
    <span class="strong"><strong>MISSING_DOUBLE, INVALID_DOUBLE}</strong></span>
<span class="strong"><strong>}</strong></span>
---
public class Args {
  ...
  private char errorArgumentId = '\0';
  private String errorParameter = "TILT";
  private <span class="strong"><strong>ArgsException</strong></span>.ErrorCode errorCode = <span class="strong"><strong>ArgsException</strong></span>.ErrorCode.OK;
  private List&lt;String&gt; argsList;

  public Args(String schema, String[] args) throws <span class="strong"><strong>ArgsException</strong></span> {
    this.schema = schema;
    argsList = Arrays.asList(args);
    valid = parse();
  }

  private boolean parse() throws ArgsException {
    if (schema.length() == 0 &amp;&amp; argsList.size() == 0)
      return true;
    parseSchema();
    try {
      parseArguments();
    } catch (<span class="strong"><strong>ArgsException</strong></span> e) {
    }
    return valid;
  }

  private boolean parseSchema() throws <span class="strong"><strong>ArgsException</strong></span> {
    ...
  }

  private void parseSchemaElement(String element) throws <span class="strong"><strong>ArgsException</strong></span> {
    ...
    else
      throw new <span class="strong"><strong>ArgsException</strong></span>(
        String.format("Argument: %c has invalid format: %s.",
                      elementId,elementTail));
  }

  private void validateSchemaElementId(char elementId) throws <span class="strong"><strong>ArgsException</strong></span> {
    if (!Character.isLetter(elementId)) {
      throw new <span class="strong"><strong>ArgsException</strong></span>(
        "Bad character:" + elementId + "in Args format: " + schema);
    }
  }

  ...

  private void parseElement(char argChar) throws <span class="strong"><strong>ArgsException</strong></span> {
    if (setArgument(argChar))
      argsFound.add(argChar);
    else {
      unexpectedArguments.add(argChar);
      errorCode = <span class="strong"><strong>ArgsException</strong></span>.ErrorCode.UNEXPECTED_ARGUMENT;
      valid = false;
    }
  }

  ...
  private class StringArgumentMarshaler implements ArgumentMarshaler {
    private String stringValue = "";

    public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {
      try {
        stringValue = currentArgument.next();
      } catch (NoSuchElementException e) {
        errorCode = <span class="strong"><strong>ArgsException</strong></span>.ErrorCode.MISSING_STRING;
        throw new ArgsException();
      }
    }

    public Object get() {
      return stringValue;
    }
  }

  private class IntegerArgumentMarshaler implements ArgumentMarshaler {
    private int intValue = 0;

    public void set(Iterator&lt;String&gt; currentArgument) throws <span class="strong"><strong>ArgsException</strong></span> {
      String parameter = null;
      try {
        parameter = currentArgument.next();
        intValue = Integer.parseInt(parameter);
      } catch (NoSuchElementException e) {
        errorCode = ArgsException.ErrorCode.MISSING_INTEGER;
        throw new <span class="strong"><strong>ArgsException</strong></span>();
      } catch (NumberFormatException e) {
        errorParameter = parameter;
        errorCode = <span class="strong"><strong>ArgsException</strong></span>.ErrorCode.INVALID_INTEGER;
        throw new <span class="strong"><strong>ArgsException</strong></span>();
      }
    }

    public Object get() {
      return intValue;
    }
  }

  private class DoubleArgumentMarshaler implements ArgumentMarshaler {
    private double doubleValue = 0;

    public void set(Iterator&lt;String&gt; currentArgument) throws ArgsException {
      String parameter = null;
      try {
        parameter = currentArgument.next();
        doubleValue = Double.parseDouble(parameter);
      } catch (NoSuchElementException e) {
        errorCode = <span class="strong"><strong>ArgsException</strong></span>.ErrorCode.MISSING_DOUBLE;
        throw new ArgsException();
      } catch (NumberFormatException e) {
        errorParameter = parameter;
        errorCode = <span class="strong"><strong>ArgsException</strong></span>.ErrorCode.INVALID_DOUBLE;
        throw new ArgsException();
      }
    }
    public Object get() {
      return doubleValue;
    }
  }
}</pre></div><p><a id="iddle1503" class="indexterm"></a><a id="iddle1525" class="indexterm"></a>This is nice. Now the only exception thrown by <code class="literal">Args</code> is <code class="literal">ArgsException</code>. Moving <code class="literal">ArgsException</code> into its own module means that we can move a lot of the miscellaneous error support code into that module and out of the <code class="literal">Args</code> module. It provides a natural and obvious place to put all that code and will really help us clean up the <code class="literal">Args</code> module going forward.</p><p>So now we have completely separated the exception and error code from the <code class="literal">Args</code> module. (See <a class="link" href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ch14ex13">Listing 14-13</a> through <a class="link" href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ch14ex16">Listing 14-16</a>.) This was achieved through a series of about 30 tiny steps, keeping the tests passing between each step.</p><div class="example"><a id="ch14ex13"></a><p class="title"><strong>Example&nbsp;14-13.&nbsp;<code class="literal">ArgsTest.java</code></strong></p><div class="example-contents"><pre class="programlisting">package com.objectmentor.utilities.args;

import junit.framework.TestCase;

public class ArgsTest extends TestCase {
  public void testCreateWithNoSchemaOrArguments() throws Exception {
    Args args = new Args("", new String[0]);
    assertEquals(0, args.cardinality());
  }

  public void testWithNoSchemaButWithOneArgument() throws Exception {
    try {
      new Args("", new String[]{"-x"});
      fail();
    } catch (ArgsException e) {
      assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
                   e.getErrorCode());
      assertEquals('x', e.getErrorArgumentId());
    }
  }

  public void testWithNoSchemaButWithMultipleArguments() throws Exception {
    try {
      new Args("", new String[]{"-x", "-y"});
      fail();
    } catch (ArgsException e) {
      assertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
                   e.getErrorCode());
      assertEquals('x', e.getErrorArgumentId());
    }

  }

  public void testNonLetterSchema() throws Exception {
    try {
      new Args("*", new String[]{});
      fail("Args constructor should have thrown exception");
    } catch (ArgsException e) {
      assertEquals(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,
                   e.getErrorCode());
      assertEquals('*', e.getErrorArgumentId());
    }
  }

  public void testInvalidArgumentFormat() throws Exception {
    try {
      new Args("f~", new String[]{});
      fail("Args constructor should have throws exception");
    } catch (ArgsException e) {
      assertEquals(ArgsException.ErrorCode.INVALID_FORMAT, e.getErrorCode());
      assertEquals('f', e.getErrorArgumentId());
    }
  }

  public void testSimpleBooleanPresent() throws Exception {
    Args args = new Args("x", new String[]{"-x"});
    assertEquals(1, args.cardinality());
    assertEquals(true, args.getBoolean('x'));
  }

  public void testSimpleStringPresent() throws Exception {
    Args args = new Args("x*", new String[]{"-x", "param"});
    assertEquals(1, args.cardinality());
    assertTrue(args.has('x'));
    assertEquals("param", args.getString('x'));
  }

  public void testMissingStringArgument() throws Exception {
    try {
      new Args("x*", new String[]{"-x"});
      fail();
    } catch (ArgsException e) {
      assertEquals(ArgsException.ErrorCode.MISSING_STRING, e.getErrorCode());
      assertEquals('x', e.getErrorArgumentId());
    }
  }

  public void testSpacesInFormat() throws Exception {
    Args args = new Args("x, y", new String[]{"-xy"});
    assertEquals(2, args.cardinality());
    assertTrue(args.has('x'));
    assertTrue(args.has('y'));
  }

  public void testSimpleIntPresent() throws Exception {
    Args args = new Args("x#", new String[]{"-x", "42"});
    assertEquals(1, args.cardinality());
    assertTrue(args.has('x'));
    assertEquals(42, args.getInt('x'));
  }

  public void testInvalidInteger() throws Exception {
    try {
      new Args("x#", new String[]{"-x", "Forty two"});
      fail();
    } catch (ArgsException e) {
      assertEquals(ArgsException.ErrorCode.INVALID_INTEGER, e.getErrorCode());
      assertEquals('x', e.getErrorArgumentId());
      assertEquals("Forty two", e.getErrorParameter());
    }

  }

  public void testMissingInteger() throws Exception {
    try {
      new Args("x#", new String[]{"-x"});
      fail();
    } catch (ArgsException e) {
      assertEquals(ArgsException.ErrorCode.MISSING_INTEGER, e.getErrorCode());
      assertEquals('x', e.getErrorArgumentId());
    }
  }

  public void testSimpleDoublePresent() throws Exception {
    Args args = new Args("x##", new String[]{"-x", "42.3"});
    assertEquals(1, args.cardinality());
    assertTrue(args.has('x'));
    assertEquals(42.3, args.getDouble('x'), .001);
  }

  public void testInvalidDouble() throws Exception {
    try {
      new Args("x##", new String[]{"-x", "Forty two"});
      fail();
    } catch (ArgsException e) {
      assertEquals(ArgsException.ErrorCode.INVALID_DOUBLE, e.getErrorCode());
      assertEquals('x', e.getErrorArgumentId());
      assertEquals("Forty two", e.getErrorParameter());
    }
  }

  public void testMissingDouble() throws Exception {
    try {
      new Args("x##", new String[]{"-x"});
      fail();
    } catch (ArgsException e) {
      assertEquals(ArgsException.ErrorCode.MISSING_DOUBLE, e.getErrorCode());
      assertEquals('x', e.getErrorArgumentId());
    }
  }
}</pre></div></div><p></p><div class="example"><a id="ch14ex14"></a><p class="title"><strong>Example&nbsp;14-14.&nbsp;<code class="literal">ArgsExceptionTest.java</code></strong></p><div class="example-contents"><pre class="programlisting">public class ArgsExceptionTest extends TestCase {
  public void testUnexpectedMessage() throws Exception {
    ArgsException e =
      new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
                        'x', null);
    assertEquals("Argument -x unexpected.", e.errorMessage());
  }

  public void testMissingStringMessage() throws Exception {
    ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_STRING,
                                        'x', null);
    assertEquals("Could not find string parameter for -x.", e.errorMessage());
  }

  public void testInvalidIntegerMessage() throws Exception {
    ArgsException e =
      new ArgsException(ArgsException.ErrorCode.INVALID_INTEGER,
                        'x', "Forty two");
    assertEquals("Argument -x expects an integer but was 'Forty two'.",
                 e.errorMessage());
  }

  public void testMissingIntegerMessage() throws Exception {
    ArgsException e =
      new ArgsException(ArgsException.ErrorCode.MISSING_INTEGER, 'x', null);
    assertEquals("Could not find integer parameter for -x.", e.errorMessage());
  }

  public void testInvalidDoubleMessage() throws Exception {
    ArgsException e = new ArgsException(ArgsException.ErrorCode.INVALID_DOUBLE,
                                        'x', "Forty two");
    assertEquals("Argument -x expects a double but was 'Forty two'.",
                 e.errorMessage());
  }

  public void testMissingDoubleMessage() throws Exception {
    ArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_DOUBLE,
                                        'x', null);
    assertEquals("Could not find double parameter for -x.", e.errorMessage());
  }
}</pre></div></div><p></p><div class="example"><a id="ch14ex15"></a><p class="title"><strong>Example&nbsp;14-15.&nbsp;<code class="literal">ArgsException.java</code></strong></p><div class="example-contents"><pre class="programlisting">public class ArgsException extends Exception {
  private char errorArgumentId = '\0';
  private String errorParameter = "TILT";
  private ErrorCode errorCode = ErrorCode.OK;

  public ArgsException() {}

  public ArgsException(String message) {super(message);}

  public ArgsException(ErrorCode errorCode) {
    this.errorCode = errorCode;
  }
  public ArgsException(ErrorCode errorCode, String errorParameter) {
    this.errorCode = errorCode;
    this.errorParameter = errorParameter;
  }

  public ArgsException(ErrorCode errorCode, char errorArgumentId,
                       String errorParameter) {
    this.errorCode = errorCode;
    this.errorParameter = errorParameter;
    this.errorArgumentId = errorArgumentId;
  }

  public char getErrorArgumentId() {
    return errorArgumentId;
  }

  public void setErrorArgumentId(char errorArgumentId) {
    this.errorArgumentId = errorArgumentId;
  }

  public String getErrorParameter() {
    return errorParameter;
  }

  public void setErrorParameter(String errorParameter) {
    this.errorParameter = errorParameter;
  }

  public ErrorCode getErrorCode() {
    return errorCode;
  }

  public void setErrorCode(ErrorCode errorCode) {
    this.errorCode = errorCode;
  }

  public String errorMessage() throws Exception {
    switch (errorCode) {
      case OK:
        throw new Exception("TILT: Should not get here.");
      case UNEXPECTED_ARGUMENT:
        return String.format("Argument -%c unexpected.", errorArgumentId);
      case MISSING_STRING:
        return String.format("Could not find string parameter for -%c.",
                             errorArgumentId);
      case INVALID_INTEGER:
        return String.format("Argument -%c expects an integer but was '%s'.",
                             errorArgumentId, errorParameter);
      case MISSING_INTEGER:
        return String.format("Could not find integer parameter for -%c.",
                             errorArgumentId);
      case INVALID_DOUBLE:
        return String.format("Argument -%c expects a double but was '%s'.",
                             errorArgumentId, errorParameter);
      case MISSING_DOUBLE:
        return String.format("Could not find double parameter for -%c.",
                             errorArgumentId);
    }
    return "";
  }

  public enum ErrorCode {
    OK, INVALID_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,
    MISSING_STRING,
    MISSING_INTEGER, INVALID_INTEGER,
    MISSING_DOUBLE, INVALID_DOUBLE}
}</pre></div></div><p></p><div class="example"><a id="ch14ex16"></a><p class="title"><strong>Example&nbsp;14-16.&nbsp;<code class="literal">Args.java</code></strong></p><div class="example-contents"><pre class="programlisting">public class Args {
  private String schema;
  private Map&lt;Character, ArgumentMarshaler&gt; marshalers =
    new HashMap&lt;Character, ArgumentMarshaler&gt;();
  private Set&lt;Character&gt; argsFound = new HashSet&lt;Character&gt;();
  private Iterator&lt;String&gt; currentArgument;
  private List&lt;String&gt; argsList;

  public Args(String schema, String[] args) throws ArgsException {
    this.schema = schema;
    argsList = Arrays.asList(args);
    parse();
  }

  private void parse() throws ArgsException {
    parseSchema();
    parseArguments();
  }

  private boolean parseSchema() throws ArgsException {
    for (String element : schema.split(",")) {
      if (element.length() &gt; 0) {
        parseSchemaElement(element.trim());
      }
    }
    return true;
  }

  private void parseSchemaElement(String element) throws ArgsException {
    char elementId = element.charAt(0);
    String elementTail = element.substring(1);
    validateSchemaElementId(elementId);
    if (elementTail.length() == 0)
      marshalers.put(elementId, new BooleanArgumentMarshaler());
    else if (elementTail.equals("*"))
      marshalers.put(elementId, new StringArgumentMarshaler());
    else if (elementTail.equals("#"))
      marshalers.put(elementId, new IntegerArgumentMarshaler());
    else if (elementTail.equals("##"))
      marshalers.put(elementId, new DoubleArgumentMarshaler());
    else
      throw new ArgsException(ArgsException.ErrorCode.INVALID_FORMAT,
                              elementId, elementTail);
  }

  private void validateSchemaElementId(char elementId) throws ArgsException {
    if (!Character.isLetter(elementId)) {
      throw new ArgsException(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,
                              elementId, null);
    }
  }

  private void parseArguments() throws ArgsException {
    for (currentArgument = argsList.iterator(); currentArgument.hasNext();) {
      String arg = currentArgument.next();
      parseArgument(arg);
    }
  }

  private void parseArgument(String arg) throws ArgsException {
    if (arg.startsWith("-"))
      parseElements(arg);
  }

  private void parseElements(String arg) throws ArgsException {
    for (int i = 1; i &lt; arg.length(); i++)
      parseElement(arg.charAt(i));
  }

  private void parseElement(char argChar) throws ArgsException {
    if (setArgument(argChar))
      argsFound.add(argChar);
    else {
      throw new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,
                              argChar, null);
    }
  }

  private boolean setArgument(char argChar) throws ArgsException {
    ArgumentMarshaler m = marshalers.get(argChar);
    if (m == null)
      return false;
    try {
      m.set(currentArgument);
      return true;
    } catch (ArgsException e) {
      e.setErrorArgumentId(argChar);
      throw e;
    }
  }
  public int cardinality() {
    return argsFound.size();
  }

  public String usage() {
    if (schema.length() &gt; 0)
      return "-[" + schema + "]";
    else
      return "";
  }

  public boolean getBoolean(char arg) {
    ArgumentMarshaler am = marshalers.get(arg);
    boolean b = false;
    try {
      b = am != null &amp;&amp; (Boolean) am.get();
    } catch (ClassCastException e) {
      b = false;
    }
    return b;
  }

  public String getString(char arg) {
    ArgumentMarshaler am = marshalers.get(arg);
    try {
      return am == null ? "" : (String) am.get();
    } catch (ClassCastException e) {
      return "";
    }
  }

  public int getInt(char arg) {
    ArgumentMarshaler am = marshalers.get(arg);
    try {
      return am == null ? 0 : (Integer) am.get();
    } catch (Exception e) {
      return 0;
    }
  }


  public double getDouble(char arg) {
    ArgumentMarshaler am = marshalers.get(arg);
    try {
      return am == null ? 0 : (Double) am.get();
    } catch (Exception e) {
      return 0.0;
    }
  }

  public boolean has(char arg) {
    return argsFound.contains(arg);
  }
}</pre></div></div><p><a id="iddle1094" class="indexterm"></a><a id="iddle1096" class="indexterm"></a><a id="iddle1300" class="indexterm"></a><a id="iddle1413" class="indexterm"></a><a id="iddle1415" class="indexterm"></a><a id="iddle1509" class="indexterm"></a><a id="iddle1511" class="indexterm"></a><a id="iddle1958" class="indexterm"></a>The majority of the changes to the <code class="literal">Args</code> class were deletions. A lot of code just got moved out of <code class="literal">Args</code> and put into <code class="literal">ArgsException</code>. Nice. We also moved all the <code class="literal">ArgumentMarshaller</code>s into their own files. Nicer!</p><p>Much of good software design is simply about partitioning—creating appropriate places to put different kinds of code. This separation of concerns makes the code much simpler to understand and maintain.</p><p>Of special interest is the <code class="literal">errorMessage</code> method of <code class="literal">ArgsException</code>. Clearly it was a violation of the SRP to put the error message formatting into <code class="literal">Args</code>. <code class="literal">Args</code> should be about the processing of arguments, not about the format of the error messages. However, does it really make sense to put the error message formatting code into <code class="literal">ArgsException</code>?</p><p>Frankly, it’s a compromise. Users who don’t like the error messages supplied by <code class="literal">ArgsException</code> will have to write their own. But the convenience of having canned error messages already prepared for you is not insignificant.</p><p>By now it should be clear that we are within striking distance of the final solution that appeared at the start of this chapter. I’ll leave the final transformations to you as an exercise.</p></div><div class="section"><div class="titlepage"><div><div><h1 class="title"><a id="ch14lev1sec4"></a>Conclusion</h1></div></div></div><p>It is not enough for code to work. Code that works is often badly broken. Programmers who satisfy themselves with merely working code are behaving unprofessionally. They may fear that they don’t have time to improve the structure and design of their code, but I disagree. Nothing has a more profound and long-term degrading effect upon a development project than bad code. Bad schedules can be redone, bad requirements can be redefined. Bad team dynamics can be repaired. But bad code rots and ferments, becoming an inexorable weight that drags the team down. Time and time again I have seen teams grind to a crawl because, in their haste, they created a malignant morass of code that forever thereafter dominated their destiny.</p><p>Of course bad code can be cleaned up. But it’s very expensive. As code rots, the modules insinuate themselves into each other, creating lots of hidden and tangled dependencies. Finding and breaking old dependencies is a long and arduous task. On the other hand, keeping code clean is relatively easy. If you made a mess in a module in the morning, it is easy to clean it up in the afternoon. Better yet, if you made a mess five minutes ago, it’s very easy to clean it up right now.</p><p>So the solution is to continuously keep your code as clean and simple as it can be. Never let the rot get started.</p></div><div class="footnotes"><br><hr><div id="ftn.ch14fn01" class="footnote"><p><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ch14fn01" class="para"><sup class="para">[1] </sup></a>I recently rewrote this module in Ruby. It was 1/7th the size and had a subtly better structure.</p></div><div id="ftn.ch14fn02" class="footnote"><p><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#ch14fn02" class="para"><sup class="para">[2] </sup></a>To prevent further surprises of this kind, I added a new unit test that invoked all the FitNesse tests.</p></div></div></div><div class="annotator-outer annotator-viewer viewer annotator-hide">
  <ul class="annotator-widget annotator-listing"></ul>
</div><div class="annotator-modal-wrapper annotator-editor-modal annotator-editor annotator-hide">
	<div class="annotator-outer editor">
		<h2 class="title">Highlight</h2>
		<form class="annotator-widget">
			<ul class="annotator-listing">
			<li class="annotator-item"><textarea id="annotator-field-0" placeholder="Add a note using markdown (optional)" class="js-editor" maxlength="750"></textarea></li></ul>
			<div class="annotator-controls">
				<a class="link-to-markdown" href="https://daringfireball.net/projects/markdown/basics" target="_blank">?</a>
				<ul>
					<li class="delete annotator-hide"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#delete" class="annotator-delete-note button positive">Delete Note</a></li>
					<li class="save"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#save" class="annotator-save annotator-focus button positive">Save Note</a></li>
					<li class="cancel"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#cancel" class="annotator-cancel button">Cancel</a></li>
				</ul>
			</div>
		</form>
	</div>
</div><div class="annotator-modal-wrapper annotator-delete-confirm-modal" style="display: none;">
  <div class="annotator-outer">
    <h2 class="title">Highlight</h2>
      <a class="js-close-delete-confirm annotator-cancel close" href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#close">Close</a>
      <div class="annotator-widget">
         <div class="delete-confirm">
            Are you sure you want to permanently delete this note?
         </div>
         <div class="annotator-controls">
            <a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#cancel" class="annotator-cancel button js-cancel-delete-confirm">No, I changed my mind</a>
            <a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#delete" class="annotator-delete button positive js-delete-confirm">Yes, delete it</a>
         </div>
       </div>
   </div>
</div><div class="annotator-adder" style="display: none;">
	<ul class="adders ">
		
		<li class="copy"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#">Copy</a></li>
		
		<li class="add-highlight"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#">Add Highlight</a></li>
		<li class="add-note"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#">
			
				Add Note
			
		</a></li>
	</ul>
</div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="/Library/view/clean-code/9780136083238/ch13.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">13. Concurrency</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="/Library/view/clean-code/9780136083238/ch15.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">15. JUnit Internals</div>
        </a>
    
  
  </div>


      
    </section>
    <div class="reading-controls-bottom">
      <ul class="interface-controls js-bitlist">
        <li class="queue-control">
            <button type="button" class="rec-fav ss-queue js-queue js-current-chapter-queue" data-queue-endpoint="/api/v1/book/9780136083238/chapter/ch14.html" data-for-analytics="9780136083238:ch14.html">
      <span>Add to Queue</span>
  </button>
        </li>
      </ul>
    </div>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  





    
    



        
      </div>
      



  <footer class="pagefoot t-pagefoot">
    <a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#" class="icon-up"><div class="visuallyhidden">Back to top</div></a>
    <ul class="js-footer-nav">
      
        <li><a class="t-recommendations-footer" href="https://www.safaribooksonline.com/r/">Recommended</a></li>
      
      <li><a class="t-queue-footer" href="https://www.safaribooksonline.com/s/">Queue</a></li>
      
        <li><a class="t-recent-footer" href="https://www.safaribooksonline.com/history/">History</a></li>
        <li><a class="t-topics-footer" href="https://www.safaribooksonline.com/topics?q=*&amp;limit=21">Topics</a></li>
      
      
        <li><a class="t-tutorials-footer" href="https://www.safaribooksonline.com/tutorials/">Tutorials</a></li>
      
      <li><a class="t-settings-footer js-settings" href="https://www.safaribooksonline.com/u/">Settings</a></li>
      <li><a href="https://www.safaribooksonline.com/blog/">Blog</a></li>
      <li class="full-support"><a href="https://www.safaribooksonline.com/public/support">Support</a></li>
      <li><a href="https://community.safaribooksonline.com/">Feedback</a></li>
      <li><a href="https://www.safaribooksonline.com/apps/">Get the App</a></li>
      <li><a href="https://www.safaribooksonline.com/accounts/logout/">Sign Out</a></li>
    </ul>
    <span class="copyright">© 2016 <a href="https://www.safaribooksonline.com/" target="_blank">Safari</a>.</span>
    <a href="https://www.safaribooksonline.com/terms/">Terms of Service</a> /
    <a href="https://www.safaribooksonline.com/privacy/">Privacy Policy</a>
  </footer>




    

    
    
  

<div class="annotator-notice"></div><div class="font-flyout"><div class="font-controls-panel">
	<div class="nightmodes">
		<ul>
			<li class="day"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#" id="day-mode" title="Day Mode">
				<i class="fa fa-sun-o"></i>
				<span>Day Mode</span></a></li>
			<li class="cloudy"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#" id="cloudy-mode" title="Cloudy Mode">
				<i class="fa fa-cloud"></i>
				<span>Cloud Mode</span>
			</a></li>
			<li class="night"><a href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#" id="night-mode" title="Night Mode">
				<i class="fa fa-moon-o"></i>
				<span>Night Mode</span>
			</a></li>
		</ul>
	</div>

	<div class="font-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-font left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-font-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-font right"></i>
		</div>
	</div>

	<div class="column-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-compress left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-column-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-expand right"></i>
		</div>
	</div>

	<a id="reset" class="button" href="https://www.safaribooksonline.com//library/view/clean-code/9780136083238/ch14.html#">Reset</a>
</div>
</div></body><span class="gr__tooltip"><span class="gr__tooltip-content"></span><i class="gr__tooltip-logo"></i><span class="gr__triangle"></span></span></html>