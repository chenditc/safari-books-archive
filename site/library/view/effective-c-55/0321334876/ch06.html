<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage"" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/effective-c-55/0321334876/ch06.html"
data-csrf-cookie="csrfsafari"
data-highlight-privacy=""


  data-user-id="859452"
  data-user-uuid="4d373bec-fada-4717-9823-769db3ed3a36"
  data-username="dchen267"
  data-account-type="B2B"
  
  data-activated-trial-date="04/25/2016"


  data-archive="0321334876"
  data-publishers="Addison-Wesley Professional"



  data-htmlfile-name="ch06.html"
  data-epub-title="Effective C++: 55 Specific Ways to Improve Your Programs and Designs, Third Edition" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class=" js flexbox flexboxlegacy no-touch websqldatabase indexeddb history csscolumns csstransforms localstorage sessionstorage applicationcache svg inlinesvg zoom gr__safaribooksonline_com" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#" itemscope="" itemtype="http://schema.org/Book http://schema.org/ItemPage" "="" data-login-url="/accounts/login/" data-offline-url="/" data-url="/library/view/effective-c-55/0321334876/ch06.html" data-csrf-cookie="csrfsafari" data-highlight-privacy="" data-user-id="859452" data-user-uuid="4d373bec-fada-4717-9823-769db3ed3a36" data-username="dchen267" data-account-type="B2B" data-activated-trial-date="04/25/2016" data-archive="0321334876" data-publishers="Addison-Wesley Professional" data-htmlfile-name="ch06.html" data-epub-title="Effective C++: 55 Specific Ways to Improve Your Programs and Designs, Third Edition" data-debug="0" data-testing="0"><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="author" content="Safari Books Online"><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://0321334876"><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"><meta property="twitter:account_id" content="4503599627559754"><link rel="apple-touch-icon" href="https://www.safaribooksonline.com/static/images/apple-touch-icon.8cc2fd27400e.png"><link rel="shortcut icon" href="https://www.safaribooksonline.com/favicon.ico" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic" rel="stylesheet" type="text/css"><title>6. Inheritance and Object-Oriented Design - Effective C++: 55 Specific Ways to Improve Your Programs and Designs, Third Edition</title><link rel="stylesheet" href="https://www.safaribooksonline.com/static/CACHE/css/e4b0fef39b55.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://www.safaribooksonline.com/static/css/annotator.min.fd58f69f4908.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book">
    #sbo-rt-content div{margin-top:5pt;margin-bottom:5pt;margin-right:15pt}#sbo-rt-content .cover{margin-top:2pt;margin-bottom:2pt;text-align:center}#sbo-rt-content h1{page-break-before:right;margin-top:5pt;text-align:center;margin-bottom:12pt;font-weight:bold}#sbo-rt-content .subtitle{font-size:large;margin-top:30pt;margin-bottom:55pt;font-weight:bold;text-align:center}#sbo-rt-content .publisher{text-align:center;margin-top:64pt;margin-bottom:4pt}#sbo-rt-content .copyright{margin-top:5pt;margin-bottom:5pt;text-indent:.12pt}#sbo-rt-content h2{page-break-before:right;margin-top:7pt;margin-bottom:25pt;font-weight:bold}#sbo-rt-content h3{margin-top:9pt;margin-bottom:8pt;text-indent:.12pt;font-weight:bold}#sbo-rt-content h4{margin-top:9pt;margin-bottom:6pt;font-weight:bold}#sbo-rt-content h5{margin-top:9pt;margin-bottom:6pt;font-weight:bold}#sbo-rt-content h6{margin-top:8pt;margin-bottom:6pt;font-weight:bold}#sbo-rt-content .author{text-align:center;font-weight:bold;margin-top:66pt;margin-bottom:24pt}#sbo-rt-content .bolditalic{font-weight:bold;font-style:italic}#sbo-rt-content .toc-chapter{margin-top:12pt;margin-bottom:5pt;text-indent:.12pt;font-weight:bold}#sbo-rt-content .emphasis{font-style:italic}#sbo-rt-content .mediaobject{margin-top:12pt;margin-bottom:12pt;text-align:center}#sbo-rt-content .tabimage{margin-top:12pt;margin-bottom:12pt;text-align:center}#sbo-rt-content .smaller{font-size:small}#sbo-rt-content .center{margin-top:50pt;margin-bottom:5pt;text-align:center}#sbo-rt-content .note{margin-top:6pt;margin-bottom:12pt;margin-left:.12pt;text-indent:.12pt;margin-right:24pt}#sbo-rt-content .toc-preface{margin-top:5pt;margin-bottom:5pt;margin-left:1pt;text-indent:.12pt;font-weight:bold}#sbo-rt-content .programlisting{font-family:"Courier New";font-size:small;margin-top:8pt;margin-bottom:8pt;text-indent:.12pt}#sbo-rt-content .programlisting1{font-family:"Courier New";font-size:small;margin-top:5pt;margin-bottom:4pt;margin-left:36pt;text-indent:.12pt}#sbo-rt-content code{font-size:x-small}#sbo-rt-content .toc-section{margin-top:4pt;margin-bottom:4pt;margin-left:12pt;text-indent:.12pt}#sbo-rt-content .toc-index{margin-top:12pt;margin-bottom:4pt;text-indent:.12pt;font-weight:bold}#sbo-rt-content .toc-appendix{margin-top:12pt;margin-bottom:4pt;text-indent:.12pt;font-weight:bold}#sbo-rt-content .strong{font-weight:bold}#sbo-rt-content .italic{font-style:italic}#sbo-rt-content .title{margin-top:12pt;margin-bottom:6pt;font-size:medium;font-weight:bold;text-align:center}#sbo-rt-content .attribution{margin-top:4pt;margin-bottom:12pt;margin-right:15pt;text-align:right}#sbo-rt-content .indexmain{margin-top:2pt;margin-bottom:2pt;text-indent:.12pt}#sbo-rt-content .indexsub{margin-top:2pt;margin-bottom:2pt;margin-left:24pt;text-indent:.12pt}#sbo-rt-content .indexsubsub{margin-top:2pt;margin-bottom:2pt;margin-left:40pt;text-indent:.12pt}#sbo-rt-content .paraindent{margin-top:4pt;margin-bottom:4pt;margin-left:25pt;text-indent:.12pt}#sbo-rt-content .indenthanding{margin-top:4pt;margin-bottom:4pt;padding-left:25pt;text-indent:-15pt}#sbo-rt-content .indenthanding1{margin-top:4pt;margin-bottom:4pt;padding-left:48pt;text-indent:-8pt}#sbo-rt-content .underline{text-decoration:underline}#sbo-rt-content .footnotes{font-size:small;margin-top:5pt;margin-bottom:4pt;padding-left:20pt;text-indent:-8pt}#sbo-rt-content .courierb{font-family:"Courier New Bold"}#sbo-rt-content .courieri{font-family:"Courier New Italic"}#sbo-rt-content .center1{margin-top:4pt;margin-bottom:4pt;margin-left:80pt;text-align:center}#sbo-rt-content .noindent{margin-top:6pt;margin-bottom:5pt;text-indent:.12pt}#sbo-rt-content .noindent1{margin-top:12pt;margin-bottom:2pt;text-indent:.12pt}#sbo-rt-content .edition{font-size:1.2em;margin-top:2pt;margin-bottom:2pt;text-align:center}#sbo-rt-content .image1{page-break-before:always;page-break-after:always}#sbo-rt-content .codelink{margin-top:6pt;margin-bottom:6pt;text-indent:.12pt;font-weight:bold;page-break-after:avoid;font-size:small}
    </style><link rel="canonical" href="/site/library/view/effective-c-55/0321334876/ch06.html"><meta name="description" content="6. Inheritance and Object-Oriented Design Object-oriented programming (OOP) has been the rage for almost two decades, so it's likely that you have some experience with the ideas of inheritance ... "><meta property="og:title" content="6. Inheritance and Object-Oriented Design"><meta itemprop="isPartOf" content="/library/view/effective-c-55/0321334876/"><meta itemprop="name" content="6. Inheritance and Object-Oriented Design"><meta property="og:url" itemprop="url" content="https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/ch06.html"><meta property="og:site_name" content="Safari"><meta property="og:image" itemprop="thumbnailUrl" content="https://www.safaribooksonline.com/library/cover/0321334876/"><meta property="og:description" itemprop="description" content="6. Inheritance and Object-Oriented Design Object-oriented programming (OOP) has been the rage for almost two decades, so it's likely that you have some experience with the ideas of inheritance ... "><meta itemprop="inLanguage" content="en"><meta itemprop="publisher" content="Addison-Wesley Professional"><meta property="og:type" content="book"><meta property="og:book:isbn" itemprop="isbn" content="0321334876"><meta property="og:book:author" itemprop="author" content="Scott Meyers"><meta property="og:book:tag" itemprop="about" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@safari"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><!--[if lt IE 9]><script src="/static/js/src/respond.min.cf5c9b7980e5.js"></script><![endif]--><style id="annotator-dynamic-style">.annotator-adder, .annotator-outer, .annotator-notice {
  z-index: 100019;
}
.annotator-filter {
  z-index: 100009;
}</style></head>


<body class="reading sidenav nav-collapsed  scalefonts library" data-gr-c-s-loaded="true">

    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        




<a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#container" class="skip">Skip to content</a><header class="topbar t-topbar" style="display:None"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li class="t-logo"><a href="https://www.safaribooksonline.com/home/" class="l0 None safari-home nav-icn js-keyboard-nav-home"><svg width="20" height="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" version="1.1" fill="#4A3C31"><desc>Safari Home Icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M4 9.9L4 9.9 4 18 16 18 16 9.9 10 4 4 9.9ZM2.6 8.1L2.6 8.1 8.7 1.9 10 0.5 11.3 1.9 17.4 8.1 18 8.7 18 9.5 18 18.1 18 20 16.1 20 3.9 20 2 20 2 18.1 2 9.5 2 8.7 2.6 8.1Z"></path><rect x="10" y="12" width="3" height="7"></rect><rect transform="translate(18.121320, 10.121320) rotate(-315.000000) translate(-18.121320, -10.121320) " x="16.1" y="9.1" width="4" height="2"></rect><rect transform="translate(2.121320, 10.121320) scale(-1, 1) rotate(-315.000000) translate(-2.121320, -10.121320) " x="0.1" y="9.1" width="4" height="2"></rect></g></svg><span>Safari Home</span></a></li><li><a href="https://www.safaribooksonline.com/r/" class="t-recommendations-nav l0 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>recommendations icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M50 25C50 18.2 44.9 12.5 38.3 11.7 37.5 5.1 31.8 0 25 0 18.2 0 12.5 5.1 11.7 11.7 5.1 12.5 0 18.2 0 25 0 31.8 5.1 37.5 11.7 38.3 12.5 44.9 18.2 50 25 50 31.8 50 37.5 44.9 38.3 38.3 44.9 37.5 50 31.8 50 25ZM25 3.1C29.7 3.1 33.6 6.9 34.4 11.8 30.4 12.4 26.9 15.1 25 18.8 23.1 15.1 19.6 12.4 15.6 11.8 16.4 6.9 20.3 3.1 25 3.1ZM34.4 15.6C33.6 19.3 30.7 22.2 27.1 22.9 27.8 19.2 30.7 16.3 34.4 15.6ZM22.9 22.9C19.2 22.2 16.3 19.3 15.6 15.6 19.3 16.3 22.2 19.2 22.9 22.9ZM3.1 25C3.1 20.3 6.9 16.4 11.8 15.6 12.4 19.6 15.1 23.1 18.8 25 15.1 26.9 12.4 30.4 11.8 34.4 6.9 33.6 3.1 29.7 3.1 25ZM22.9 27.1C22.2 30.7 19.3 33.6 15.6 34.4 16.3 30.7 19.2 27.8 22.9 27.1ZM25 46.9C20.3 46.9 16.4 43.1 15.6 38.2 19.6 37.6 23.1 34.9 25 31.3 26.9 34.9 30.4 37.6 34.4 38.2 33.6 43.1 29.7 46.9 25 46.9ZM27.1 27.1C30.7 27.8 33.6 30.7 34.4 34.4 30.7 33.6 27.8 30.7 27.1 27.1ZM38.2 34.4C37.6 30.4 34.9 26.9 31.3 25 34.9 23.1 37.6 19.6 38.2 15.6 43.1 16.4 46.9 20.3 46.9 25 46.9 29.7 43.1 33.6 38.2 34.4Z" fill="currentColor"></path></g></svg><span>Recommended</span></a></li><li><a href="https://www.safaribooksonline.com/s/" class="t-queue-nav l0 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>queue icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 29.2C25.4 29.2 25.8 29.1 26.1 28.9L48.7 16.8C49.5 16.4 50 15.5 50 14.6 50 13.7 49.5 12.8 48.7 12.4L26.1 0.3C25.4-0.1 24.6-0.1 23.9 0.3L1.3 12.4C0.5 12.8 0 13.7 0 14.6 0 15.5 0.5 16.4 1.3 16.8L23.9 28.9C24.2 29.1 24.6 29.2 25 29.2ZM7.3 14.6L25 5.2 42.7 14.6 25 24 7.3 14.6ZM48.7 22.4L47.7 21.9 25 34.2 2.3 21.9 1.3 22.4C0.5 22.9 0 23.7 0 24.7 0 25.6 0.5 26.5 1.3 26.9L23.9 39.3C24.2 39.5 24.6 39.6 25 39.6 25.4 39.6 25.8 39.5 26.1 39.3L48.7 26.9C49.5 26.5 50 25.6 50 24.7 50 23.7 49.5 22.9 48.7 22.4ZM48.7 32.8L47.7 32.3 25 44.6 2.3 32.3 1.3 32.8C0.5 33.3 0 34.1 0 35.1 0 36 0.5 36.9 1.3 37.3L23.9 49.7C24.2 49.9 24.6 50 25 50 25.4 50 25.8 49.9 26.1 49.7L48.7 37.3C49.5 36.9 50 36 50 35.1 50 34.1 49.5 33.3 48.7 32.8Z" fill="currentColor"></path></g></svg><span>Queue</span></a></li><li class="search"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z" fill="currentColor"></path></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"></path></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li><a href="https://www.safaribooksonline.com/history/" class="t-recent-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>recent items icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 0C11.2 0 0 11.2 0 25 0 38.8 11.2 50 25 50 38.8 50 50 38.8 50 25 50 11.2 38.8 0 25 0ZM6.3 25C6.3 14.6 14.6 6.3 25 6.3 35.4 6.3 43.8 14.6 43.8 25 43.8 35.4 35.4 43.8 25 43.8 14.6 43.8 6.3 35.4 6.3 25ZM31.8 31.5C32.5 30.5 32.4 29.2 31.6 28.3L27.1 23.8 27.1 12.8C27.1 11.5 26.2 10.4 25 10.4 23.9 10.4 22.9 11.5 22.9 12.8L22.9 25.7 28.8 31.7C29.2 32.1 29.7 32.3 30.2 32.3 30.8 32.3 31.3 32 31.8 31.5Z" fill="currentColor"></path></g></svg><span>History</span></a></li><li><a href="https://www.safaribooksonline.com/topics" class="t-topics-link l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 55" version="1.1" fill="#4A3C31"><desc>topics icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 55L50 41.262 50 13.762 25 0 0 13.762 0 41.262 25 55ZM8.333 37.032L8.333 17.968 25 8.462 41.667 17.968 41.667 37.032 25 46.538 8.333 37.032Z" fill="currentColor"></path></g></svg><span>Topics</span></a></li><li><a href="https://www.safaribooksonline.com/tutorials/" class="l1 nav-icn t-tutorials-nav js-toggle-menu-item None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" version="1.1" fill="#4A3C31"><desc>tutorials icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M15.8 18.2C15.8 18.2 15.9 18.2 16 18.2 16.1 18.2 16.2 18.2 16.4 18.2 16.5 18.2 16.7 18.1 16.9 18 17 17.9 17.1 17.8 17.2 17.7 17.3 17.6 17.4 17.5 17.4 17.4 17.5 17.2 17.6 16.9 17.6 16.7 17.6 16.6 17.6 16.5 17.6 16.4 17.5 16.2 17.5 16.1 17.4 15.9 17.3 15.8 17.2 15.6 17 15.5 16.8 15.3 16.6 15.3 16.4 15.2 16.2 15.2 16 15.2 15.8 15.2 15.7 15.2 15.5 15.3 15.3 15.4 15.2 15.4 15.1 15.5 15 15.7 14.9 15.8 14.8 15.9 14.7 16 14.7 16.1 14.6 16.3 14.6 16.4 14.6 16.5 14.6 16.6 14.6 16.6 14.6 16.7 14.6 16.9 14.6 17 14.6 17.1 14.7 17.3 14.7 17.4 14.8 17.6 15 17.7 15.1 17.9 15.2 18 15.3 18 15.5 18.1 15.5 18.1 15.6 18.2 15.7 18.2 15.7 18.2 15.7 18.2 15.8 18.2L15.8 18.2ZM9.4 11.5C9.5 11.5 9.5 11.5 9.6 11.5 9.7 11.5 9.9 11.5 10 11.5 10.2 11.5 10.3 11.4 10.5 11.3 10.6 11.2 10.8 11.1 10.9 11 10.9 10.9 11 10.8 11.1 10.7 11.2 10.5 11.2 10.2 11.2 10 11.2 9.9 11.2 9.8 11.2 9.7 11.2 9.5 11.1 9.4 11 9.2 10.9 9.1 10.8 8.9 10.6 8.8 10.5 8.7 10.3 8.6 10 8.5 9.9 8.5 9.7 8.5 9.5 8.5 9.3 8.5 9.1 8.6 9 8.7 8.8 8.7 8.7 8.8 8.6 9 8.5 9.1 8.4 9.2 8.4 9.3 8.2 9.5 8.2 9.8 8.2 10 8.2 10.1 8.2 10.2 8.2 10.3 8.2 10.5 8.3 10.6 8.4 10.7 8.5 10.9 8.6 11.1 8.7 11.2 8.9 11.3 9 11.4 9.1 11.4 9.2 11.4 9.3 11.5 9.3 11.5 9.3 11.5 9.4 11.5 9.4 11.5L9.4 11.5ZM3 4.8C3.1 4.8 3.1 4.8 3.2 4.8 3.4 4.8 3.5 4.8 3.7 4.8 3.8 4.8 4 4.7 4.1 4.6 4.3 4.5 4.4 4.4 4.5 4.3 4.6 4.2 4.6 4.1 4.7 4 4.8 3.8 4.8 3.5 4.8 3.3 4.8 3.1 4.8 3 4.8 2.9 4.7 2.8 4.7 2.6 4.6 2.5 4.5 2.3 4.4 2.2 4.2 2.1 4 1.9 3.8 1.9 3.6 1.8 3.5 1.8 3.3 1.8 3.1 1.8 2.9 1.8 2.7 1.9 2.6 2 2.4 2.1 2.3 2.2 2.2 2.3 2.1 2.4 2 2.5 2 2.6 1.8 2.8 1.8 3 1.8 3.3 1.8 3.4 1.8 3.5 1.8 3.6 1.8 3.8 1.9 3.9 2 4 2.1 4.2 2.2 4.4 2.4 4.5 2.5 4.6 2.6 4.7 2.7 4.7 2.8 4.7 2.9 4.8 2.9 4.8 3 4.8 3 4.8 3 4.8L3 4.8ZM13.1 15.2C13.2 15.1 13.2 15.1 13.2 15.1 13.3 14.9 13.4 14.7 13.6 14.5 13.8 14.2 14.1 14 14.4 13.8 14.7 13.6 15.1 13.5 15.5 13.4 15.9 13.4 16.3 13.4 16.7 13.5 17.2 13.5 17.6 13.7 17.9 13.9 18.2 14.1 18.5 14.4 18.7 14.7 18.9 15 19.1 15.3 19.2 15.6 19.3 15.9 19.4 16.1 19.4 16.4 19.4 17 19.3 17.5 19.1 18.1 19 18.3 18.9 18.5 18.7 18.7 18.5 19 18.3 19.2 18 19.4 17.7 19.6 17.3 19.8 16.9 19.9 16.6 20 16.3 20 16 20 15.8 20 15.6 20 15.4 19.9 15.4 19.9 15.4 19.9 15.4 19.9 15.2 19.9 15 19.8 14.9 19.8 14.8 19.7 14.7 19.7 14.6 19.7 14.4 19.6 14.3 19.5 14.1 19.3 13.7 19.1 13.4 18.7 13.2 18.4 13.1 18.1 12.9 17.8 12.9 17.5 12.8 17.3 12.8 17.1 12.8 16.9L3.5 14.9C3.3 14.9 3.1 14.8 3 14.8 2.7 14.7 2.4 14.5 2.1 14.3 1.7 14 1.4 13.7 1.2 13.3 1 13 0.9 12.6 0.8 12.3 0.7 12 0.7 11.7 0.7 11.4 0.7 11 0.8 10.5 1 10.1 1.1 9.8 1.3 9.5 1.6 9.2 1.8 8.9 2.1 8.7 2.4 8.5 2.8 8.3 3.2 8.1 3.6 8.1 3.9 8 4.2 8 4.5 8 4.6 8 4.8 8 4.9 8.1L6.8 8.5C6.8 8.4 6.8 8.4 6.8 8.4 6.9 8.2 7.1 8 7.2 7.8 7.5 7.5 7.7 7.3 8 7.1 8.4 6.9 8.7 6.8 9.1 6.7 9.5 6.7 10 6.7 10.4 6.8 10.8 6.8 11.2 7 11.5 7.2 11.8 7.5 12.1 7.7 12.4 8 12.6 8.3 12.7 8.6 12.8 8.9 12.9 9.2 13 9.4 13 9.7 13 9.7 13 9.8 13 9.8 13.6 9.9 14.2 10.1 14.9 10.2 15 10.2 15 10.2 15.1 10.2 15.3 10.2 15.4 10.2 15.6 10.2 15.8 10.1 16 10 16.2 9.9 16.4 9.8 16.5 9.6 16.6 9.5 16.8 9.2 16.9 8.8 16.9 8.5 16.9 8.3 16.9 8.2 16.8 8 16.8 7.8 16.7 7.7 16.6 7.5 16.5 7.3 16.3 7.2 16.2 7.1 16 7 15.9 6.9 15.8 6.9 15.7 6.9 15.6 6.8 15.5 6.8L6.2 4.8C6.2 5 6 5.2 5.9 5.3 5.7 5.6 5.5 5.8 5.3 6 4.9 6.2 4.5 6.4 4.1 6.5 3.8 6.6 3.5 6.6 3.2 6.6 3 6.6 2.8 6.6 2.7 6.6 2.6 6.6 2.6 6.5 2.6 6.5 2.5 6.5 2.3 6.5 2.1 6.4 1.8 6.3 1.6 6.1 1.3 6 1 5.7 0.7 5.4 0.5 5 0.3 4.7 0.2 4.4 0.1 4.1 0 3.8 0 3.6 0 3.3 0 2.8 0.1 2.2 0.4 1.7 0.5 1.5 0.7 1.3 0.8 1.1 1.1 0.8 1.3 0.6 1.6 0.5 2 0.3 2.3 0.1 2.7 0.1 3.1 0 3.6 0 4 0.1 4.4 0.2 4.8 0.3 5.1 0.5 5.5 0.8 5.7 1 6 1.3 6.2 1.6 6.3 1.9 6.4 2.3 6.5 2.5 6.6 2.7 6.6 3 6.6 3 6.6 3.1 6.6 3.1 9.7 3.8 12.8 4.4 15.9 5.1 16.1 5.1 16.2 5.2 16.4 5.2 16.7 5.3 16.9 5.5 17.2 5.6 17.5 5.9 17.8 6.2 18.1 6.5 18.3 6.8 18.4 7.2 18.6 7.5 18.6 7.9 18.7 8.2 18.7 8.6 18.7 9 18.6 9.4 18.4 9.8 18.3 10.1 18.2 10.3 18 10.6 17.8 10.9 17.5 11.1 17.3 11.3 16.9 11.6 16.5 11.8 16 11.9 15.7 12 15.3 12 15 12 14.8 12 14.7 12 14.5 11.9 13.9 11.8 13.3 11.7 12.6 11.5 12.5 11.7 12.4 11.9 12.3 12 12.1 12.3 11.9 12.5 11.7 12.7 11.3 12.9 10.9 13.1 10.5 13.2 10.2 13.3 9.9 13.3 9.6 13.3 9.4 13.3 9.2 13.3 9 13.2 9 13.2 9 13.2 9 13.2 8.8 13.2 8.7 13.2 8.5 13.1 8.2 13 8 12.8 7.7 12.6 7.4 12.4 7.1 12 6.8 11.7 6.7 11.4 6.6 11.1 6.5 10.8 6.4 10.6 6.4 10.4 6.4 10.2 5.8 10.1 5.2 9.9 4.5 9.8 4.4 9.8 4.4 9.8 4.3 9.8 4.1 9.8 4 9.8 3.8 9.8 3.6 9.9 3.4 10 3.2 10.1 3 10.2 2.9 10.4 2.8 10.5 2.6 10.8 2.5 11.1 2.5 11.5 2.5 11.6 2.5 11.8 2.6 12 2.6 12.1 2.7 12.3 2.8 12.5 2.9 12.6 3.1 12.8 3.2 12.9 3.3 13 3.5 13.1 3.6 13.1 3.7 13.1 3.8 13.2 3.9 13.2L13.1 15.2 13.1 15.2Z" fill="currentColor"></path></g></svg><span>Tutorials</span></a></li><li class="nav-offers flyout-parent"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#" class="l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>offers icon</desc><path d="M10.8 43.7L0 39 0 10.2 13.6 4.6 23.3 8.7 11.5 13.5C11 13.6 10.8 13.9 10.8 14.3L10.8 43.7 10.8 43.7Z"></path><polygon points="12.3 44.4 25 50 38 44.3 38 14.7 25.2 9.4 12.3 14.7 12.3 44.4"></polygon><path d="M36.6 4.7L50 10.2 50 39 39.5 43.6 39.5 14.3C39.5 13.8 39.2 13.6 38.8 13.5L27 8.7 36.6 4.7 36.6 4.7Z"></path><polygon points="34.8 4 25 0 15.4 3.9 25.2 7.9 34.8 4"></polygon></svg><span>Offers</span></a><ul class="flyout"><li><a href="https://www.safaribooksonline.com/oreilly-conferences/" class="l2 nav-icn"><span>Conferences</span></a></li><li><a href="https://www.safaribooksonline.com/oreilly-newsletters/" class="l2 nav-icn"><span>Newsletter</span></a></li></ul></li><li class="nav-highlights"><a href="https://www.safaribooksonline.com/u/003o000000t5q9fAAA/" class="t-highlights-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 35" version="1.1" fill="#4A3C31"><desc>highlights icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M13.325 18.071L8.036 18.071C8.036 11.335 12.36 7.146 22.5 5.594L22.5 0C6.37 1.113 0 10.632 0 22.113 0 29.406 3.477 35 10.403 35 15.545 35 19.578 31.485 19.578 26.184 19.578 21.556 17.211 18.891 13.325 18.071L13.325 18.071ZM40.825 18.071L35.565 18.071C35.565 11.335 39.86 7.146 50 5.594L50 0C33.899 1.113 27.5 10.632 27.5 22.113 27.5 29.406 30.977 35 37.932 35 43.045 35 47.078 31.485 47.078 26.184 47.078 21.556 44.74 18.891 40.825 18.071L40.825 18.071Z" fill="currentColor"></path></g></svg><span>Highlights</span></a></li><li><a href="https://www.safaribooksonline.com/u/" class="t-settings-nav l1 js-settings nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z" fill="currentColor"></path></g></svg><span>Settings</span></a></li><li><a href="https://community.safaribooksonline.com/" class="l1 no-icon">Feedback</a></li><li><a href="https://www.safaribooksonline.com/accounts/logout/" class="l1 no-icon">Sign Out</a></li></ul><ul class="profile"><li><a href="https://www.safaribooksonline.com/u/" class="l2 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z" fill="currentColor"></path></g></svg><span>Settings</span></a></li><li><a href="https://community.safaribooksonline.com/" class="l2">Feedback</a></li><li><a href="https://www.safaribooksonline.com/accounts/logout/" class="l2">Sign Out</a></li></ul></div></li></ul></nav></header>


      </div>
      <div id="container" class="application">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Effective C++: 55 Specific Ways to Improve Your Programs and Designs, Third Edition
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#" title="Search in archive" class="js-search-controls search-controls"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><button type="button" class="rec-fav ss-queue js-queue js-current-chapter-queue" data-queue-endpoint="/api/v1/book/0321334876/chapter/ch06.html" data-for-analytics="0321334876:ch06.html"><span>Add to Queue</span></button></li><li class="js-font-control-panel font-control-activator"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a class="twitter share-button t-twitter" target="_blank" aria-label="Share this section on Twitter" title="Share this section on Twitter" href="https://twitter.com/share?url=https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/ch06.html&amp;text=Effective%20C%2B%2B%3A%2055%20Specific%20Ways%20to%20Improve%20Your%20Programs%20and%20Designs%2C%20Third%20Edition&amp;via=safari"><span>Twitter</span></a></li><li><a class="facebook share-button t-facebook" target="_blank" aria-label="Share this section on Facebook" title="Share this section on Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/ch06.html"><span>Facebook</span></a></li><li><a class="googleplus share-button t-googleplus" target="_blank" aria-label="Share this secton on Google Plus" title="Share this secton on Google Plus" href="https://plus.google.com/share?url=https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/ch06.html"><span>Google Plus</span></a></li><li><a class="email share-button t-email" aria-label="Share this section via email" title="Share this section via email" href="mailto:?subject=Safari:%206.%20Inheritance%20and%20Object-Oriented%20Design&amp;body=https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/ch06.html%0D%0Afrom%20Effective%20C%2B%2B%3A%2055%20Specific%20Ways%20to%20Improve%20Your%20Programs%20and%20Designs%2C%20Third%20Edition%0D%0A"><span>Email</span></a></li></ul></li>
      </ul>
    </div>

    <section role="document">
      
	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="/site/library/view/effective-c-55/0321334876/ch05.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">5. Implementations</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="/site/library/view/effective-c-55/0321334876/ch07.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">7. Templates and Generic Programming</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div class="annotator-wrapper"><h2 id="ch06">6. Inheritance and Object-Oriented Design</h2>
<p class="noindent"><a id="page_149"></a>Object-oriented programming (OOP) has been the rage for almost two decades, so it's likely that you have some experience with the ideas of inheritance, derivation, and virtual functions. Even if you've been programming only in C, you've surely not escaped the OOP hoopla.</p>
<p class="noindent">Still, OOP in C++ is probably a bit different from what you're used to. Inheritance can be single or multiple, and each inheritance link can be public, protected, or private. Each link can also be virtual or non-virtual. Then there are the member function options. Virtual? Non-virtual? Pure virtual? And the interactions with other language features. How do default parameter values interact with virtual functions? How does inheritance affect C++'s name lookup rules? And what about design options? If a class's behavior needs to be modifiable, is a virtual function the best way to do that?</p>
<p class="noindent">This chapter sorts it all out. Furthermore, I explain what the different features in C++ really <em>mean</em> — what you are really <em>expressing</em> when you use a particular construct. For example, public inheritance means “is-a,” and if you try to make it mean anything else, you'll run into trouble. Similarly, a virtual function means “interface must be inherited,” while a non-virtual function means “both interface and implementation must be inherited.” Failing to distinguish between these meanings has caused C++ programmers considerable grief.</p>
<p class="noindent">If you understand the meanings of C++'s various features, you'll find that your outlook on OOP changes. Instead of it being an exercise in differentiating between language features, it will become a matter of determining what you want to say about your software system. And once you know what you want to say, the translation into C++ is not terribly demanding.</p>
<h3 id="ch06lev1sec1">Item 32: Make sure public inheritance models “is-a.”</h3>
<p class="noindent"><a id="page_150"></a>In his book, <em>Some Must Watch While Some Must Sleep</em> (W. H. Freeman and Company, 1974), William Dement relates the story of his attempt to fix in the minds of his students the most important lessons of his course. It is claimed, he told his class, that the average British schoolchild remembers little more history than that the Battle of Hastings was in 1066. If a child remembers little else, Dement emphasized, he or she remembers the date 1066. For the students in <em>his</em> course, Dement went on, there were only a few central messages, including, interestingly enough, the fact that sleeping pills cause insomnia. He implored his students to remember these few critical facts even if they forgot everything else discussed in the course, and he returned to these fundamental precepts repeatedly during the term.</p>
<p class="noindent">At the end of the course, the last question on the final exam was, “Write one thing from the course that you will surely remember for the rest of your life.” When Dement graded the exams, he was stunned. Nearly everyone had written “1066.”</p>
<p class="noindent">It is thus with great trepidation that I proclaim to you now that the single most important rule in object-oriented programming with C++ is this: public inheritance means “is-a.” Commit this rule to memory.</p>
<p class="noindent">If you write that class <code>D</code> (“Derived”) publicly inherits from class <code>B</code> (“Base”), you are telling C++ compilers (as well as human readers of your code) that every object of type <code>D</code> is also an object of type <code>B</code>, but <em>not vice versa</em>. You are saying that <code>B</code> represents a more general concept than <code>D</code>, that <code>D</code> represents a more specialized concept than <code>B</code>. You are asserting that anywhere an object of type <code>B</code> can be used, an object of type <code>D</code> can be used just as well, because every object of type <code>D</code> <em>is</em> an object of type <code>B</code>. On the other hand, if you need an object of type <code>D</code>, an object of type <code>B</code> will not do: every <code>D</code> is-a <code>B</code>, but not vice versa.</p>
<p class="noindent">C++ enforces this interpretation of public inheritance. Consider this example:</p>
<p class="programlisting"><br>class Person {...};<br><br>class Student: public Person {...};<br></p>
<p class="noindent">We know from everyday experience that every student is a person, but not every person is a student. That is exactly what this hierarchy asserts. We expect that anything that is true of a person — for example, that he or she has a date of birth — is also true of a student. We do not expect that everything that is true of a student — that he or she is enrolled in a particular school, for instance — is true of people <a id="page_151"></a>in general. The notion of a person is more general than is that of a student; a student is a specialized type of person.</p>
<p class="noindent">Within the realm of C++, any function that expects an argument of type <code>Person</code> (or pointer-to-<code>Person</code> or reference-to-<code>Person</code>) will also take a <code>Student</code> object (or pointer-to-<code>Student</code> or reference-to-<code>Student</code>):</p>
<p class="codelink"><a id="procode220"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode220">Click here to view code image</a></p>
<p class="programlisting"><br>void eat(const Person&amp; p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// anyone can eat<br><br>void study(const Student&amp; s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// only students study<br><br>Person p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// p is a Person<br>Student s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// s is a Student<br><br>eat(p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fine, p is a Person<br><br>eat(s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fine, s is a Student,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// and a Student is-a Person<br><br>study(s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fine<br><br>study(p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error! p isn't a Student<br></p>
<p class="noindent">This is true only for <em>public</em> inheritance. C++ will behave as I've described only if <code>Student</code> is publicly derived from <code>Person</code>. Private inheritance means something entirely different (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec8">Item 39</a>), and protected inheritance is something whose meaning eludes me to this day.</p>
<p class="noindent">The equivalence of public inheritance and is-a sounds simple, but sometimes your intuition can mislead you. For example, it is a fact that a penguin is a bird, and it is a fact that birds can fly. If we naively try to express this in C++, our effort yields:</p>
<p class="codelink"><a id="procode221"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode221">Click here to view code image</a></p>
<p class="programlisting"><br>class Bird {<br>public:<br>&nbsp;&nbsp;virtual void fly();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// birds can fly<br><br>&nbsp;&nbsp;...<br>};<br><br>class Penguin:public Bird {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// penguins are birds<br>&nbsp;&nbsp;...<br>};<br></p>
<p class="noindent">Suddenly we are in trouble, because this hierarchy says that penguins can fly, which we know is not true. What happened?</p>
<p class="noindent">In this case, we are the victims of an imprecise language: English. When we say that birds can fly, we don't mean that <em>all</em> types of birds can fly, only that, in general, birds have the ability to fly. If we were more precise, we'd recognize that there are several types of non-flying <a id="page_152"></a>birds, and we would come up with the following hierarchy, which models reality much better:</p>
<p class="codelink"><a id="procode222"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode222">Click here to view code image</a></p>
<p class="programlisting"><br>class Bird {<br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// no fly function is declared<br>};<br><br>class FlyingBird: public Bird {<br>public:<br>&nbsp;&nbsp;virtual void fly();<br>&nbsp;&nbsp;...<br>};<br><br>class Penguin: public Bird {<br><br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// no fly function is declared<br><br>};<br></p>
<p class="noindent">This hierarchy is much more faithful to what we really know than was the original design.</p>
<p class="noindent">Yet we're not finished with these fowl matters, because for some software systems, there may be no need to distinguish between flying and non-flying birds. If your application has much to do with beaks and wings and nothing to do with flying, the original two-class hierarchy might be quite satisfactory. That's a simple reflection of the fact that there is no one ideal design for all software. The best design depends on what the system is expected to do, both now and in the future. If your application has no knowledge of flying and isn't expected to ever have any, failing to distinguish between flying and non-flying birds may be a perfectly valid design decision. In fact, it may be preferable to a design that does distinguish between them, because such a distinction would be absent from the world you are trying to model.</p>
<p class="noindent">There is another school of thought on how to handle what I call the “All birds can fly, penguins are birds, penguins can't fly, uh oh” problem. That is to redefine the <code>fly</code> function for penguins so that it generates a runtime error:</p>
<p class="codelink"><a id="procode223"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode223">Click here to view code image</a></p>
<p class="programlisting"><br>void error(const std::string&amp; msg);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// defined elsewhere<br><br>class Penguin: public Bird {<br>public:<br>&nbsp;&nbsp;virtual void fly() { error("Attempt to make a penguin fly!");}<br><br>&nbsp;&nbsp;...<br><br>};<br></p>
<p class="noindent"><a id="page_153"></a>It's important to recognize that this says something different from what you might think. This does <em>not</em> say, “Penguins can't fly.” This says, “Penguins can fly, but it's an error for them to actually try to do it.”</p>
<p class="noindent">How can you tell the difference? From the time at which the error is detected. The injunction, “Penguins can't fly,” can be enforced by compilers, but violations of the rule, “It's an error for penguins to actually try to fly,” can be detected only at runtime.</p>
<p class="noindent">To express the constraint, “Penguins can't fly — <em>period</em>,” you make sure that no such function is defined for <code>Penguin</code> objects:</p>
<p class="codelink"><a id="procode224"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode224">Click here to view code image</a></p>
<p class="programlisting"><br>class Bird {<br><br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// no fly function is declared<br><br>};<br><br>class Penguin: public Bird {<br><br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// no fly function is declared<br><br>};<br></p>
<p class="noindent">If you now try to make a penguin fly, compilers will reprimand you for your transgression:</p>
<p class="programlisting"><br>Penguin p;<br><br>p.fly();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error!<br></p>
<p class="noindent">This is very different from the behavior you get if you adopt the approach that generates runtime errors. With that methodology, compilers won't say a word about the call to <code>p.fly</code>. <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch04.html#ch04lev1sec1">Item 18</a> explains that good interfaces prevent invalid code from compiling, so you should prefer the design that rejects penguin flight attempts during compilation to the one that detects them only at runtime.</p>
<p class="noindent">Perhaps you'll concede that your ornithological intuition may be lacking, but you can rely on your mastery of elementary geometry, right? I mean, how complicated can rectangles and squares be?</p>
<p class="noindent">Well, answer this simple question: should class <code>Square</code> publicly inherit from class <code>Rectangle</code>?</p>
<p class="mediaobject"><img src="https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/graphics/06inf01.gif" alt="images" width="90" height="86" data-mfp-src="/library/view/effective-c-55/0321334876/graphics/06inf01.gif"></p>
<p class="noindent"><a id="page_154"></a>“Duh!” you say, “Of course it should! Everybody knows that a square is a rectangle, but generally not vice versa.” True enough, at least in school. But I don't think we're in school anymore.</p>
<p class="noindent">Consider this code:</p>
<p class="codelink"><a id="procode225"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode225">Click here to view code image</a></p>
<p class="programlisting"><br>class Rectangle {<br>public:<br>&nbsp;&nbsp;virtual void setHeight(int newHeight);<br>&nbsp;&nbsp;virtual void setWidth(int newWidth);<br><br>&nbsp;&nbsp;virtual int height() const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// return current values<br>&nbsp;&nbsp;virtual int width() const;<br><br>&nbsp;&nbsp;...<br><br>};<br><br>void makeBigger(Rectangle&amp; r)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// function to increase r's area<br>{<br>&nbsp;&nbsp;int oldHeight = r.height();<br><br>&nbsp;&nbsp;r.setWidth(r.width() + 10);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// add 10 to r's width<br><br>&nbsp;&nbsp;assert(r.height() == oldHeight);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// assert that r's<br>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// height is unchanged<br></p>
<p class="noindent">Clearly, the assertion should never fail. <code>makeBigger</code> only changes <code>r</code>'s width. Its height is never modified.</p>
<p class="noindent">Now consider this code, which uses public inheritance to allow squares to be treated like rectangles:</p>
<p class="codelink"><a id="procode226"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode226">Click here to view code image</a></p>
<p class="programlisting"><br>class Square: public Rectangle {...};<br><br>Square s;<br><br>...<br><br>assert(s.width() == s.height());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this must be true for all squares<br><br>makeBigger(s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// by inheritance, s is-a Rectangle,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// so we can increase its area<br><br>assert(s.width() == s.height());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this must still be true<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// for all squares<br></p>
<p class="noindent">It's just as clear that this second assertion should also never fail. By definition, the width of a square is the same as its height.</p>
<p class="noindent">But now we have a problem. How can we reconcile the following assertions?</p>
<p class="indenthanding">• Before calling <code>makeBigger</code>, <code>s</code>'s height is the same as its width;</p>
<p class="indenthanding">• Inside <code>makeBigger</code>, <code>s</code>'s width is changed, but its height is not;</p>
<p class="indenthanding">• <a id="page_155"></a>After returning from <code>makeBigger</code>, <code>s</code>'s height is again the same as its width. (Note that <code>s</code> is passed to <code>makeBigger</code> by reference, so <code>makeBigger</code> modifies <code>s</code> itself, not a copy of <code>s</code>.)</p>
<p class="noindent">Well?</p>
<p class="noindent">Welcome to the wonderful world of public inheritance, where the instincts you've developed in other fields of study — including mathematics — may not serve you as well as you expect. The fundamental difficulty in this case is that something applicable to a rectangle (its width may be modified independently of its height) is not applicable to a square (its width and height must be the same). But public inheritance asserts that everything that applies to base class objects — <em>everything!</em> — also applies to derived class objects. In the case of rectangles and squares (as well as an example involving sets and lists in <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec7">Item 38</a>), that assertion fails to hold, so using public inheritance to model their relationship is simply incorrect. Compilers will let you do it, but as we've just seen, that's no guarantee the code will behave properly. As every programmer must learn (some more often than others), just because the code compiles doesn't mean it will work.</p>
<p class="noindent">Don't fret that the software intuition you've developed over the years will fail you as you approach object-oriented design. That knowledge is still valuable, but now that you've added inheritance to your arsenal of design alternatives, you'll have to augment your intuition with new insights to guide you in inheritance's proper application. In time, the notion of having <code>Penguin</code> inherit from <code>Bird</code> or <code>Square</code> inherit from <code>Rectangle</code> will give you the same funny feeling you probably get now when somebody shows you a function several pages long. It's <em>possibly</em> the right way to approach things, it's just not very likely.</p>
<p class="noindent">The is-a relationship is not the only one that can exist between classes. Two other common inter-class relationships are “has-a” and “is-implemented-in-terms-of.” These relationships are considered in <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec7">Items 38</a> and <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec8">39</a>. It's not uncommon for C++ designs to go awry because one of these other important relationships was incorrectly modeled as is-a, so you should make sure that you understand the differences among these relationships and that you know how each is best modeled in C++.</p>
<div class="note">
<h3 id="ch06note01">Things to Remember</h3>
<p class="indenthanding">• Public inheritance means “is-a.” Everything that applies to base classes must also apply to derived classes, because every derived class object <em>is</em> a base class object.</p>
</div>
<h3 id="ch06lev1sec2">Item 33: Avoid hiding inherited names</h3>
<p class="noindent"><a id="page_156"></a>Shakespeare had a thing about names. “What's in a name?” he asked, “A rose by any other name would smell as sweet.” The Bard also wrote, “he that filches from me my good name ... makes me poor indeed.” Right. Which brings us to inherited names in C++.</p>
<p class="noindent">The matter actually has nothing to do with inheritance. It has to do with scopes. We all know that in code like this,</p>
<p class="codelink"><a id="procode227"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode227">Click here to view code image</a></p>
<p class="programlisting"><br>int x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// global variable<br><br>void someFunc()<br>{<br>&nbsp;&nbsp;double x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// local variable<br><br>&nbsp;&nbsp;std::cin &gt;&gt; <span class="courierb">x</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// read a new value for local x<br>}<br></p>
<p class="noindent">the statement reading into <code>x</code> refers to the local variable <code>x</code> instead of the global variable <code>x</code>, because names in inner scopes hide (“shadow”) names in outer scopes. We can visualize the scope situation this way:</p>
<p class="mediaobject"><img src="https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/graphics/06inf02.gif" alt="images" width="250" height="93" data-mfp-src="/library/view/effective-c-55/0321334876/graphics/06inf02.gif"></p>
<p class="noindent">When compilers are in <code>someFunc</code>'s scope and they encounter the name <code>x</code>, they look in the local scope to see if there is something with that name. Because there is, they never examine any other scope. In this case, <code>someFunc</code>'s <code>x</code> is of type <code>double</code> and the global <code>x</code> is of type <code>int</code>, but that doesn't matter. C++'s name-hiding rules do just that: hide <em>names</em>. Whether the names correspond to the same or different types is immaterial. In this case, a <code>double</code> named <code>x</code> hides an <code>int</code> named <code>x</code>.</p>
<p class="noindent">Enter inheritance. We know that when we're inside a derived class member function and we refer to something in a base class (e.g., a member function, a typedef, or a data member), compilers can find what we're referring to because derived classes inherit the things declared in base classes. The way that actually works is that the scope of a derived class is nested inside its base class's scope. For example:</p>
<p class="programlisting"><br><br><a id="page_157"></a>class Base {<br>private:<br>&nbsp;&nbsp;int x;<br><br>public:<br>&nbsp;&nbsp;virtual void mf1() = 0;<br>&nbsp;&nbsp;virtual void mf2();<br>&nbsp;&nbsp;void mf3();<br><br>&nbsp;&nbsp;...<br>};<br><br>class Derived: public Base {<br>public:<br>&nbsp;&nbsp;virtual void mf1();<br>&nbsp;&nbsp;void mf4();<br><br>&nbsp;&nbsp;...<br>};<br><img src="https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/graphics/06inf03.gif" alt="images" width="300" height="248" data-mfp-src="/library/view/effective-c-55/0321334876/graphics/06inf03.gif"></p>
<p class="noindent">This example includes a mix of public and private names as well as names of both data members and member functions. The member functions are pure virtual, simple (impure) virtual, and non-virtual. That's to emphasize that we're talking about <em>names</em>. The example could also have included names of types, e.g., enums, nested classes, and typedefs. The only thing that matters in this discussion is that they're names. What they're names <em>of</em> is irrelevant. The example uses single inheritance, but once you understand what's happening under single inheritance, C++'s behavior under multiple inheritance is easy to anticipate.</p>
<p class="noindent">Suppose <code>mf4</code> in the derived class is implemented, in part, like this:</p>
<p class="programlisting"><br>void Derived::mf4()<br>{<br><br>&nbsp;&nbsp;...<br>&nbsp;&nbsp;<span class="courierb">mf2();</span><br><br>&nbsp;&nbsp;...<br>}<br></p>
<p class="noindent">When compilers see the use of the name <code>mf2</code> here, they have to figure out what it refers to. They do that by searching scopes for a declaration of something named <code>mf2</code>. First they look in the local scope (that of <code>mf4</code>), but they find no declaration for anything called <code>mf2</code>. They then search the containing scope, that of the class <code>Derived</code>. They still find nothing named <code>mf2</code>, so they move on to the next containing scope, that of the base class. There they find something named <code>mf2</code>, so the search stops. If there were no <code>mf2</code> in <code>Base</code>, the search would continue, <a id="page_158"></a>first to the namespace(s) containing <code>Base</code>, if any, and finally to the global scope.</p>
<p class="noindent">The process I just described is accurate, but it's not a comprehensive description of how names are found in C++. Our goal isn't to know enough about name lookup to write a compiler, however. It's to know enough to avoid unpleasant surprises, and for that task, we already have plenty of information.</p>
<p class="noindent">Consider the previous example again, except this time let's overload <code>mf1</code> and <code>mf3</code>, and let's add a version of <code>mf3</code> to <code>Derived</code>. (As <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec5">Item 36</a> explains, <code>Derived</code>'s overloading of <code>mf3</code> — an inherited non-virtual function — makes this design instantly suspicious, but in the interest of understanding name visibility under inheritance, we'll overlook that.)</p>
<p class="programlisting"><br>class Base {<br>private:<br>&nbsp;&nbsp;int x;<br><br>public:<br>&nbsp;&nbsp;virtual void mf1() = 0;<br>&nbsp;&nbsp;<span class="courierb">virtual void mf1(int);</span><br><br>&nbsp;&nbsp;virtual void mf2();<br><br>&nbsp;&nbsp;void mf3();<br>&nbsp;&nbsp;<span class="courierb">void mf3(double);</span><br>&nbsp;&nbsp;...<br>};<br><br>class Derived: public Base {<br>public:<br>&nbsp;&nbsp;virtual void mf1();<br>&nbsp;&nbsp;<span class="courierb">void mf3();</span><br>&nbsp;&nbsp;void mf4();<br>&nbsp;&nbsp;...<br>};<br><img src="https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/graphics/06inf04.gif" alt="images" width="300" height="262" data-mfp-src="/library/view/effective-c-55/0321334876/graphics/06inf04.gif"></p>
<p class="noindent">This code leads to behavior that surprises every C++ programmer the first time they encounter it. The scope-based name hiding rule hasn't changed, so <em>all</em> functions named <code>mf1</code> and <code>mf3</code> in the base class are hidden by the functions named <code>mf1</code> and <code>mf3</code> in the derived class. From the perspective of name lookup, <code>Base::mf1</code> and <code>Base::mf3</code> are no longer inherited by <code>Derived</code>!</p>
<p class="codelink"><a id="procode228"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode228">Click here to view code image</a></p>
<p class="programlisting"><br>Derived d;<br>int x;<br><br>...<br>d.mf1();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fine, calls Derived::mf1<br>d.mf1(x);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error! Derived::mf1 hides Base::mf1<br><br><a id="page_159"></a>d.mf2();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fine, calls Base::mf2<br><br>d.mf3();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fine, calls Derived::mf3<br>d.mf3(x);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error! Derived::mf3 hides Base::mf3<br></p>
<p class="noindent">As you can see, this applies even though the functions in the base and derived classes take different parameter types, and it also applies regardless of whether the functions are virtual or non-virtual. In the same way that, at the beginning of this Item, the <code>double x</code> in the function <code>someFunc</code> hides the <code>int x</code> at global scope, here the function <code>mf3</code> in <code>Derived</code> hides a <code>Base</code> function named <code>mf3</code> that has a different type.</p>
<p class="noindent">The rationale behind this behavior is that it prevents you from accidentally inheriting overloads from distant base classes when you create a new derived class in a library or application framework. Unfortunately, you typically <em>want</em> to inherit the overloads. In fact, if you're using public inheritance and you don't inherit the overloads, you're violating the is-a relationship between base and derived classes that <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec1">Item 32</a> explains is fundamental to public inheritance. That being the case, you'll almost always want to override C++'s default hiding of inherited names.</p>
<p class="noindent">You do it with <em><code>using</code> declarations</em>:</p>
<p class="codelink"><a id="procode229"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode229">Click here to view code image</a></p>
<p class="programlisting"><br>class Base {<br>private:<br>&nbsp;&nbsp;int x;<br><br>public:<br>&nbsp;&nbsp;virtual void mf1() = 0;<br>&nbsp;&nbsp;virtual void mf1(int);<br><br>&nbsp;&nbsp;virtual void mf2();<br><br>&nbsp;&nbsp;void mf3();<br>&nbsp;&nbsp;void mf3(double);<br>&nbsp;&nbsp;...<br>};<br><br>class Derived: public Base {<br>public:<br>&nbsp;&nbsp;<span class="courierb">using Base::mf1;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// make all things in Base named mf1 and mf3<br>&nbsp;&nbsp;<span class="courierb">using Base::mf3;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// visible (and public) in Derived's scope<br><br>&nbsp;&nbsp;virtual void mf1();<br>&nbsp;&nbsp;void mf3();<br>&nbsp;&nbsp;void mf4();<br>&nbsp;&nbsp;...<br>};<br><img src="https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/graphics/06inf05.gif" alt="images" width="300" height="226" data-mfp-src="/library/view/effective-c-55/0321334876/graphics/06inf05.gif"></p>
<p class="noindent">Now inheritance will work as expected:</p>
<p class="codelink"><a id="procode230"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode230">Click here to view code image</a></p>
<p class="programlisting"><br><br><a id="page_160"></a>Derived d;<br>int x;<br><br>...<br><br>d.mf1();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// still fine, still calls Derived::mf1<br>d.mf1(x);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <span class="courierb">now okay, calls Base::mf1</span><br><br>d.mf2();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// still fine, still calls Base::mf2<br><br>d.mf3();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fine, calls Derived::mf3<br>d.mf3(x);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <span class="courierb">now okay, calls Base::mf3</span><br></p>
<p class="noindent">This means that if you inherit from a base class with overloaded functions and you want to redefine or override only some of them, you need to include a <code>using</code> declaration for each name you'd otherwise be hiding. If you don't, some of the names you'd like to inherit will be hidden.</p>
<p class="noindent">It's conceivable that you sometimes won't want to inherit all the functions from your base classes. Under public inheritance, this should never be the case, because, again, it violates public inheritance's is-a relationship between base and derived classes. (That's why the <code>using</code> declarations above are in the public part of the derived class: names that are public in a base class should also be public in a publicly derived class.) Under private inheritance (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec8">Item 39</a>), however, it can make sense. For example, suppose <code>Derived</code> privately inherits from <code>Base</code>, and the only version of <code>mf1</code> that <code>Derived</code> wants to inherit is the one taking no parameters. A <code>using</code> declaration won't do the trick here, because a <code>using</code> declaration makes <em>all</em> inherited functions with a given name visible in the derived class. No, this is a case for a different technique, namely, a simple forwarding function:</p>
<p class="codelink"><a id="procode231"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode231">Click here to view code image</a></p>
<p class="programlisting"><br>class Base {<br>public:<br>&nbsp;&nbsp;virtual void mf1() = 0;<br>&nbsp;&nbsp;virtual void mf1(int);<br><br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// as before<br>};<br><br>class Derived: <span class="courierb">private</span> Base {<br>public:<br>&nbsp;&nbsp;<span class="courierb">virtual void mf1()</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// forwarding function; implicitly<br>&nbsp;&nbsp;<span class="courierb">{ Base::mf1(); }</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// inline (see Item<br>30)<br>&nbsp;&nbsp;...<br>};<br><br>...<br><br>Derived d;<br>int x;<br><br>d.mf1();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fine, calls Derived::mf1<br>d.mf1(x);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error! Base::mf1() is hidden<br></p>
<p class="noindent"><a id="page_161"></a>Another use for inline forwarding functions is to work around ancient compilers that (incorrectly) don't support <code>using</code> declarations to import inherited names into the scope of a derived class.</p>
<p class="noindent">That's the whole story on inheritance and name hiding, but when inheritance is combined with templates, an entirely different form of the “inherited names are hidden” issue arises. For all the angle-bracket-demarcated details, see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch07.html#ch07lev1sec3">Item 43</a>.</p>
<div class="note">
<h3 id="ch06note02">Things to Remember</h3>
<p class="indenthanding">• Names in derived classes hide names in base classes. Under public inheritance, this is never desirable.</p>
<p class="indenthanding">• To make hidden names visible again, employ <code>using</code> declarations or forwarding functions.</p>
</div>
<h3 id="ch06lev1sec3">Item 34: Differentiate between inheritance of interface and inheritance of implementation</h3>
<p class="noindent">The seemingly straightforward notion of (public) inheritance turns out, upon closer examination, to be composed of two separable parts: inheritance of function interfaces and inheritance of function implementations. The difference between these two kinds of inheritance corresponds exactly to the difference between function declarations and function definitions discussed in the Introduction to this book.</p>
<p class="noindent">As a class designer, you sometimes want derived classes to inherit only the interface (declaration) of a member function. Sometimes you want derived classes to inherit both a function's interface and implementation, but you want to allow them to override the implementation they inherit. And sometimes you want derived classes to inherit a function's interface and implementation without allowing them to override anything.</p>
<p class="noindent">To get a better feel for the differences among these options, consider a class hierarchy for representing geometric shapes in a graphics application:</p>
<p class="programlisting"><br>class Shape {<br>public:<br>&nbsp;&nbsp;virtual void draw() const = 0;<br><br>&nbsp;&nbsp;virtual void error(const std::string&amp; msg);<br><br>&nbsp;&nbsp;int objectID() const;<br><br>&nbsp;&nbsp;...<br>};<br><br>class Rectangle: public Shape { ... };<br><br>class Ellipse: public Shape { ... };<br></p>
<p class="noindent"><a id="page_162"></a><code>Shape</code> is an abstract class; its pure virtual function <code>draw</code> marks it as such. As a result, clients cannot create instances of the <code>Shape</code> class, only of classes derived from it. Nonetheless, <code>Shape</code> exerts a strong influence on all classes that (publicly) inherit from it, because</p>
<p class="indenthanding">• Member function <em>interfaces are always inherited</em>. As explained in <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec1">Item 32</a>, public inheritance means is-a, so anything that is true of a base class must also be true of its derived classes. Hence, if a function applies to a class, it must also apply to its derived classes.</p>
<p class="noindent">Three functions are declared in the <code>Shape</code> class. The first, <code>draw</code>, draws the current object on an implicit display. The second, <code>error</code>, is called by member functions if they need to report an error. The third, <code>objectID</code>, returns a unique integer identifier for the current object. Each function is declared in a different way: <code>draw</code> is a pure virtual function; <code>error</code> is a simple (impure?) virtual function; and <code>objectID</code> is a non-virtual function. What are the implications of these different declarations?</p>
<p class="noindent">Consider first the pure virtual function <code>draw</code>:</p>
<p class="programlisting"><br>class Shape {<br>public:<br>&nbsp;&nbsp;<span class="courierb">virtual void draw() const = 0;</span><br>&nbsp;&nbsp;...<br>};<br></p>
<p class="noindent">The two most salient features of pure virtual functions are that they <em>must</em> be redeclared by any concrete class that inherits them, and they typically have no definition in abstract classes. Put these two characteristics together, and you realize that</p>
<p class="indenthanding">• The purpose of declaring a pure virtual function is to have derived classes inherit a function <em>interface only</em>.</p>
<p class="noindent">This makes perfect sense for the <code>Shape::draw</code> function, because it is a reasonable demand that all <code>Shape</code> objects must be <code>draw</code>able, but the <code>Shape</code> class can provide no reasonable default implementation for that function. The algorithm for drawing an ellipse is very different from the algorithm for drawing a rectangle, for example. The declaration of <code>Shape::draw</code> says to designers of concrete derived classes, “You must provide a <code>draw</code> function, but I have no idea how you're going to implement it.”</p>
<p class="noindent">Incidentally, it <em>is</em> possible to provide a definition for a pure virtual function. That is, you could provide an implementation for <code>Shape::draw</code>, and C++ wouldn't complain, but the only way to call it would be to qualify the call with the class name:</p>
<p class="codelink"><a id="procode232"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode232">Click here to view code image</a></p>
<p class="programlisting"><br><br><a id="page_163"></a>Shape *ps = new Shape;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error! Shape is abstract<br><br>Shape *ps1 = new Rectangle;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fine<br>ps1-&gt;draw();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls Rectangle::draw<br><br>Shape *ps2 = new Ellipse;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fine<br>ps2-&gt;draw();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls Ellipse::draw<br><br>ps1-&gt;<span class="courierb">Shape::draw</span>();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls Shape::draw<br><br>ps2-&gt;<span class="courierb">Shape::draw</span>();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls Shape::draw<br></p>
<p class="noindent">Aside from helping you impress fellow programmers at cocktail parties, knowledge of this feature is generally of limited utility. As you'll see below, however, it can be employed as a mechanism for providing a safer-than-usual default implementation for simple (impure) virtual functions.</p>
<p class="noindent">The story behind simple virtual functions is a bit different from that behind pure virtuals. As usual, derived classes inherit the interface of the function, but simple virtual functions provide an implementation that derived classes may override. If you think about this for a minute, you'll realize that</p>
<p class="indenthanding">• The purpose of declaring a simple virtual function is to have derived classes inherit a function <em>interface as well as a default implementation</em>.</p>
<p class="noindent">Consider the case of <code>Shape::error</code>:</p>
<p class="programlisting"><br>class Shape {<br>public:<br>&nbsp;&nbsp;<span class="courierb">virtual void error(const std::string&amp; msg)</span>;<br>&nbsp;&nbsp;...<br>};<br></p>
<p class="noindent">The interface says that every class must support a function to be called when an error is encountered, but each class is free to handle errors in whatever way it sees fit. If a class doesn't want to do anything special, it can just fall back on the default error handling provided in the <code>Shape</code> class. That is, the declaration of <code>Shape::error</code> says to designers of derived classes, “You've got to support an <code>error</code> function, but if you don't want to write your own, you can fall back on the default version in the <code>Shape</code> class.”</p>
<p class="noindent">It turns out that it can be dangerous to allow simple virtual functions to specify both a function interface and a default implementation. To see why, consider a hierarchy of airplanes for XYZ Airlines. XYZ has only two kinds of planes, the Model A and the Model B, and both are flown in exactly the same way. Hence, XYZ designs the following hierarchy:</p>
<p class="codelink"><a id="procode233"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode233">Click here to view code image</a></p>
<p class="programlisting"><br><br><a id="page_164"></a>class Airport { ... };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// represents airports<br><br>class Airplane {<br>public:<br>&nbsp;&nbsp;virtual void fly(const Airport&amp; destination);<br><br>&nbsp;&nbsp;...<br><br>};<br><br>void Airplane::fly(const Airport&amp; destination)<br>{<br>&nbsp;&nbsp;<span class="courieri">default code for flying an airplane to the given destination</span><br>}<br><br>class ModelA: public Airplane { ... };<br><br>class ModelB: public Airplane { ... };<br></p>
<p class="noindent">To express that all planes have to support a <code>fly</code> function, and in recognition of the fact that different models of plane could, in principle, require different implementations for <code>fly</code>, <code>Airplane::fly</code> is declared virtual. However, in order to avoid writing identical code in the <code>ModelA</code> and <code>ModelB</code> classes, the default flying behavior is provided as the body of <code>Airplane::fly</code>, which both <code>ModelA</code> and <code>ModelB</code> inherit.</p>
<p class="noindent">This is a classic object-oriented design. Two classes share a common feature (the way they implement <code>fly</code>), so the common feature is moved into a base class, and the feature is inherited by the two classes. This design makes common features explicit, avoids code duplication, facilitates future enhancements, and eases long-term maintenance — all the things for which object-oriented technology is so highly touted. XYZ Airlines should be proud.</p>
<p class="noindent">Now suppose that XYZ, its fortunes on the rise, decides to acquire a new type of airplane, the Model C. The Model C differs in some ways from the Model A and the Model B. In particular, it is flown differently.</p>
<p class="noindent">XYZ's programmers add the class for Model C to the hierarchy, but in their haste to get the new model into service, they forget to redefine the <code>fly</code> function:</p>
<p class="codelink"><a id="procode234"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode234">Click here to view code image</a></p>
<p class="programlisting"><br>class ModelC: public Airplane {<br><br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// no fly function is declared<br>};<br></p>
<p class="noindent">In their code, then, they have something akin to the following:</p>
<p class="codelink"><a id="procode235"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode235">Click here to view code image</a></p>
<p class="programlisting"><br>Airport PDX(...);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// PDX is the airport near my home<br><br>Airplane *pa = new ModelC;<br><br>...<br><br>pa-&gt;fly(PDX);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls Airplane::fly!<br></p>
<p class="noindent"><a id="page_165"></a>This is a disaster: an attempt is being made to fly a <code>ModelC</code> object as if it were a <code>ModelA</code> or a <code>ModelB</code>. That's not the kind of behavior that inspires confidence in the traveling public.</p>
<p class="noindent">The problem here is not that <code>Airplane::fly</code> has default behavior, but that <code>ModelC</code> was allowed to inherit that behavior without explicitly saying that it wanted to. Fortunately, it's easy to offer default behavior to derived classes but not give it to them unless they ask for it. The trick is to sever the connection between the <em>interface</em> of the virtual function and its default <em>implementation</em>. Here's one way to do it:</p>
<p class="codelink"><a id="procode236"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode236">Click here to view code image</a></p>
<p class="programlisting"><br>class Airplane {<br>public:<br>&nbsp;&nbsp;virtual void fly(const Airport&amp; destination) <span class="courierb">= 0</span>;<br><br>&nbsp;&nbsp;...<br><br><span class="courierb">protected:</span><br>&nbsp;&nbsp;<span class="courierb">void defaultFly(const Airport&amp; destination);</span><br>};<br><br>void Airplane::defaultFly(const Airport&amp; destination)<br>{<br>&nbsp;&nbsp;<span class="courieri">default code for flying an airplane to the given destination</span><br>}<br></p>
<p class="noindent">Notice how <code>Airplane::fly</code> has been turned into a <em>pure</em> virtual function. That provides the interface for flying. The default implementation is also present in the <code>Airplane</code> class, but now it's in the form of an independent function, <code>defaultFly</code>. Classes like <code>ModelA</code> and <code>ModelB</code> that want to use the default behavior simply make an inline call to <code>defaultFly</code> inside their body of <code>fly</code> (but see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch05.html#ch05lev1sec5">Item 30</a> for information on the interaction of inlining and virtual functions):</p>
<p class="codelink"><a id="procode237"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode237">Click here to view code image</a></p>
<p class="programlisting"><br>class ModelA: public Airplane {<br>public:<br>&nbsp;&nbsp;virtual void fly(const Airport&amp; destination)<br>&nbsp;&nbsp;{ <span class="courierb">defaultFly(destination);</span> }<br><br>&nbsp;&nbsp;...<br>};<br><br>class ModelB: public Airplane {<br>public:<br>&nbsp;&nbsp;virtual void fly(const Airport&amp; destination)<br>&nbsp;&nbsp;{ <span class="courierb">defaultFly(destination);</span> }<br><br>&nbsp;&nbsp;...<br>};<br></p>
<p class="noindent"><a id="page_166"></a>For the <code>ModelC</code> class, there is no possibility of accidentally inheriting the incorrect implementation of <code>fly</code>, because the pure virtual in <code>Airplane</code> forces <code>ModelC</code> to provide its own version of <code>fly</code>.</p>
<p class="codelink"><a id="procode238"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode238">Click here to view code image</a></p>
<p class="programlisting"><br>class ModelC: public Airplane {<br>public:<br>&nbsp;&nbsp;<span class="courierb">virtual void fly(const Airport&amp; destination);</span><br><br>&nbsp;&nbsp;...<br>};<br><br>void ModelC::fly(const Airport&amp; destination)<br>{<br>&nbsp;&nbsp;<span class="courieri">code for flying a ModelC airplane to the given destination</span><br>}<br></p>
<p class="noindent">This scheme isn't foolproof (programmers can still copy-and-paste themselves into trouble), but it's more reliable than the original design. As for <code>Airplane::defaultFly</code>, it's protected because it's truly an implementation detail of <code>Airplane</code> and its derived classes. Clients using airplanes should care only that they can be flown, not how the flying is implemented.</p>
<p class="noindent">It's also important that <code>Airplane::defaultFly</code> is a <em>non-virtual</em> function. This is because no derived class should redefine this function, a truth to which <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec5">Item 36</a> is devoted. If <code>defaultFly</code> were virtual, you'd have a circular problem: what if some derived class forgets to redefine <code>defaultFly</code> when it's supposed to?</p>
<p class="noindent">Some people object to the idea of having separate functions for providing interface and default implementation, such as <code>fly</code> and <code>defaultFly</code> above. For one thing, they note, it pollutes the class namespace with a proliferation of closely related function names. Yet they still agree that interface and default implementation should be separated. How do they resolve this seeming contradiction? By taking advantage of the fact that pure virtual functions must be redeclared in concrete derived classes, but they may also have implementations of their own. Here's how the <code>Airplane</code> hierarchy could take advantage of the ability to define a pure virtual function:</p>
<p class="codelink"><a id="procode239"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode239">Click here to view code image</a></p>
<p class="programlisting"><br>class Airplane {<br>public:<br>&nbsp;&nbsp;virtual void fly(const Airport&amp; destination) <span class="courierb">= 0</span>;<br><br>&nbsp;&nbsp;...<br>};<br><br><a id="page_167"></a><br><span class="courierb">void Airplane::fly(const Airport&amp; destination)</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// an implementation of<br><span class="courierb">{</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// a pure virtual function<br>&nbsp;&nbsp;<span class="courierb"><span class="courieri">default code for flying an airplane to</span></span><br>&nbsp;&nbsp;<span class="courierb"><span class="courieri">the given destination</span></span><br>}<br><br>class ModelA: public Airplane {<br>public:<br>&nbsp;&nbsp;virtual void fly(const Airport&amp; destination)<br>&nbsp;&nbsp;{ <span class="courierb">Airplane::fly</span>(destination); }<br><br>&nbsp;&nbsp;...<br><br>};<br><br>class ModelB: public Airplane {<br>public:<br>&nbsp;&nbsp;virtual void fly(const Airport&amp; destination)<br>&nbsp;&nbsp;{ <span class="courierb">Airplane::fly</span>(destination); }<br><br>&nbsp;&nbsp;...<br><br>};<br><br>class ModelC: public Airplane {<br>public:<br>&nbsp;&nbsp;virtual void fly(const Airport&amp; destination);<br><br>&nbsp;&nbsp;...<br><br>};<br><br>void ModelC::fly(const Airport&amp; destination)<br>{<br>&nbsp;&nbsp;<span class="courieri">code for flying a ModelC airplane to the given destination</span><br>}<br></p>
<p class="noindent">This is almost exactly the same design as before, except that the body of the pure virtual function <code>Airplane::fly</code> takes the place of the independent function <code>Airplane::defaultFly</code>. In essence, <code>fly</code> has been broken into its two fundamental components. Its declaration specifies its interface (which derived classes <em>must</em> use), while its definition specifies its default behavior (which derived classes <em>may</em> use, but only if they explicitly request it). In merging <code>fly</code> and <code>defaultFly</code>, however, you've lost the ability to give the two functions different protection levels: the code that used to be protected (by being in <code>defaultFly</code>) is now public (because it's in <code>fly</code>).</p>
<p class="noindent">Finally, we come to <code>Shape</code>'s non-virtual function, <code>objectID</code>:</p>
<p class="programlisting"><br>class Shape {<br>public:<br>&nbsp;&nbsp;<span class="courierb">int objectID() const;</span><br>&nbsp;&nbsp;...<br>};<br></p>
<p class="noindent"><a id="page_168"></a>When a member function is non-virtual, it's not supposed to behave differently in derived classes. In fact, a non-virtual member function specifies an <em>invariant over specialization</em>, because it identifies behavior that is not supposed to change, no matter how specialized a derived class becomes. As such,</p>
<p class="indenthanding">• The purpose of declaring a non-virtual function is to have derived classes inherit a function <em>interface as well as a mandatory implementation</em>.</p>
<p class="noindent">You can think of the declaration for <code>Shape::objectID</code> as saying, “Every <code>Shape</code> object has a function that yields an object identifier, and that object identifier is always computed the same way. That way is determined by the definition of <code>Shape::objectID</code>, and no derived class should try to change how it's done.” Because a non-virtual function identifies an <em>invariant</em> over specialization, it should never be redefined in a derived class, a point that is discussed in detail in <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec5">Item 36</a>.</p>
<p class="noindent">The differences in declarations for pure virtual, simple virtual, and non-virtual functions allow you to specify with precision what you want derived classes to inherit: interface only, interface and a default implementation, or interface and a mandatory implementation, respectively. Because these different types of declarations mean fundamentally different things, you must choose carefully among them when you declare your member functions. If you do, you should avoid the two most common mistakes made by inexperienced class designers.</p>
<p class="noindent">The first mistake is to declare all functions non-virtual. That leaves no room for specialization in derived classes; non-virtual destructors are particularly problematic (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch02.html#ch02lev1sec3">Item 7</a>). Of course, it's perfectly reasonable to design a class that is not intended to be used as a base class. In that case, a set of exclusively non-virtual member functions is appropriate. Too often, however, such classes are declared either out of ignorance of the differences between virtual and non-virtual functions or as a result of an unsubstantiated concern over the performance cost of virtual functions. The fact of the matter is that almost any class that's to be used as a base class will have virtual functions (again, see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch02.html#ch02lev1sec3">Item 7</a>).</p>
<p class="noindent">If you're concerned about the cost of virtual functions, allow me to bring up the empirically-based rule of 80-20 (see also <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch05.html#ch05lev1sec5">Item 30</a>), which states that in a typical program, 80% of the runtime will be spent executing just 20% of the code. This rule is important, because it means that, on average, 80% of your function calls can be virtual without having the slightest detectable impact on your program's overall performance. Before you go gray worrying about whether you can afford <a id="page_169"></a>the cost of a virtual function, take the simple precaution of making sure that you're focusing on the 20% of your program where the decision might really make a difference.</p>
<p class="noindent">The other common problem is to declare <em>all</em> member functions virtual. Sometimes this is the right thing to do — witness <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch05.html#ch05lev1sec6">Item 31</a>'s Interface classes. However, it can also be a sign of a class designer who lacks the backbone to take a stand. Some functions should <em>not</em> be redefinable in derived classes, and whenever that's the case, you've got to say so by making those functions non-virtual. It serves no one to pretend that your class can be all things to all people if they'll just take the time to redefine all your functions. If you have an invariant over specialization, don't be afraid to say so!</p>
<div class="note">
<h3 id="ch06note03">Things to Remember</h3>
<p class="indenthanding">• Inheritance of interface is different from inheritance of implementation. Under public inheritance, derived classes always inherit base class interfaces.</p>
<p class="indenthanding">• Pure virtual functions specify inheritance of interface only.</p>
<p class="indenthanding">• Simple (impure) virtual functions specify inheritance of interface plus inheritance of a default implementation.</p>
<p class="indenthanding">• Non-virtual functions specify inheritance of interface plus inheritance of a mandatory implementation.</p>
</div>
<h3 id="ch06lev1sec4">Item 35: Consider alternatives to virtual functions</h3>
<p class="noindent">So you're working on a video game, and you're designing a hierarchy for characters in the game. Your game being of the slash-and-burn variety, it's not uncommon for characters to be injured or otherwise in a reduced state of health. You therefore decide to offer a member function, <code>healthValue</code>, that returns an integer indicating how healthy the character is. Because different characters may calculate their health in different ways, declaring <code>healthValue</code> virtual seems the obvious way to design things:</p>
<p class="codelink"><a id="procode240"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode240">Click here to view code image</a></p>
<p class="programlisting"><br>class GameCharacter {<br>public:<br>&nbsp;&nbsp;<span class="courierb">virtual int healthValue() const</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// return character's health rating;<br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// derived classes may redefine this<br>};<br></p>
<p class="noindent">The fact that <code>healthValue</code> isn't declared pure virtual suggests that there is a default algorithm for calculating health (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec3">Item 34</a>).</p>
<p class="noindent"><a id="page_170"></a>This is, indeed, the obvious way to design things, and in some sense, that's its weakness. Because this design is so obvious, you may not give adequate consideration to its alternatives. In the interest of helping you escape the ruts in the road of object-oriented design, let's consider some other ways to approach this problem.</p>
<h3 id="ch06lev2sec1">The Template Method Pattern via the Non-Virtual Interface Idiom</h3>
<p class="noindent">We'll begin with an interesting school of thought that argues that virtual functions should almost always be private. Adherents to this school would suggest that a better design would retain <code>healthValue</code> as a public member function but make it non-virtual and have it call a private virtual function to do the real work, say, <code>doHealthValue</code>:</p>
<p class="codelink"><a id="procode241"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode241">Click here to view code image</a></p>
<p class="programlisting"><br>class GameCharacter {<br>public:<br>&nbsp;&nbsp;<span class="courierb">int healthValue() const</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// derived classes do <span class="courieri">not</span> redefine<br>&nbsp;&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this — see Item 36<br><br>&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do "before" stuff — see below<br><br>&nbsp;&nbsp;&nbsp;&nbsp;int retVal = doHealthValue();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do the real work<br><br>&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do "after" stuff — see below<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return retVal;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;...<br><br>private:<br>&nbsp;&nbsp;<span class="courierb">virtual int doHealthValue() const</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// derived classes may redefine this<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// default algorithm for calculating<br>&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// character's health<br>};<br></p>
<p class="noindent">In this code (and for the rest of this Item), I'm showing the bodies of member functions in class definitions. As <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch05.html#ch05lev1sec5">Item 30</a> explains, that implicitly declares them <code>inline</code>. I'm showing the code this way only to make it easier to see what is going on. The designs I'm describing are independent of inlining decisions, so don't think it's meaningful that the member functions are defined inside classes. It's not.</p>
<p class="noindent">This basic design — having clients call private virtual functions indirectly through public non-virtual member functions — is known as the <em>non-virtual interface (<em>NVI</em>) idiom</em>. It's a particular manifestation of the more general design pattern called Template Method (a pattern that, unfortunately, has nothing to do with C++ templates). I call the non-virtual function (e.g., <code>healthValue</code>) the virtual function's <em>wrapper</em>.</p>
<p class="noindent"><a id="page_171"></a>An advantage of the NVI idiom is suggested by the “do 'before' stuff” and “do 'after' stuff” comments in the code. Those comments identify code segments guaranteed to be called before and after the virtual function that does the real work. This means that the wrapper ensures that before a virtual function is called, the proper context is set up, and after the call is over, the context is cleaned up. For example, the “before” stuff could include locking a mutex, making a log entry, verifying that class invariants and function preconditions are satisfied, etc. The “after” stuff could include unlocking a mutex, verifying function postconditions, reverifying class invariants, etc. There's not really any good way to do that if you let clients call virtual functions directly.</p>
<p class="noindent">It may have crossed your mind that the NVI idiom involves derived classes redefining private virtual functions — redefining functions they can't call! There's no design contradiction here. Redefining a virtual function specifies <em>how</em> something is to be done. Calling a virtual function specifies <em>when</em> it will be done. These concerns are independent. The NVI idiom allows derived classes to redefine a virtual function, thus giving them control over <em>how</em> functionality is implemented, but the base class reserves for itself the right to say <em>when</em> the function will be called. It may seem odd at first, but C++'s rule that derived classes may redefine private inherited virtual functions is perfectly sensible.</p>
<p class="noindent">Under the NVI idiom, it's not strictly necessary that the virtual functions be private. In some class hierarchies, derived class implementations of a virtual function are expected to invoke their base class counterparts (e.g., the example on page <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch05.html#page_120">120</a>), and for such calls to be legal, the virtuals must be protected, not private. Sometimes a virtual function even has to be public (e.g., destructors in polymorphic base classes — see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch02.html#ch02lev1sec3">Item 7</a>), but then the NVI idiom can't really be applied.</p>
<h3 id="ch06lev2sec2">The Strategy Pattern via Function Pointers</h3>
<p class="noindent">The NVI idiom is an interesting alternative to public virtual functions, but from a design point of view, it's little more than window dressing. After all, we're still using virtual functions to calculate each character's health. A more dramatic design assertion would be to say that calculating a character's health is independent of the character's type — that such calculations need not be part of the character at all. For example, we could require that each character's constructor be passed a pointer to a health calculation function, and we could call that function to do the actual calculation:</p>
<p class="codelink"><a id="procode242"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode242">Click here to view code image</a></p>
<p class="programlisting"><br><br><a id="page_172"></a>class GameCharacter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// forward declaration<br><br>// function for the default health calculation algorithm<br>int defaultHealthCalc(const GameCharacter&amp; gc);<br><br>class GameCharacter {<br>public:<br>&nbsp;&nbsp;typedef int (*HealthCalcFunc)(const GameCharacter&amp;);<br><br>&nbsp;&nbsp;explicit GameCharacter(<span class="courierb">HealthCalcFunc hcf = defaultHealthCalc</span>)<br>&nbsp;&nbsp;: healthFunc(hcf)<br>&nbsp;&nbsp;{}<br><br>&nbsp;&nbsp;int healthValue() const<br>&nbsp;&nbsp;{ return <span class="courierb">healthFunc(*this)</span>; }<br><br>&nbsp;&nbsp;...<br><br>private:<br>&nbsp;&nbsp;<span class="courierb">HealthCalcFunc healthFunc;</span><br>};<br></p>
<p class="noindent">This approach is a simple application of another common design pattern, Strategy. Compared to approaches based on virtual functions in the <code>GameCharacter</code> hierarchy, it offers some interesting flexibility:</p>
<p class="indenthanding">• Different instances of the same character type can have different health calculation functions. For example:</p>
<p class="codelink"><a id="procode243"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode243">Click here to view code image</a></p>
<p class="programlisting1"><br>class EvilBadGuy: public GameCharacter {<br>public:<br>&nbsp;&nbsp;explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc)<br>&nbsp;&nbsp;: GameCharacter(hcf)<br>&nbsp;&nbsp;{ ... }<br><br>&nbsp;&nbsp;...<br><br>};<br>int loseHealthQuickly(const GameCharacter&amp;);&nbsp;&nbsp;&nbsp;&nbsp;// health calculation<br>int loseHealthSlowly(const GameCharacter&amp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// funcs with different<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// behavior<br><br>EvilBadGuy <span class="courierb">ebg1</span>(loseHealthQuickly);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// same-type charac-<br>EvilBadGuy <span class="courierb">ebg2</span>(loseHealthSlowly);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ters with different<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// health-related<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// behavior<br></p>
<p class="indenthanding">• Health calculation functions for a particular character may be changed at runtime. For example, <code>GameCharacter</code> might offer a member function, <code>setHealthCalculator</code>, that allowed replacement of the current health calculation function.</p>
<p class="noindent">On the other hand, the fact that the health calculation function is no longer a member function of the <code>GameCharacter</code> hierarchy means that it has no special access to the internal parts of the object whose <a id="page_173"></a>health it's calculating. For example, <code>defaultHealthCalc</code> has no access to the non-public parts of <code>EvilBadGuy</code>. If a character's health can be calculated based purely on information available through the character's public interface, this is not a problem, but if accurate health calculation requires non-public information, it is. In fact, it's a potential issue anytime you replace functionality inside a class (e.g., via a member function) with equivalent functionality outside the class (e.g., via a non-member non-friend function or via a non-friend member function of another class). This issue will persist for the remainder of this Item, because all the other design alternatives we're going to consider involve the use of functions outside the <code>GameCharacter</code> hierarchy.</p>
<p class="noindent">As a general rule, the only way to resolve the need for non-member functions to have access to non-public parts of a class is to weaken the class's encapsulation. For example, the class might declare the non-member functions to be <code>friend</code>s, or it might offer public accessor functions for parts of its implementation it would otherwise prefer to keep hidden. Whether the advantages of using a function pointer instead of a virtual function (e.g., the ability to have per-object health calculation functions and the ability to change such functions at runtime) offset the possible need to decrease <code>GameCharacter</code>'s encapsulation is something you must decide on a design-by-design basis.</p>
<h3 id="ch06lev2sec3">The Strategy Pattern via <code>tr1::function</code></h3>
<p class="noindent">Once you accustom yourself to templates and their use of implicit interfaces (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch07.html#ch07lev1sec1">Item 41</a>), the function-pointer-based approach looks rather rigid. Why must the health calculator be a function instead of simply something that <em>acts</em> like a function (e.g., a function object)? If it must be a function, why can't it be a member function? And why must it return an <code>int</code> instead of any type <em>convertible</em> to an <code>int</code>?</p>
<p class="noindent">These constraints evaporate if we replace the use of a function pointer (such as <code>healthFunc</code>) with an object of type <code>tr1::function</code>. As <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch09.html#ch09lev1sec2">Item 54</a> explains, such objects may hold <em>any callable entity</em> (i.e., function pointer, function object, or member function pointer) whose signature is compatible with what is expected. Here's the design we just saw, this time using <code>tr1::function</code>:</p>
<p class="codelink"><a id="procode244"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode244">Click here to view code image</a></p>
<p class="programlisting"><br>class GameCharacter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// as before<br>int defaultHealthCalc(const GameCharacter&amp; gc);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// as before<br><br>class GameCharacter {<br>public:<br>&nbsp;&nbsp;&nbsp;// HealthCalcFunc is any callable entity that can be called with<br>&nbsp;&nbsp;&nbsp;// anything compatible with a GameCharacter and that returns anything<br>&nbsp;&nbsp;&nbsp;// compatible with an int; see below for details<br>&nbsp;&nbsp;&nbsp;<span class="courierb">typedef std::tr1::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><br><a id="page_174"></a>&nbsp;&nbsp;&nbsp;explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc)<br>&nbsp;&nbsp;&nbsp;: healthFunc(hcf)<br>&nbsp;&nbsp;&nbsp;{}<br><br>&nbsp;&nbsp;&nbsp;int healthValue() const<br>&nbsp;&nbsp;&nbsp;{ return healthFunc(*this);&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;...<br><br>private:<br>&nbsp;&nbsp;HealthCalcFunc healthFunc;<br>};<br></p>
<p class="noindent">As you can see, <code>HealthCalcFunc</code> is a typedef for a <code>tr1::function</code> instantiation. That means it acts like a generalized function pointer type. Look closely at what <code>HealthCalcFunc</code> is a typedef for:</p>
<p class="programlisting"><br>std::tr1::function&lt;<span class="courierb">int (const GameCharacter&amp;)</span>&gt;<br></p>
<p class="noindent">Here I've highlighted the “target signature” of this <code>tr1::function</code> instantiation. That target signature is “function taking a reference to a <code>const GameCharacter</code> and returning an <code>int</code>.” An object of this <code>tr1::function</code> type (i.e., of type <code>HealthCalcFunc</code>) may hold any callable entity compatible with the target signature. To be compatible means that the entity's parameter can be implicitly converted to a <code>const GameCharacter&amp;</code> and its return type can be implicitly converted to an <code>int</code>.</p>
<p class="noindent">Compared to the last design we saw (where <code>GameCharacter</code> held a pointer to a function), this design is almost the same. The only difference is that <code>GameCharacter</code> now holds a <code>tr1::function</code> object — a <em>generalized</em> pointer to a function. This change is so small, I'd call it inconsequential, except that a consequence is that clients now have staggeringly more flexibility in specifying health calculation functions:</p>
<p class="codelink"><a id="procode245"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode245">Click here to view code image</a></p>
<p class="programlisting"><br>short calcHealth(const GameCharacter&amp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// health calculation<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// function; note<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// non-int return type<br><br>struct HealthCalculator {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// class for health<br>&nbsp;&nbsp;{ ... }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// objects<br>};<br><br>class GameLevel {<br>public:<br>&nbsp;&nbsp;float health(const GameCharacter&amp;) const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// health calculation<br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// mem function; note<br>};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// non-int return type<br><br><br>class EvilBadGuy: public GameCharacter {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// as before<br>&nbsp;&nbsp;...<br>};<br><br><a id="page_175"></a>class EyeCandyCharacter:&nbsp;&nbsp;&nbsp;public GameCharacter {&nbsp;&nbsp;// another character<br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// type; assume same<br>};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// constructor as<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// EvilBadGuy<br><br><br>EvilBadGuy ebg1(<span class="courierb">calcHealth</span>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// character using a<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// health calculation<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// function<br><br><br>EyeCandyCharacter ecc1(<span class="courierb">HealthCalculator()</span>);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// character using a<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// health calculation<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// function object<br><br>GameLevel currentLevel;<br>...<br>EvilBadGuy ebg2(&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// character using a<br>&nbsp;&nbsp;<span class="courierb">std::tr1::bind(&amp;GameLevel::health</span>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// health calculation<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="courierb">currentLevel,</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// member function;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="courierb">_1</span>)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// see below for details<br>);<br></p>
<p class="noindent">Personally, I find what <code>tr1::function</code> lets you do so amazing, it makes me tingle all over. If you're not tingling, it may be because you're staring at the definition of <code>ebg2</code> and wondering what's going on with the call to <code>tr1::bind</code>. Kindly allow me to explain.</p>
<p class="noindent">We want to say that to calculate <code>ebg2</code>'s health rating, the <code>health</code> member function in the <code>GameLevel</code> class should be used. Now, <code>GameLevel::health</code> is a function that is declared to take one parameter (a reference to a <code>GameCharacter</code>), but it really takes two, because it also gets an implicit <code>GameLevel</code> parameter — the one <code>this</code> points to. Health calculation functions for <code>GameCharacter</code>s, however, take a single parameter: the <code>GameCharacter</code> whose health is to be calculated. If we're to use <code>GameLevel::health</code> for <code>ebg2</code>'s health calculation, we have to somehow “adapt” it so that instead of taking two parameters (a <code>GameCharacter</code> and a <code>GameLevel</code>), it takes only one (a <code>GameCharacter</code>). In this example, we always want to use <code>currentLevel</code> as the <code>GameLevel</code> object for <code>ebg2</code>'s health calculation, so we “bind” <code>currentLevel</code> as the <code>GameLevel</code> object to be used each time <code>GameLevel::health</code> is called to calculate <code>ebg2</code>'s health. That's what the <code>tr1::bind</code> call does: it specifies that <code>ebg2</code>'s health calculation function should always use <code>currentLevel</code> as the <code>GameLevel</code> object.</p>
<p class="noindent">I'm skipping over a host of details, such as why “<code>_1</code>” means “use <code>currentLevel</code> as the <code>GameLevel</code> object when calling <code>GameLevel::health</code> for <code>ebg2</code>.” Such details wouldn't be terribly illuminating, and they'd distract from the fundamental point I want to make: by using <code>tr1::function</code> instead of a function pointer, we're allowing clients to use <em>any compatible callable entity</em> when calculating a character's health. Is that cool or what?</p>
<h3 id="ch06lev2sec4">The “Classic” Strategy Pattern</h3>
<p class="noindent"><a id="page_176"></a>If you're more into design patterns than C++ coolness, a more conventional approach to Strategy would be to make the health-calculation function a virtual member function of a separate health-calculation hierarchy. The resulting hierarchy design would look like this:</p>
<p class="mediaobject"><img src="https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/graphics/06inf06.gif" alt="images" width="500" height="171" data-mfp-src="/library/view/effective-c-55/0321334876/graphics/06inf06.gif"></p>
<p class="noindent">If you're not up on your UML notation, this just says that <code>GameCharacter</code> is the root of an inheritance hierarchy where <code>EvilBadGuy</code> and <code>EyeCandyCharacter</code> are derived classes; <code>HealthCalcFunc</code> is the root of an inheritance hierarchy with derived classes <code>SlowHealthLoser</code> and <code>FastHealthLoser</code>; and each object of type <code>GameCharacter</code> contains a pointer to an object from the <code>HealthCalcFunc</code> hierarchy.</p>
<p class="noindent">Here's the corresponding code skeleton:</p>
<p class="codelink"><a id="procode246"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode246">Click here to view code image</a></p>
<p class="programlisting"><br>class GameCharacter;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// forward declaration<br><br>class HealthCalcFunc {<br>public:<br><br>&nbsp;&nbsp;...<br>&nbsp;&nbsp;virtual int calc(const GameCharacter&amp; gc) const<br>&nbsp;&nbsp;{ ... }<br>&nbsp;&nbsp;...<br><br>};<br><br>HealthCalcFunc defaultHealthCalc;<br><br>class GameCharacter {<br>public:<br>&nbsp;&nbsp;explicit GameCharacter(<span class="courierb">HealthCalcFunc *phcf = &amp;defaultHealthCalc</span>)<br>&nbsp;&nbsp;: pHealthCalc(phcf)<br>&nbsp;&nbsp;{}<br><br>&nbsp;&nbsp;int healthValue() const<br>&nbsp;&nbsp;{ return <span class="courierb">pHealthCalc-&gt;calc(*this)</span>;}<br><br>&nbsp;&nbsp;...<br><br>private:<br>&nbsp;&nbsp;<span class="courierb">HealthCalcFunc *pHealthCalc;</span><br>};<br></p>
<p class="noindent"><a id="page_177"></a>This approach has the appeal of being quickly recognizable to people familiar with the “standard” Strategy pattern implementation, plus it offers the possibility that an existing health calculation algorithm can be tweaked by adding a derived class to the <code>HealthCalcFunc</code> hierarchy.</p>
<h3 id="ch06lev2sec5">Summary</h3>
<p class="noindent">The fundamental advice of this Item is to consider alternatives to virtual functions when searching for a design for the problem you're trying to solve. Here's a quick recap the alternatives we examined:</p>
<p class="indenthanding">• Use the <strong>non-virtual interface idiom</strong> (NVI idiom), a form of the Template Method design pattern that wraps public non-virtual member functions around less accessible virtual functions.</p>
<p class="indenthanding">• Replace virtual functions with <strong>function pointer data members</strong>, a stripped-down manifestation of the Strategy design pattern.</p>
<p class="indenthanding">• Replace virtual functions with <strong>tr1::function data members</strong>, thus allowing use of any callable entity with a signature compatible with what you need. This, too, is a form of the Strategy design pattern.</p>
<p class="indenthanding">• Replace virtual functions in one hierarchy with <strong>virtual functions in another hierarchy</strong>. This is the conventional implementation of the Strategy design pattern.</p>
<p class="noindent">This isn't an exhaustive list of design alternatives to virtual functions, but it should be enough to convince you that there <em>are</em> alternatives. Furthermore, their comparative advantages and disadvantages should make clear that you <em>should</em> consider them.</p>
<p class="noindent">To avoid getting stuck in the ruts of the road of object-oriented design, give the wheel a good jerk from time to time. There are lots of other roads. It's worth taking the time to investigate them.</p>
<div class="note">
<h3 id="ch06note04">Things to Remember</h3>
<p class="indenthanding">• Alternatives to virtual functions include the NVI idiom and various forms of the Strategy design pattern. The NVI idiom is itself an example of the Template Method design pattern.</p>
<p class="indenthanding">• A disadvantage of moving functionality from a member function to a function outside the class is that the non-member function lacks access to the class's non-public members.</p>
<p class="indenthanding">• <code>tr1::function</code> objects act like generalized function pointers. Such objects support all callable entities compatible with a given target signature.</p>
</div>
<h3 id="ch06lev1sec5">Item 36: Never redefine an inherited non-virtual function</h3>
<p class="noindent"><a id="page_178"></a>Suppose I tell you that a class <code>D</code> is publicly derived from a class <code>B</code> and that there is a public member function <code>mf</code> defined in class <code>B</code>. The parameters and return type of <code>mf</code> are unimportant, so let's just assume they're both <code>void</code>. In other words, I say this:</p>
<p class="programlisting"><br>class B {<br>public:<br>&nbsp;&nbsp;void mf();<br>&nbsp;&nbsp;...<br>};<br>class D: public B { ... };<br></p>
<p class="noindent">Even without knowing anything about <code>B</code>, <code>D</code>, or <code>mf</code>, given an object <code>x</code> of type <code>D</code>,</p>
<p class="codelink"><a id="procode247"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode247">Click here to view code image</a></p>
<p class="programlisting"><br>D x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// x is an object of type D<br></p>
<p class="noindent">you would probably be quite surprised if this,</p>
<p class="codelink"><a id="procode248"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode248">Click here to view code image</a></p>
<p class="programlisting"><br>B *pB = &amp;x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// get pointer to x<br>pB-&gt;mf();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// call mf through pointer<br></p>
<p class="noindent">behaved differently from this:</p>
<p class="codelink"><a id="procode249"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode249">Click here to view code image</a></p>
<p class="programlisting"><br>D *pD = &amp;x;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// get pointer to x<br>pD-&gt;mf();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// call mf through pointer<br></p>
<p class="noindent">That's because in both cases you're invoking the member function <code>mf</code> on the object <code>x</code>. Because it's the same function and the same object in both cases, it should behave the same way, right?</p>
<p class="noindent">Right, it should. But it might not. In particular, it won't if <code>mf</code> is non-virtual and <code>D</code> has defined its own version of <code>mf</code>:</p>
<p class="codelink"><a id="procode250"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode250">Click here to view code image</a></p>
<p class="programlisting"><br>class D: public B {<br>public:<br>&nbsp;&nbsp;void mf();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// hides B::mf; see Item 33<br><br>&nbsp;&nbsp;...<br><br>};<br><br>pB-&gt;mf();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls B::mf<br><br>pD-&gt;mf();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls D::mf<br></p>
<p class="noindent">The reason for this two-faced behavior is that <em>non-virtual</em> functions like <code>B::mf</code> and <code>D::mf</code> are statically bound (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec6">Item 37</a>). That means that because <code>pB</code> is declared to be of type pointer-to-<code>B</code>, non-virtual functions invoked through <code>pB</code> will <em>always</em> be those defined for class <code>B</code>, even <a id="page_179"></a>if <code>pB</code> points to an object of a class derived from <code>B</code>, as it does in this example.</p>
<p class="noindent"><em>Virtual</em> functions, on the other hand, are dynamically bound (again, see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec6">Item 37</a>), so they don't suffer from this problem. If <code>mf</code> were a virtual function, a call to <code>mf</code> through either <code>pB</code> or <code>pD</code> would result in an invocation of <code>D::mf</code>, because what <code>pB</code> and <code>pD</code> <em>really</em> point to is an object of type <code>D</code>.</p>
<p class="noindent">If you are writing class <code>D</code> and you redefine a non-virtual function <code>mf</code> that you inherit from class <code>B</code>, <code>D</code> objects will likely exhibit inconsistent behavior. In particular, any given <code>D</code> object may act like either a <code>B</code> or a <code>D</code> when <code>mf</code> is called, and the determining factor will have nothing to do with the object itself, but with the declared type of the pointer that points to it. References exhibit the same baffling behavior as do pointers.</p>
<p class="noindent">But that's just a pragmatic argument. What you really want, I know, is some kind of theoretical justification for not redefining inherited non-virtual functions. I am pleased to oblige.</p>
<p class="noindent"><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec1">Item 32</a> explains that public inheritance means is-a, and <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec3">Item 34</a> describes why declaring a non-virtual function in a class establishes an invariant over specialization for that class. If you apply these observations to the classes <code>B</code> and <code>D</code> and to the non-virtual member function <code>B::mf</code>, then</p>
<p class="indenthanding">• Everything that applies to <code>B</code> objects also applies to <code>D</code> objects, because every <code>D</code> object is-a <code>B</code> object;</p>
<p class="indenthanding">• Classes derived from <code>B</code> must inherit both the interface <em>and</em> the implementation of <code>mf</code>, because <code>mf</code> is non-virtual in <code>B</code>.</p>
<p class="noindent">Now, if <code>D</code> redefines <code>mf</code>, there is a contradiction in your design. If <code>D</code> <em>really</em> needs to implement <code>mf</code> differently from <code>B</code>, and if every <code>B</code> object — no matter how specialized — <em>really</em> has to use the <code>B</code> implementation for <code>mf</code>, then it's simply not true that every <code>D</code> is-a <code>B</code>. In that case, <code>D</code> shouldn't publicly inherit from <code>B</code>. On the other hand, if <code>D</code> <em>really</em> has to publicly inherit from <code>B</code>, and if <code>D</code> <em>really</em> needs to implement <code>mf</code> differently from <code>B</code>, then it's just not true that <code>mf</code> reflects an invariant over specialization for <code>B</code>. In that case, <code>mf</code> should be virtual. Finally, if every <code>D</code> <em>really</em> is-a <code>B</code>, and if <code>mf</code> really corresponds to an invariant over specialization for <code>B</code>, then <code>D</code> can't honestly need to redefine <code>mf</code>, and it shouldn't try to.</p>
<p class="noindent">Regardless of which argument applies, something has to give, and under no conditions is it the prohibition on redefining an inherited non-virtual function.</p>
<p class="noindent"><a id="page_180"></a>If reading this Item gives you a sense of <em>déjà vu</em>, it's probably because you've already read <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch02.html#ch02lev1sec3">Item 7</a>, which explains why destructors in polymorphic base classes should be virtual. If you violate that guideline (i.e., if you declare a non-virtual destructor in a polymorphic base class), you'll also be violating this guideline, because derived classes would invariably redefine an inherited non-virtual function: the base class's destructor. This would be true even for derived classes that declare no destructor, because, as <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch02.html#ch02lev1sec1">Item 5</a> explains, the destructor is one of the member functions that compilers generate for you if you don't declare one yourself. In essence, <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch02.html#ch02lev1sec3">Item 7</a> is nothing more than a special case of this Item, though it's important enough to merit calling out on its own.</p>
<div class="note">
<h3 id="ch06note05">Things to Remember</h3>
<p class="indenthanding">• Never redefine an inherited non-virtual function.</p>
</div>
<h3 id="ch06lev1sec6">Item 37: Never redefine a function's inherited default parameter value</h3>
<p class="noindent">Let's simplify this discussion right from the start. There are only two kinds of functions you can inherit: virtual and non-virtual. However, it's always a mistake to redefine an inherited non-virtual function (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec5">Item 36</a>), so we can safely limit our discussion here to the situation in which you inherit a <em>virtual</em> function with a default parameter value.</p>
<p class="noindent">That being the case, the justification for this Item becomes quite straightforward: virtual functions are dynamically bound, but default parameter values are statically bound.</p>
<p class="noindent">What's that? You say the difference between static and dynamic binding has slipped your already overburdened mind? (For the record, static binding is also known as <em>early binding</em>, and dynamic binding is also known as <em>late binding</em>.) Let's review, then.</p>
<p class="noindent">An object's <em>static type</em> is the type you declare it to have in the program text. Consider this class hierarchy:</p>
<p class="codelink"><a id="procode251"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode251">Click here to view code image</a></p>
<p class="programlisting"><br>// a class for geometric shapes<br>class Shape {<br>public:<br>&nbsp;&nbsp;enum ShapeColor { Red, Green, Blue };<br><br>&nbsp;&nbsp;// all shapes must offer a function to draw themselves<br>&nbsp;&nbsp;virtual void draw(ShapeColor color = Red) const = 0;<br>&nbsp;&nbsp;...<br>};<br><br><a id="page_181"></a>class Rectangle: public Shape {<br>public:<br>&nbsp;&nbsp;// notice the different default parameter value — bad!<br>&nbsp;&nbsp;virtual void draw(ShapeColor color = Green) const;<br>&nbsp;&nbsp;...<br>};<br><br>class Circle: public Shape {<br>public:<br>&nbsp;&nbsp;virtual void draw(ShapeColor color) const;<br>&nbsp;&nbsp;...<br>};<br></p>
<p class="noindent">Graphically, it looks like this:</p>
<p class="mediaobject"><img src="https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/graphics/06inf07.gif" alt="images" width="250" height="114" data-mfp-src="/library/view/effective-c-55/0321334876/graphics/06inf07.gif"></p>
<p class="noindent">Now consider these pointers:</p>
<p class="codelink"><a id="procode252"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode252">Click here to view code image</a></p>
<p class="programlisting"><br>Shape *ps;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// static type = Shape*<br>Shape *pc = new Circle;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// static type = Shape*<br>Shape *pr = new Rectangle;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// static type = Shape*<br></p>
<p class="noindent">In this example, <code>ps</code>, <code>pc</code>, and <code>pr</code> are all declared to be of type pointer-to-<code>Shape</code>, so they all have that as their static type. Notice that it makes absolutely no difference what they're <em>really</em> pointing to — their static type is <code>Shape*</code> regardless.</p>
<p class="noindent">An object's <em>dynamic type</em> is determined by the type of the object to which it currently refers. That is, its dynamic type indicates how it will behave. In the example above, <code>pc</code>'s dynamic type is <code>Circle*</code>, and <code>pr</code>'s dynamic type is <code>Rectangle*</code>. As for <code>ps</code>, it doesn't really have a dynamic type, because it doesn't refer to any object (yet).</p>
<p class="noindent">Dynamic types, as their name suggests, can change as a program runs, typically through assignments:</p>
<p class="codelink"><a id="procode253"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode253">Click here to view code image</a></p>
<p class="programlisting"><br>ps = pc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ps's dynamic type is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// now Circle*<br><br>ps = pr;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ps's dynamic type is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// now Rectangle*<br></p>
<p class="noindent">Virtual functions are <em>dynamically bound</em>, meaning that the particular function called is determined by the dynamic type of the object through which it's invoked:</p>
<p class="codelink"><a id="procode254"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode254">Click here to view code image</a></p>
<p class="programlisting"><br><br><a id="page_182"></a>pc-&gt;draw(Shape::Red);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls Circle::draw(Shape::Red)<br><br>pr-&gt;draw(Shape::Red);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls Rectangle::draw(Shape::Red)<br></p>
<p class="noindent">This is all old hat, I know; you surely understand virtual functions. The twist comes in when you consider virtual functions with default parameter values, because, as I said above, virtual functions are dynamically bound, but default parameters are statically bound. That means you may end up invoking a virtual function defined in a <em>derived class</em> but using a default parameter value from a <em>base class</em>:</p>
<p class="codelink"><a id="procode255"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode255">Click here to view code image</a></p>
<p class="programlisting"><br>pr-&gt;draw();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls Rectangle::draw(Shape::Red)!<br></p>
<p class="noindent">In this case, <code>pr</code>'s dynamic type is <code>Rectangle*</code>, so the <code>Rectangle</code> virtual function is called, just as you would expect. In <code>Rectangle::draw</code>, the default parameter value is <code>Green</code>. Because <code>pr</code>'s static type is <code>Shape*</code>, however, the default parameter value for this function call is taken from the <code>Shape</code> class, not the <code>Rectangle</code> class! The result is a call consisting of a strange and almost certainly unanticipated combination of the declarations for <code>draw</code> in both the <code>Shape</code> and <code>Rectangle</code> classes.</p>
<p class="noindent">The fact that <code>ps</code>, <code>pc</code>, and <code>pr</code> are pointers is of no consequence in this matter. Were they references, the problem would persist. The only important things are that <code>draw</code> is a virtual function, and one of its default parameter values is redefined in a derived class.</p>
<p class="noindent">Why does C++ insist on acting in this perverse manner? The answer has to do with runtime efficiency. If default parameter values were dynamically bound, compilers would have to come up with a way to determine the appropriate default value(s) for parameters of virtual functions at runtime, which would be slower and more complicated than the current mechanism of determining them during compilation. The decision was made to err on the side of speed and simplicity of implementation, and the result is that you now enjoy execution behavior that is efficient, but, if you fail to heed the advice of this Item, confusing.</p>
<p class="noindent">That's all well and good, but look what happens if you try to follow this rule and also offer default parameter values to users of both base and derived classes:</p>
<p class="programlisting"><br>class Shape {<br>public:<br>&nbsp;&nbsp;enum ShapeColor { Red, Green, Blue };<br><br>&nbsp;&nbsp;virtual void draw(ShapeColor color <span class="courierb">= Red</span>) const = 0;<br>&nbsp;&nbsp;...<br>};<br><br><a id="page_183"></a>class Rectangle: public Shape {<br>public:<br>&nbsp;&nbsp;virtual void draw(ShapeColor color <span class="courierb">= Red</span>) const;<br>&nbsp;&nbsp;...<br>};<br></p>
<p class="noindent">Uh oh, code duplication. Worse yet, code duplication with dependencies: if the default parameter value is changed in <code>Shape</code>, all derived classes that repeat it must also be changed. Otherwise they'll end up redefining an inherited default parameter value. What to do?</p>
<p class="noindent">When you're having trouble making a virtual function behave the way you'd like, it's wise to consider alternative designs, and <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec4">Item 35</a> is filled with alternatives to virtual functions. One of the alternatives is the <em>non-virtual interface idiom</em> (NVI idiom): having a public non-virtual function in a base class call a private virtual function that derived classes may redefine. Here, we have the non-virtual function specify the default parameter, while the virtual function does the actual work:</p>
<p class="codelink"><a id="procode256"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode256">Click here to view code image</a></p>
<p class="programlisting"><br>class Shape {<br>public:<br>&nbsp;&nbsp;enum ShapeColor { Red, Green, Blue };<br><br>&nbsp;&nbsp;void draw(ShapeColor color = Red) const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// now non-virtual<br>&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;doDraw(color);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls a virtual<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;...<br><br>private:<br>&nbsp;&nbsp;<span class="courierb">virtual void doDraw(ShapeColor color) const = 0;</span>&nbsp;&nbsp;// the actual work is<br>};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// done in this func<br><br>class Rectangle: public Shape {<br>public:<br><br>&nbsp;&nbsp;...<br><br>private:<br>&nbsp;&nbsp;virtual void <span class="courierb">doDraw</span>(ShapeColor color) const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// note lack of a<br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// default param val.<br>};<br></p>
<p class="noindent">Because non-virtual functions should never be overridden by derived classes (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec5">Item 36</a>), this design makes clear that the default value for <code>draw</code>'s <code>color</code> parameter should always be <code>Red</code>.</p>
<div class="note">
<h3 id="ch06note06">Things to Remember</h3>
<p class="indenthanding">• Never redefine an inherited default parameter value, because default parameter values are statically bound, while virtual functions — the only functions you should be overriding — are dynamically bound.</p>
</div>
<h3 id="ch06lev1sec7">Item 38: Model “has-a” or “is-implemented-in-terms-of” through composition</h3>
<p class="noindent"><a id="page_184"></a><em>Composition</em> is the relationship between types that arises when objects of one type contain objects of another type. For example:</p>
<p class="codelink"><a id="procode257"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode257">Click here to view code image</a></p>
<p class="programlisting"><br>class Address { ... };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// where someone lives<br><br>class PhoneNumber { ... };<br><br>class Person {<br>public:<br>&nbsp;&nbsp;...<br><br>private:<br>&nbsp;&nbsp;<span class="courierb">std::string name;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// composed object<br>&nbsp;&nbsp;<span class="courierb">Address address;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ditto<br>&nbsp;&nbsp;<span class="courierb">PhoneNumber voiceNumber;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ditto<br>&nbsp;&nbsp;<span class="courierb">PhoneNumber faxNumber;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ditto<br>};<br></p>
<p class="noindent">In this example, <code>Person</code> objects are composed of <code>string</code>, <code>Address</code>, and <code>PhoneNumber</code> objects. Among programmers, the term <em>composition</em> has lots of synonyms. It's also known as <em>layering, containment, aggregation</em>, and <em>embedding</em>.</p>
<p class="noindent"><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec1">Item 32</a> explains that public inheritance means “is-a.” Composition has a meaning, too. Actually, it has two meanings. Composition means either “has-a” or “is-implemented-in-terms-of.” That's because you are dealing with two different domains in your software. Some objects in your programs correspond to things in the world you are modeling, e.g., people, vehicles, video frames, etc. Such objects are part of the <em>application domain</em>. Other objects are purely implementation artifacts, e.g., buffers, mutexes, search trees, etc. These kinds of objects correspond to your software's <em>implementation domain</em>. When composition occurs between objects in the application domain, it expresses a has-a relationship. When it occurs in the implementation domain, it expresses an is-implemented-in-terms-of relationship.</p>
<p class="noindent">The <code>Person</code> class above demonstrates the has-a relationship. A <code>Person</code> object has a name, an address, and voice and fax telephone numbers. You wouldn't say that a person <em>is</em> a name or that a person <em>is</em> an address. You would say that a person <em>has</em> a name and <em>has</em> an address. Most people have little difficulty with this distinction, so confusion between the roles of is-a and has-a is relatively rare.</p>
<p class="noindent">Somewhat more troublesome is the difference between is-a and is-implemented-in-terms-of. For example, suppose you need a template for classes representing fairly small sets of objects, i.e., collections without duplicates. Because reuse is a wonderful thing, your first <a id="page_185"></a>instinct is to employ the standard library's <code>set</code> template. Why write a new template when you can use one that's already been written?</p>
<p class="noindent">Unfortunately, <code>set</code> implementations typically incur an overhead of three pointers per element. This is because <code>set</code>s are usually implemented as balanced search trees, something that allows them to guarantee logarithmic-time lookups, insertions, and erasures. When speed is more important than space, this is a reasonable design, but it turns out that for your application, space is more important than speed. The standard library's <code>set</code> thus offers the wrong trade-off for you. It seems you'll need to write your own template after all.</p>
<p class="noindent">Still, reuse <em>is</em> a wonderful thing. Being the data structure maven you are, you know that of the many choices for implementing sets, one is to use linked lists. You also know that the standard C++ library has a <code>list</code> template, so you decide to (re)use it.</p>
<p class="noindent">In particular, you decide to have your nascent <code>Set</code> template inherit from <code>list</code>. That is, <code>Set&lt;T&gt;</code> will inherit from <code>list&lt;T&gt;</code>. After all, in your implementation, a <code>Set</code> object will in fact <em>be</em> a <code>list</code> object. You thus declare your <code>Set</code> template like this:</p>
<p class="codelink"><a id="procode258"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode258">Click here to view code image</a></p>
<p class="programlisting"><br>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the <span class="courieri">wrong</span> way to use list for Set<br>class Set: public std::list&lt;T&gt; { ... };<br></p>
<p class="noindent">Everything may seem fine at this point, but in fact there is something quite wrong. As <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec1">Item 32</a> explains, if <code>D</code> is-a <code>B</code>, everything true of <code>B</code> is also true of <code>D</code>. However, a <code>list</code> object may contain duplicates, so if the value 3051 is inserted into a <code>list&lt;int&gt;</code> twice, that list will contain two copies of 3051. In contrast, a <code>Set</code> may not contain duplicates, so if the value 3051 is inserted into a <code>Set&lt;int&gt;</code> twice, the set contains only one copy of the value. It is thus untrue that a <code>Set</code> is-a <code>list</code>, because some of the things that are true for <code>list</code> objects are not true for <code>Set</code> objects.</p>
<p class="noindent">Because the relationship between these two classes isn't is-a, public inheritance is the wrong way to model that relationship. The right way is to realize that a <code>Set</code> object can be <em>implemented in terms of</em> a <code>list</code> object:</p>
<p class="codelink"><a id="procode259"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode259">Click here to view code image</a></p>
<p class="programlisting"><br>template&lt;class T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the right way to use list for Set<br>class Set {<br>public:<br>&nbsp;&nbsp;bool member(const T&amp; item) const;<br><br>&nbsp;&nbsp;void insert(const T&amp; item);<br>&nbsp;&nbsp;void remove(const T&amp; item);<br><br>&nbsp;&nbsp;std::size_t size() const;<br><br>private:<br>&nbsp;&nbsp;<span class="courierb">std::list&lt;T&gt; rep;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// representation for Set data<br>};<br></p>
<p class="noindent"><a id="page_186"></a><code>Set</code>'s member functions can lean heavily on functionality already offered by <code>list</code> and other parts of the standard library, so the implementation is straightforward, as long as you're familiar with the basics of programming with the STL:</p>
<p class="codelink"><a id="procode260"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode260">Click here to view code image</a></p>
<p class="programlisting"><br>template&lt;typename T&gt;<br>bool Set&lt;T&gt;::member(const T&amp; item) const<br>{<br>&nbsp;&nbsp;return std::find(rep.begin(), rep.end(), item) != rep.end();<br>}<br>template&lt;typename T&gt;<br>void Set&lt;T&gt;::insert(const T&amp; item)<br>{<br>&nbsp;&nbsp;if (!member(item)) rep.push_back(item);<br>}<br>template&lt;typename T&gt;<br>void Set&lt;T&gt;::remove(const T&amp; item)<br>{<br>&nbsp;&nbsp;typename std::list&lt;T&gt;::iterator it =&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// see Item 42 for info on<br>&nbsp;&nbsp;&nbsp;&nbsp;std::find(rep.begin(), rep.end(), item);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "typename" here<br>&nbsp;&nbsp;if (it != rep.end()) rep.erase(it);<br>}<br>template&lt;typename T&gt;<br>std::size_t Set&lt;T&gt;::size() const<br>{<br>&nbsp;&nbsp;return rep.size();<br>}<br></p>
<p class="noindent">These functions are simple enough that they make reasonable candidates for inlining, though I know you'd want to review the discussion in <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch05.html#ch05lev1sec5">Item 30</a> before making any firm inlining decisions.</p>
<p class="noindent">One can argue that <code>Set</code>'s interface would be more in accord with <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch04.html#ch04lev1sec1">Item 18</a>'s admonition to design interfaces that are easy to use correctly and hard to use incorrectly if it followed the STL container conventions, but following those conventions here would require adding a lot of stuff to <code>Set</code> that would obscure the relationship between it and <code>list</code>. Since that relationship is the point of this Item, we'll trade STL compatibility for pedagogical clarity. Besides, nits about <code>Set</code>'s interface shouldn't overshadow what's indisputably right about <code>Set</code>: the relationship between it and <code>list</code>. That relationship is not is-a (though it initially looked like it might be), it's is-implemented-in-terms-of.</p>
<div class="note">
<h3 id="ch06note07">Things to Remember</h3>
<p class="indenthanding">• Composition has meanings completely different from that of public inheritance.</p>
<p class="indenthanding">• In the application domain, composition means has-a. In the implementation domain, it means is-implemented-in-terms-of.</p>
</div>
<h3 id="ch06lev1sec8">Item 39: Use private inheritance judiciously</h3>
<p class="noindent"><a id="page_187"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch04.html#ch04lev1sec1">Item 32</a> demonstrates that C++ treats public inheritance as an is-a relationship. It does this by showing that compilers, when given a hierarchy in which a class <code>Student</code> publicly inherits from a class <code>Person</code>, implicitly convert <code>Student</code>s to <code>Person</code>s when that is necessary for a function call to succeed. It's worth repeating a portion of that example using private inheritance instead of public inheritance:</p>
<p class="codelink"><a id="procode261"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode261">Click here to view code image</a></p>
<p class="programlisting"><br>class Person { ... };<br>class Student: <span class="courierb">private</span> Person { ... };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// inheritance is now private<br><br>void eat(const Person&amp; p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// anyone can eat<br><br>void study(const Student&amp; s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// only students study<br><br>Person p;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// p is a Person<br>Student s;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// s is a Student<br><br>eat(p);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fine, p is a Person<br><br>eat(s);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error! a Student isn't a Person<br></p>
<p class="noindent">Clearly, private inheritance doesn't mean is-a. What does it mean then?</p>
<p class="noindent">“Whoa!” you say. “Before we get to the meaning, let's cover the behavior. How does private inheritance behave?” Well, the first rule governing private inheritance you've just seen in action: in contrast to public inheritance, compilers will generally <em>not</em> convert a derived class object (such as <code>Student</code>) into a base class object (such as <code>Person</code>) if the inheritance relationship between the classes is private. That's why the call to <code>eat</code> fails for the object <code>s</code>. The second rule is that members inherited from a private base class become private members of the derived class, even if they were protected or public in the base class.</p>
<p class="noindent">So much for behavior. That brings us to meaning. Private inheritance means is-implemented-in-terms-of. If you make a class <code>D</code> privately inherit from a class <code>B</code>, you do so because you are interested in taking advantage of some of the features available in class <code>B</code>, not because there is any conceptual relationship between objects of types <code>B</code> and <code>D</code>. As such, private inheritance is purely an implementation technique. (That's why everything you inherit from a private base class becomes private in your class: it's all just implementation detail.) Using the terms introduced in <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec3">Item 34</a>, private inheritance means that implementation <em>only</em> should be inherited; interface should be ignored. If <code>D</code> privately inherits from <code>B</code>, it means that <code>D</code> objects are implemented in terms of <code>B</code> objects, nothing more. Private inheritance means nothing during software <em>design</em>, only during software <em>implementation</em>.</p>
<p class="noindent"><a id="page_188"></a>The fact that private inheritance means is-implemented-in-terms-of is a little disturbing, because <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec7">Item 38</a> points out that composition can mean the same thing. How are you supposed to choose between them? The answer is simple: use composition whenever you can, and use private inheritance whenever you must. When must you? Primarily when protected members and/or virtual functions enter the picture, though there's also an edge case where space concerns can tip the scales toward private inheritance. We'll worry about the edge case later. After all, it's an edge case.</p>
<p class="noindent">Suppose we're working on an application involving <code>Widget</code>s, and we decide we need to better understand how <code>Widget</code>s are being used. For example, not only do we want to know things like how often <code>Widget</code> member functions are called, we also want to know how the call ratios change over time. Programs with distinct phases of execution can have different behavioral profiles during the different phases. For example, the functions used during the parsing phase of a compiler are largely different from the functions used during optimization and code generation.</p>
<p class="noindent">We decide to modify the <code>Widget</code> class to keep track of how many times each member function is called. At runtime, we'll periodically examine that information, possibly along with the values of each <code>Widget</code> and whatever other data we deem useful. To make this work, we'll need to set up a timer of some kind so that we'll know when it's time to collect the usage statistics.</p>
<p class="noindent">Preferring to reuse existing code over writing new code, we rummage around in our utility toolkit and are pleased to find the following class:</p>
<p class="codelink"><a id="procode262"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode262">Click here to view code image</a></p>
<p class="programlisting"><br>class Timer {<br>public:<br>&nbsp;&nbsp;explicit Timer(int tickFrequency);<br>&nbsp;&nbsp;&nbsp;virtual void onTick() const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// automatically called for each tick<br>&nbsp;&nbsp;...<br>};<br></p>
<p class="noindent">This is just what we're looking for. A <code>Timer</code> object can be configured to tick with whatever frequency we need, and on each tick, it calls a virtual function. We can redefine that virtual function so that it examines the current state of the <code>Widget</code> world. Perfect!</p>
<p class="noindent">In order for <code>Widget</code> to redefine a virtual function in <code>Timer</code>, <code>Widget</code> must inherit from <code>Timer</code>. But public inheritance is inappropriate in this case. It's not true that a <code>Widget</code> is-a <code>Timer</code>. <code>Widget</code> clients shouldn't be able to call <code>onTick</code> on a <code>Widget</code>, because that's not part of the conceptual <a id="page_189"></a><code>Widget</code> interface. Allowing such a function call would make it easy for clients to use the <code>Widget</code> interface incorrectly, a clear violation of <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch04.html#ch04lev1sec1">Item 18</a>'s advice to make interfaces easy to use correctly and hard to use incorrectly. Public inheritance is not a valid option here.</p>
<p class="noindent">We thus inherit privately:</p>
<p class="codelink"><a id="procode263"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode263">Click here to view code image</a></p>
<p class="programlisting"><br>class Widget: <span class="courierb">private</span> Timer {<br>private:<br>&nbsp;&nbsp;virtual void onTick() const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// look at Widget usage data, etc.<br>&nbsp;&nbsp;...<br>};<br></p>
<p class="noindent">By virtue of private inheritance, <code>Timer</code>'s public <code>onTick</code> function becomes private in <code>Widget</code>, and we keep it there when we redeclare it. Again, putting <code>onTick</code> in the public interface would mislead clients into thinking they could call it, and that would violate <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch04.html#ch04lev1sec1">Item 18</a>.</p>
<p class="noindent">This is a nice design, but it's worth noting that private inheritance isn't strictly necessary. If we were determined to use composition instead, we could. We'd just declare a private nested class inside <code>Widget</code> that would publicly inherit from <code>Timer</code>, redefine <code>onTick</code> there, and put an object of that type inside <code>Widget</code>. Here's a sketch of the approach:</p>
<p class="programlisting"><br>class Widget {<br>private:<br>&nbsp;&nbsp;<span class="courierb">class WidgetTimer: public Timer {</span><br>&nbsp;&nbsp;public:<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="courierb">virtual void onTick() const;</span><br>&nbsp;&nbsp;&nbsp;&nbsp;...<br>&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;<span class="courierb">WidgetTimer timer;</span><br>&nbsp;&nbsp;...<br>};<br><img src="https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/graphics/06inf08.gif" alt="images" width="300" height="125" data-mfp-src="/library/view/effective-c-55/0321334876/graphics/06inf08.gif"></p>
<p class="noindent">This design is more complicated than the one using only private inheritance, because it involves both (public) inheritance and composition, as well as the introduction of a new class (<code>WidgetTimer</code>). To be honest, I show it primarily to remind you that there is more than one way to approach a design problem, and it's worth training yourself to consider multiple approaches (see also <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec4">Item 35</a>). Nevertheless, I can think of two reasons why you might prefer public inheritance plus composition over private inheritance.</p>
<p class="noindent">First, you might want to design <code>Widget</code> to allow for derived classes, but you might also want to prevent derived classes from redefining <code>onTick</code>. If <code>Widget</code> inherits from <code>Timer</code>, that's not possible, not even if the inheritance <a id="page_190"></a>is private. (Recall from <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec4">Item 35</a> that derived classes may redefine virtual functions even if they are not permitted to call them.) But if <code>WidgetTimer</code> is private in <code>Widget</code> and inherits from <code>Timer</code>, <code>Widget</code>'s derived classes have no access to <code>WidgetTimer</code>, hence can't inherit from it or redefine its virtual functions. If you've programmed in Java or C# and miss the ability to prevent derived classes from redefining virtual functions (i.e., Java's <code>final</code> methods and C#'s <code>sealed</code> ones), now you have an idea how to approximate that behavior in C++.</p>
<p class="noindent">Second, you might want to minimize <code>Widget</code>'s compilation dependencies. If <code>Widget</code> inherits from <code>Timer</code>, <code>Timer</code>'s definition must be available when <code>Widget</code> is compiled, so the file defining <code>Widget</code> probably has to <code>#include Timer.h</code>. On the other hand, if <code>WidgetTimer</code> is moved out of <code>Widget</code> and <code>Widget</code> contains only a pointer to a <code>WidgetTimer</code>, <code>Widget</code> can get by with a simple declaration for the <code>WidgetTimer</code> class; it need not <code>#include</code> anything to do with <code>Timer</code>. For large systems, such decouplings can be important. (For details on minimizing compilation dependencies, consult <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch05.html#ch05lev1sec6">Item 31</a>.)</p>
<p class="noindent">I remarked earlier that private inheritance is useful primarily when a would-be derived class wants access to the protected parts of a would-be base class or would like to redefine one or more of its virtual functions, but the conceptual relationship between the classes is is-implemented-in-terms-of instead of is-a. However, I also said that there was an edge case involving space optimization that could nudge you to prefer private inheritance over composition.</p>
<p class="noindent">The edge case is edgy indeed: it applies only when you're dealing with a class that has no data in it. Such classes have no non-static data members; no virtual functions (because the existence of such functions adds a <code>vptr</code> to each object — see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch02.html#ch02lev1sec3">Item 7</a>); and no virtual base classes (because such base classes also incur a size overhead — see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec9">Item 40</a>). Conceptually, objects of such <em>empty classes</em> should use no space, because there is no per-object data to be stored. However, there are technical reasons for C++ decreeing that freestanding objects must have non-zero size, so if you do this,</p>
<p class="codelink"><a id="procode264"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode264">Click here to view code image</a></p>
<p class="programlisting"><br>class Empty {};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// has no data, so objects should<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// use no memory<br>class HoldsAnInt {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// should need only space for an int<br>private:<br>&nbsp;&nbsp;int x;<br>&nbsp;&nbsp;Empty e;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// should require no memory<br>};<br></p>
<p class="noindent">you'll find that <code>sizeof(HoldsAnInt) &gt; sizeof(int)</code>; an <code>Empty</code> data member requires memory. With most compilers, <code>sizeof(Empty)</code> is 1, because <a id="page_191"></a>C++'s edict against zero-size freestanding objects is typically satisfied by the silent insertion of a <code>char</code> into “empty” objects. However, alignment requirements (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec2">Item 50</a>) may cause compilers to add padding to classes like <code>HoldsAnInt</code>, so it's likely that <code>HoldsAnInt</code> objects wouldn't gain just the size of a <code>char</code>, they would actually enlarge enough to hold a second <code>int</code>. (On all the compilers I tested, that's exactly what happened.)</p>
<p class="noindent">But perhaps you've noticed that I've been careful to say that “freestanding” objects mustn't have zero size. This constraint doesn't apply to base class parts of derived class objects, because they're not freestanding. If you <em>inherit</em> from <code>Empty</code> instead of containing an object of that type,</p>
<p class="programlisting"><br>class HoldsAnInt<span class="courierb">: private Empty</span> {<br>private:<br>&nbsp;&nbsp;int x;<br>};<br></p>
<p class="noindent">you're almost sure to find that <code>sizeof(HoldsAnInt) == sizeof(int)</code>. This is known as the <em>empty base optimization</em> (EBO), and it's implemented by all the compilers I tested. If you're a library developer whose clients care about space, the EBO is worth knowing about. Also worth knowing is that the EBO is generally viable only under single inheritance. The rules governing C++ object layout generally mean that the EBO can't be applied to derived classes that have more than one base.</p>
<p class="noindent">In practice, “empty” classes aren't truly empty. Though they never have non-static data members, they often contain typedefs, enums, static data members, or non-virtual functions. The STL has many technically empty classes that contain useful members (usually typedefs), including the base classes <code>unary_function</code> and <code>binary_function</code>, from which classes for user-defined function objects typically inherit. Thanks to widespread implementation of the EBO, such inheritance rarely increases the size of the inheriting classes.</p>
<p class="noindent">Still, let's get back to basics. Most classes aren't empty, so the EBO is rarely a legitimate justification for private inheritance. Furthermore, most inheritance corresponds to is-a, and that's a job for public inheritance, not private. Both composition and private inheritance mean is-implemented-in-terms-of, but composition is easier to understand, so you should use it whenever you can.</p>
<p class="noindent">Private inheritance is most likely to be a legitimate design strategy when you're dealing with two classes not related by is-a where one either needs access to the protected members of another or needs to redefine one or more of its virtual functions. Even in that case, we've <a id="page_192"></a>seen that a mixture of public inheritance and containment can often yield the behavior you want, albeit with greater design complexity. Using private inheritance <em>judiciously</em> means employing it when, having considered all the alternatives, it's the best way to express the relationship between two classes in your software.</p>
<div class="note">
<h3 id="ch06note08">Things to Remember</h3>
<p class="indenthanding">• Private inheritance means is-implemented-in-terms of. It's usually inferior to composition, but it makes sense when a derived class needs access to protected base class members or needs to redefine inherited virtual functions.</p>
<p class="indenthanding">• Unlike composition, private inheritance can enable the empty base optimization. This can be important for library developers who strive to minimize object sizes.</p>
</div>
<h3 id="ch06lev1sec9">Item 40: Use multiple inheritance judiciously</h3>
<p class="noindent">When it comes to multiple inheritance (MI), the C++ community largely breaks into two basic camps. One camp believes that if single inheritance (SI) is good, multiple inheritance must be better. The other camp argues that single inheritance is good, but multiple inheritance isn't worth the trouble. In this Item, our primary goal is to understand both perspectives on the MI question.</p>
<p class="noindent">One of the first things to recognize is that when MI enters the designscape, it becomes possible to inherit the same name (e.g., function, typedef, etc.) from more than one base class. That leads to new opportunities for ambiguity. For example:</p>
<p class="codelink"><a id="procode265"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode265">Click here to view code image</a></p>
<p class="programlisting"><br>class BorrowableItem {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// something a library lets you borrow<br>public:<br>&nbsp;&nbsp;void <span class="courierb">checkOut</span>();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// check the item out from the library<br><br>&nbsp;&nbsp;...<br>};<br><br>class ElectronicGadget {<br>private:<br>&nbsp;&nbsp;bool <span class="courierb">checkOut</span>() const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// perform self-test, return whether<br><br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// test succeeds<br>};<br><br>class MP3Player:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// note MI here<br>&nbsp;&nbsp;<span class="courierb">public BorrowableItem</span>,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (some libraries loan MP3 players)<br>&nbsp;&nbsp;<span class="courierb">public ElectronicGadget</span><br>{ ... };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// class definition is unimportant<br>MP3Player mp;<br><br>mp.<span class="courierb">checkOut</span>();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ambiguous! which checkOut?<br></p>
<p class="noindent"><a id="page_193"></a>Note that in this example, the call to <code>checkOut</code> is ambiguous, even though only one of the two functions is accessible. (<code>checkOut</code> is public in <code>BorrowableItem</code> but private in <code>ElectronicGadget</code>.) That's in accord with the C++ rules for resolving calls to overloaded functions: before seeing whether a function is accessible, C++ first identifies the function that's the best match for the call. It checks accessibility only after finding the best-match function. In this case, both <code>checkOut</code>s are equally good matches, so there's no best match. The accessibility of <code>ElectronicGadget::checkOut</code> is therefore never examined.</p>
<p class="noindent">To resolve the ambiguity, you must specify which base class's function to call:</p>
<p class="codelink"><a id="procode266"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode266">Click here to view code image</a></p>
<p class="programlisting"><br>mp.<span class="courierb">BorrowableItem::</span>checkOut();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ah, <span class="courieri">that</span> checkOut...<br></p>
<p class="noindent">You could try to explicitly call <code>ElectronicGadget::checkOut</code>, too, of course, but then the ambiguity error would be replaced with a “you're trying to call a private member function” error.</p>
<p class="noindent">Multiple inheritance just means inheriting from more than one base class, but it is not uncommon for MI to be found in hierarchies that have higher-level base classes, too. That can lead to what is sometimes known as the “deadly MI diamond”</p>
<p class="programlisting"><br>class File { ... };<br>class InputFile: public File { ... };<br>class OutputFile: public File { ... };<br>class IOFile: public InputFile,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public OutputFile<br>{ ... };<br><img src="https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/graphics/06inf09.gif" alt="images" width="200" height="143" data-mfp-src="/library/view/effective-c-55/0321334876/graphics/06inf09.gif"></p>
<p class="noindent">Any time you have an inheritance hierarchy with more than one path between a base class and a derived class (such as between <code>File</code> and <code>IOFile</code> above, which has paths through both <code>InputFile</code> and <code>OutputFile</code>), you must confront the question of whether you want the data members in the base class to be replicated for each of the paths. For example, suppose that the <code>File</code> class has a data member, <code>fileName</code>. How many copies of this field should <code>IOFile</code> have? On the one hand, it inherits a copy from each of its base classes, so that suggests that <code>IOFile</code> should have two <code>fileName</code> data members. On the other hand, simple logic says that an <code>IOFile</code> object has only one file name, so the <code>fileName</code> field it inherits through its two base classes should not be replicated.</p>
<p class="noindent">C++ takes no position on this debate. It happily supports both options, though its default is to perform the replication. If that's not what you want, you must make the class with the data (i.e., <code>File</code>) a <em>virtual <a id="page_194"></a>base class</em>. To do that, you have all classes that immediately inherit from it use <em>virtual inheritance</em>:</p>
<p class="programlisting"><br>class File { ... };<br>class InputFile: <span class="courierb">virtual</span> public File { ... };<br>class OutputFile: <span class="courierb">virtual</span> public File { ... };<br>class IOFile: public InputFile,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public OutputFile<br>{ ... };<br><img src="https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/graphics/06inf10.gif" alt="images" width="200" height="143" data-mfp-src="/library/view/effective-c-55/0321334876/graphics/06inf10.gif"></p>
<p class="noindent">The standard C++ library contains an MI hierarchy just like this one, except the classes are class templates, and the names are <code>basic_ios</code>, <code>basic_istream</code>, <code>basic_ostream</code>, and <code>basic_iostream</code> instead of <code>File</code>, <code>InputFile</code>, <code>OutputFile</code>, and <code>IOFile</code>.</p>
<p class="noindent">From the viewpoint of correct behavior, public inheritance should always be virtual. If that were the only point of view, the rule would be simple: anytime you use public inheritance, use <em>virtual</em> public inheritance. Alas, correctness is not the only perspective. Avoiding the replication of inherited fields requires some behind-the-scenes legerdemain on the part of compilers, and the result is that objects created from classes using virtual inheritance are generally larger than they would be without virtual inheritance. Access to data members in virtual base classes is also slower than to those in non-virtual base classes. The details vary from compiler to compiler, but the basic thrust is clear: virtual inheritance costs.</p>
<p class="noindent">It costs in other ways, too. The rules governing the initialization of virtual base classes are more complicated and less intuitive than are those for non-virtual bases. The responsibility for initializing a virtual base is borne by the <em>most derived class</em> in the hierarchy. Implications of this rule include (1) classes derived from virtual bases that require initialization must be aware of their virtual bases, no matter how far distant the bases are, and (2) when a new derived class is added to the hierarchy, it must assume initialization responsibilities for its virtual bases (both direct and indirect).</p>
<p class="noindent">My advice on virtual base classes (i.e., on virtual inheritance) is simple. First, don't use virtual bases unless you need to. By default, use non-virtual inheritance. Second, if you must use virtual base classes, try to avoid putting data in them. That way you won't have to worry about oddities in the initialization (and, as it turns out, assignment) rules for such classes. It's worth noting that Interfaces in Java and .NET, which are in many ways comparable to virtual base classes in C++, are not allowed to contain any data.</p>
<p class="noindent">Let us now turn to the following C++ Interface class (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch05.html#ch05lev1sec6">Item 31</a>) for modeling persons:</p>
<p class="programlisting"><br><br><a id="page_195"></a>class IPerson {<br>public:<br>&nbsp;&nbsp;virtual ~IPerson();<br><br>&nbsp;&nbsp;virtual std::string name() const = 0;<br>&nbsp;&nbsp;virtual std::string birthDate() const = 0;<br>};<br></p>
<p class="noindent"><code>IPerson</code> clients must program in terms of <code>IPerson</code> pointers and references, because abstract classes cannot be instantiated. To create objects that can be manipulated as <code>IPerson</code> objects, clients of <code>IPerson</code> use factory functions (again, see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch05.html#ch05lev1sec6">Item 31</a>) to instantiate concrete classes derived from <code>IPerson</code>:</p>
<p class="codelink"><a id="procode267"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode267">Click here to view code image</a></p>
<p class="programlisting"><br>// factory function to create a Person object from a unique database ID;<br>// see Item 18 for why the return type isn't a raw pointer<br>std::tr1::shared_ptr&lt;IPerson&gt; makePerson(DatabaseID personIdentifier);<br><br>// function to get a database ID from the user<br>DatabaseID askUserForDatabaseID();<br><br><br>DatabaseID id(askUserForDatabaseID());<br>std::tr1::shared_ptr&lt;IPerson&gt; pp(makePerson(id));&nbsp;&nbsp;&nbsp;&nbsp;// create an object<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// supporting the<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// IPerson interface<br><br>...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// manipulate *pp via<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// IPerson's member<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// functions<br></p>
<p class="noindent">But how does <code>makePerson</code> create the objects to which it returns pointers? Clearly, there must be some concrete class derived from <code>IPerson</code> that <code>makePerson</code> can instantiate.</p>
<p class="noindent">Suppose this class is called <code>CPerson</code>. As a concrete class, <code>CPerson</code> must provide implementations for the pure virtual functions it inherits from <code>IPerson</code>. It could write these from scratch, but it would be better to take advantage of existing components that do most or all of what's necessary. For example, suppose an old database-specific class <code>PersonInfo</code> offers the essence of what <code>CPerson</code> needs:</p>
<p class="codelink"><a id="procode268"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode268">Click here to view code image</a></p>
<p class="programlisting"><br>class PersonInfo {<br>public:<br>&nbsp;&nbsp;explicit PersonInfo(DatabaseID pid);<br>&nbsp;&nbsp;virtual ~PersonInfo();<br><br>&nbsp;&nbsp;virtual const char * theName() const;<br>&nbsp;&nbsp;virtual const char * theBirthDate() const;<br>&nbsp;&nbsp;...<br><br>private:<br>&nbsp;&nbsp;virtual const char * valueDelimOpen() const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// see<br>&nbsp;&nbsp;virtual const char * valueDelimClose() const;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// below<br>&nbsp;&nbsp;...<br>};<br></p>
<p class="noindent"><a id="page_196"></a>You can tell this is an old class, because the member functions return <code>const char*</code>s instead of <code>string</code> objects. Still, if the shoe fits, why not wear it? The names of this class's member functions suggest that the result is likely to be pretty comfortable.</p>
<p class="noindent">You come to discover that <code>PersonInfo</code> was designed to facilitate printing database fields in various formats, with the beginning and end of each field value delimited by special strings. By default, the opening and closing delimiters for field values are square brackets, so the field value “Ring-tailed Lemur” would be formatted this way:</p>
<p class="programlisting"><br>[Ring-tailed Lemur]<br></p>
<p class="noindent">In recognition of the fact that square brackets are not universally desired by clients of <code>PersonInfo</code>, the virtual functions <code>valueDelimOpen</code> and <code>valueDelimClose</code> allow derived classes to specify their own opening and closing delimiter strings. The implementations of <code>PersonInfo</code>'s member functions call these virtual functions to add the appropriate delimiters to the values they return. Using <code>PersonInfo::theName</code> as an example, the code looks like this:</p>
<p class="codelink"><a id="procode269"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode269">Click here to view code image</a></p>
<p class="programlisting"><br>const char * PersonInfo::valueDelimOpen() const<br>{<br>&nbsp;&nbsp;return "[";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// default opening delimiter<br>}<br><br>const char * PersonInfo::valueDelimClose() const<br>{<br>&nbsp;&nbsp;return "]";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// default closing delimiter<br>}<br><br>const char * PersonInfo::theName() const<br>{<br>&nbsp;&nbsp;// reserve buffer for return value; because this is<br>&nbsp;&nbsp;// static, it's automatically initialized to all zeros<br>&nbsp;&nbsp;static char value[Max_Formatted_Field_Value_Length];<br><br>&nbsp;&nbsp;// write opening delimiter<br>&nbsp;&nbsp;std::strcpy(value, valueDelimOpen());<br><br>&nbsp;&nbsp;<span class="courieri">append to the string in value this object's&nbsp;&nbsp;&nbsp;name field (being careful</span><br>&nbsp;&nbsp;<span class="courieri">to avoid buffer overruns!)</span><br><br>&nbsp;&nbsp;// write closing delimiter<br>&nbsp;&nbsp;std::strcat(value, valueDelimClose());<br><br>&nbsp;&nbsp;return value;<br>}<br></p>
<p class="noindent">One might question the antiquated design of <code>PersonInfo::theName</code> (especially the use of a fixed-size static buffer, something that's rife for both overrun and threading problems — see also <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch04.html#ch04lev1sec4">Item 21</a>), but set such questions aside and focus instead on this: <code>theName</code> calls <code>valueDelimOpen</code> to generate the opening delimiter of the string it will return, then it generates the name value itself, then it calls <code>valueDelimClose</code>.</p>
<p class="noindent"><a id="page_197"></a>Because <code>valueDelimOpen</code> and <code>valueDelimClose</code> are virtual functions, the result returned by <code>theName</code> is dependent not only on <code>PersonInfo</code> but also on the classes derived from <code>PersonInfo</code>.</p>
<p class="noindent">As the implementer of <code>CPerson</code>, that's good news, because while perusing the fine print in the <code>IPerson</code> documentation, you discover that <code>name</code> and <code>birthDate</code> are required to return unadorned values, i.e., no delimiters are allowed. That is, if a person is named Homer, a call to that person's <code>name</code> function should return “Homer”, not “[Homer]”.</p>
<p class="noindent">The relationship between <code>CPerson</code> and <code>PersonInfo</code> is that <code>PersonInfo</code> happens to have some functions that would make <code>CPerson</code> easier to implement. That's all. Their relationship is thus is-implemented-in-terms-of, and we know that can be represented in two ways: via composition (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec7">Item 38</a>) and via private inheritance (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec8">Item 39</a>). <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec8">Item 39</a> points out that composition is the generally preferred approach, but inheritance is necessary if virtual functions are to be redefined. In this case, <code>CPerson</code> needs to redefine <code>valueDelimOpen</code> and <code>valueDelimClose</code>, so simple composition won't do. The most straightforward solution is to have <code>CPerson</code> privately inherit from <code>PersonInfo</code>, though <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec8">Item 39</a> explains that with a bit more work, <code>CPerson</code> could also use a combination of composition and inheritance to effectively redefine <code>PersonInfo</code>'s virtuals. Here, we'll use private inheritance.</p>
<p class="noindent">But <code>CPerson</code> must also implement the <code>IPerson</code> interface, and that calls for public inheritance. This leads to one reasonable application of multiple inheritance: combine public inheritance of an interface with private inheritance of an implementation:</p>
<p class="codelink"><a id="procode270"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode270">Click here to view code image</a></p>
<p class="programlisting"><br>class IPerson {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this class specifies the<br>public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// interface to be implemented<br>&nbsp;&nbsp;virtual ~IPerson();<br><br>&nbsp;&nbsp;virtual std::string name() const = 0;<br>&nbsp;&nbsp;virtual std::string birthDate() const = 0;<br>};<br><br>class DatabaseID { ... };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// used below; details are<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// unimportant<br><br>class PersonInfo {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this class has functions<br>public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// useful in implementing<br>&nbsp;&nbsp;explicit PersonInfo(DatabaseID pid);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the IPerson interface<br>&nbsp;&nbsp;virtual ~PersonInfo();<br><br>&nbsp;&nbsp;virtual const char * theName() const;<br>&nbsp;&nbsp;virtual const char * theBirthDate() const;<br><br>&nbsp;&nbsp;virtual const char * valueDelimOpen() const;<br>&nbsp;&nbsp;virtual const char * valueDelimClose() const;<br>&nbsp;&nbsp;...<br>};<br><br><a id="page_198"></a>class CPerson: <span class="courierb">public IPerson, private PersonInfo</span> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// note use of MI<br>public:<br>&nbsp;&nbsp;explicit CPerson(&nbsp;&nbsp;&nbsp;&nbsp;DatabaseID pid): PersonInfo(pid) {}<br>&nbsp;&nbsp;virtual std::string name() const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// implementations<br>&nbsp;&nbsp;{ return PersonInfo::theName(); }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// of the required<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// IPerson member<br>&nbsp;&nbsp;virtual std::string birthDate() const&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// functions<br>&nbsp;&nbsp;{ return PersonInfo::theBirthDate(); }<br>private:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// redefinitions of<br>&nbsp;&nbsp;const char * valueDelimOpen() const { return ""; }&nbsp;&nbsp;&nbsp;&nbsp;// inherited virtual<br>&nbsp;&nbsp;const char * valueDelimClose() const { return ""; }&nbsp;&nbsp;&nbsp;// delimiter<br>};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// functions<br></p>
<p class="noindent">In UML, the design looks like this:</p>
<p class="mediaobject"><img src="https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/graphics/06inf11.gif" alt="images" width="250" height="108" data-mfp-src="/library/view/effective-c-55/0321334876/graphics/06inf11.gif"></p>
<p class="noindent">This example demonstrates that MI can be both useful and comprehensible.</p>
<p class="noindent">At the end of the day, multiple inheritance is just another tool in the object-oriented toolbox. Compared to single inheritance, it's typically more complicated to use and more complicated to understand, so if you've got an SI design that's more or less equivalent to an MI design, the SI design is almost certainly preferable. If the only design you can come up with involves MI, you should think a little harder — there's almost certainly <em>some</em> way to make SI work. At the same time, MI is sometimes the clearest, most maintainable, most reasonable way to get the job done. When that's the case, don't be afraid to use it. Just be sure to use it judiciously.</p>
<div class="note">
<h3 id="ch06note09">Things to Remember</h3>
<p class="indenthanding">• Multiple inheritance is more complex than single inheritance. It can lead to new ambiguity issues and to the need for virtual inheritance.</p>
<p class="indenthanding">• Virtual inheritance imposes costs in size, speed, and complexity of initialization and assignment. It's most practical when virtual base classes have no data.</p>
<p class="indenthanding">• Multiple inheritance does have legitimate uses. One scenario involves combining public inheritance from an Interface class with private inheritance from a class that helps with implementation.</p>
</div>
<div class="annotator-outer annotator-viewer viewer annotator-hide">
  <ul class="annotator-widget annotator-listing"></ul>
</div><div class="annotator-modal-wrapper annotator-editor-modal annotator-editor annotator-hide">
	<div class="annotator-outer editor">
		<h2 class="title">Highlight</h2>
		<form class="annotator-widget">
			<ul class="annotator-listing">
			<li class="annotator-item"><textarea id="annotator-field-0" placeholder="Add a note using markdown (optional)" class="js-editor" maxlength="750"></textarea></li></ul>
			<div class="annotator-controls">
				<a class="link-to-markdown" href="https://daringfireball.net/projects/markdown/basics" target="_blank">?</a>
				<ul>
					<li class="delete annotator-hide"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#delete" class="annotator-delete-note button positive">Delete Note</a></li>
					<li class="save"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#save" class="annotator-save annotator-focus button positive">Save Note</a></li>
					<li class="cancel"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#cancel" class="annotator-cancel button">Cancel</a></li>
				</ul>
			</div>
		</form>
	</div>
</div><div class="annotator-modal-wrapper annotator-delete-confirm-modal" style="display: none;">
  <div class="annotator-outer">
    <h2 class="title">Highlight</h2>
      <a class="js-close-delete-confirm annotator-cancel close" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#close">Close</a>
      <div class="annotator-widget">
         <div class="delete-confirm">
            Are you sure you want to permanently delete this note?
         </div>
         <div class="annotator-controls">
            <a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#cancel" class="annotator-cancel button js-cancel-delete-confirm">No, I changed my mind</a>
            <a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#delete" class="annotator-delete button positive js-delete-confirm">Yes, delete it</a>
         </div>
       </div>
   </div>
</div><div class="annotator-adder" style="display: none;">
	<ul class="adders ">
		
		<li class="copy"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#">Copy</a></li>
		
		<li class="add-highlight"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#">Add Highlight</a></li>
		<li class="add-note"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#">
			
				Add Note
			
		</a></li>
	</ul>
</div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="/site/library/view/effective-c-55/0321334876/ch05.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">5. Implementations</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="/site/library/view/effective-c-55/0321334876/ch07.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">7. Templates and Generic Programming</div>
        </a>
    
  
  </div>


      
    </section>
    <div class="reading-controls-bottom">
      <ul class="interface-controls js-bitlist">
        <li class="queue-control">
            <button type="button" class="rec-fav ss-queue js-queue js-current-chapter-queue" data-queue-endpoint="/api/v1/book/0321334876/chapter/ch06.html" data-for-analytics="0321334876:ch06.html">
      <span>Add to Queue</span>
  </button>
        </li>
      </ul>
    </div>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  





    
    



        
      </div>
      



  <footer class="pagefoot t-pagefoot">
    <a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#" class="icon-up"><div class="visuallyhidden">Back to top</div></a>
    <ul class="js-footer-nav">
      
        <li><a class="t-recommendations-footer" href="https://www.safaribooksonline.com/r/">Recommended</a></li>
      
      <li><a class="t-queue-footer" href="https://www.safaribooksonline.com/s/">Queue</a></li>
      
        <li><a class="t-recent-footer" href="https://www.safaribooksonline.com/history/">History</a></li>
        <li><a class="t-topics-footer" href="https://www.safaribooksonline.com/topics?q=*&amp;limit=21">Topics</a></li>
      
      
        <li><a class="t-tutorials-footer" href="https://www.safaribooksonline.com/tutorials/">Tutorials</a></li>
      
      <li><a class="t-settings-footer js-settings" href="https://www.safaribooksonline.com/u/">Settings</a></li>
      <li><a href="https://www.safaribooksonline.com/blog/">Blog</a></li>
      <li class="full-support"><a href="https://www.safaribooksonline.com/public/support">Support</a></li>
      <li><a href="https://community.safaribooksonline.com/">Feedback</a></li>
      <li><a href="https://www.safaribooksonline.com/apps/">Get the App</a></li>
      <li><a href="https://www.safaribooksonline.com/accounts/logout/">Sign Out</a></li>
    </ul>
    <span class="copyright">© 2016 <a href="https://www.safaribooksonline.com/" target="_blank">Safari</a>.</span>
    <a href="https://www.safaribooksonline.com/terms/">Terms of Service</a> /
    <a href="https://www.safaribooksonline.com/privacy/">Privacy Policy</a>
  </footer>




    

    <div class="font-flyout"><div class="font-controls-panel">
	<div class="nightmodes">
		<ul>
			<li class="day"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#" id="day-mode" title="Day Mode">
				<i class="fa fa-sun-o"></i>
				<span>Day Mode</span></a></li>
			<li class="cloudy"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#" id="cloudy-mode" title="Cloudy Mode">
				<i class="fa fa-cloud"></i>
				<span>Cloud Mode</span>
			</a></li>
			<li class="night"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#" id="night-mode" title="Night Mode">
				<i class="fa fa-moon-o"></i>
				<span>Night Mode</span>
			</a></li>
		</ul>
	</div>

	<div class="font-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-font left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-font-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-font right"></i>
		</div>
	</div>

	<div class="column-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-compress left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-column-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-expand right"></i>
		</div>
	</div>

	<a id="reset" class="button" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#">Reset</a>
</div>
</div>
    
  

<div class="annotator-notice"></div></body><span class="gr__tooltip"><span class="gr__tooltip-content"></span><i class="gr__tooltip-logo"></i><span class="gr__triangle"></span></span></html>