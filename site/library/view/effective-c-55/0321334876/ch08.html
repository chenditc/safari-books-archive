<!--[if IE]><![endif]--><!DOCTYPE html><!--[if IE 8]><html class="no-js ie8 oldie" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#"

    
        itemscope itemtype="http://schema.org/Book http://schema.org/ItemPage"" data-login-url="/accounts/login/"
data-offline-url="/"
data-url="/library/view/effective-c-55/0321334876/ch08.html"
data-csrf-cookie="csrfsafari"
data-highlight-privacy=""


  data-user-id="859452"
  data-user-uuid="4d373bec-fada-4717-9823-769db3ed3a36"
  data-username="dchen267"
  data-account-type="B2B"
  
  data-activated-trial-date="04/25/2016"


  data-archive="0321334876"
  data-publishers="Addison-Wesley Professional"



  data-htmlfile-name="ch08.html"
  data-epub-title="Effective C++: 55 Specific Ways to Improve Your Programs and Designs, Third Edition" data-debug=0 data-testing=0><![endif]--><!--[if gt IE 8]><!--><html class=" js flexbox flexboxlegacy no-touch websqldatabase indexeddb history csscolumns csstransforms localstorage sessionstorage applicationcache svg inlinesvg zoom gr__safaribooksonline_com" lang="en" prefix="og: http://ogp.me/ns/# og:book: http://ogp.me/ns/book# og:video: http://ogp.me/ns/video#" itemscope="" itemtype="http://schema.org/Book http://schema.org/ItemPage" "="" data-login-url="/accounts/login/" data-offline-url="/" data-url="/library/view/effective-c-55/0321334876/ch08.html" data-csrf-cookie="csrfsafari" data-highlight-privacy="" data-user-id="859452" data-user-uuid="4d373bec-fada-4717-9823-769db3ed3a36" data-username="dchen267" data-account-type="B2B" data-activated-trial-date="04/25/2016" data-archive="0321334876" data-publishers="Addison-Wesley Professional" data-htmlfile-name="ch08.html" data-epub-title="Effective C++: 55 Specific Ways to Improve Your Programs and Designs, Third Edition" data-debug="0" data-testing="0"><!--<![endif]--><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><meta name="author" content="Safari Books Online"><meta name="format-detection" content="telephone=no"><meta http-equiv="cleartype" content="on"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="apple-itunes-app" content="app-id=881697395, app-argument=safaridetail://0321334876"><meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, maximum-scale=1.0"><meta property="twitter:account_id" content="4503599627559754"><link rel="apple-touch-icon" href="https://www.safaribooksonline.com/static/images/apple-touch-icon.8cc2fd27400e.png"><link rel="shortcut icon" href="https://www.safaribooksonline.com/favicon.ico" type="image/x-icon"><link href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:200,300,400,600,700,900,200italic,300italic,400italic,600italic,700italic,900italic" rel="stylesheet" type="text/css"><title>8. Customizing new and delete - Effective C++: 55 Specific Ways to Improve Your Programs and Designs, Third Edition</title><link rel="stylesheet" href="https://www.safaribooksonline.com/static/CACHE/css/e4b0fef39b55.css" type="text/css"><link rel="stylesheet" type="text/css" href="https://www.safaribooksonline.com/static/css/annotator.min.fd58f69f4908.css"><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css"><style type="text/css" title="ibis-book">
    #sbo-rt-content div{margin-top:5pt;margin-bottom:5pt;margin-right:15pt}#sbo-rt-content .cover{margin-top:2pt;margin-bottom:2pt;text-align:center}#sbo-rt-content h1{page-break-before:right;margin-top:5pt;text-align:center;margin-bottom:12pt;font-weight:bold}#sbo-rt-content .subtitle{font-size:large;margin-top:30pt;margin-bottom:55pt;font-weight:bold;text-align:center}#sbo-rt-content .publisher{text-align:center;margin-top:64pt;margin-bottom:4pt}#sbo-rt-content .copyright{margin-top:5pt;margin-bottom:5pt;text-indent:.12pt}#sbo-rt-content h2{page-break-before:right;margin-top:7pt;margin-bottom:25pt;font-weight:bold}#sbo-rt-content h3{margin-top:9pt;margin-bottom:8pt;text-indent:.12pt;font-weight:bold}#sbo-rt-content h4{margin-top:9pt;margin-bottom:6pt;font-weight:bold}#sbo-rt-content h5{margin-top:9pt;margin-bottom:6pt;font-weight:bold}#sbo-rt-content h6{margin-top:8pt;margin-bottom:6pt;font-weight:bold}#sbo-rt-content .author{text-align:center;font-weight:bold;margin-top:66pt;margin-bottom:24pt}#sbo-rt-content .bolditalic{font-weight:bold;font-style:italic}#sbo-rt-content .toc-chapter{margin-top:12pt;margin-bottom:5pt;text-indent:.12pt;font-weight:bold}#sbo-rt-content .emphasis{font-style:italic}#sbo-rt-content .mediaobject{margin-top:12pt;margin-bottom:12pt;text-align:center}#sbo-rt-content .tabimage{margin-top:12pt;margin-bottom:12pt;text-align:center}#sbo-rt-content .smaller{font-size:small}#sbo-rt-content .center{margin-top:50pt;margin-bottom:5pt;text-align:center}#sbo-rt-content .note{margin-top:6pt;margin-bottom:12pt;margin-left:.12pt;text-indent:.12pt;margin-right:24pt}#sbo-rt-content .toc-preface{margin-top:5pt;margin-bottom:5pt;margin-left:1pt;text-indent:.12pt;font-weight:bold}#sbo-rt-content .programlisting{font-family:"Courier New";font-size:small;margin-top:8pt;margin-bottom:8pt;text-indent:.12pt}#sbo-rt-content .programlisting1{font-family:"Courier New";font-size:small;margin-top:5pt;margin-bottom:4pt;margin-left:36pt;text-indent:.12pt}#sbo-rt-content code{font-size:x-small}#sbo-rt-content .toc-section{margin-top:4pt;margin-bottom:4pt;margin-left:12pt;text-indent:.12pt}#sbo-rt-content .toc-index{margin-top:12pt;margin-bottom:4pt;text-indent:.12pt;font-weight:bold}#sbo-rt-content .toc-appendix{margin-top:12pt;margin-bottom:4pt;text-indent:.12pt;font-weight:bold}#sbo-rt-content .strong{font-weight:bold}#sbo-rt-content .italic{font-style:italic}#sbo-rt-content .title{margin-top:12pt;margin-bottom:6pt;font-size:medium;font-weight:bold;text-align:center}#sbo-rt-content .attribution{margin-top:4pt;margin-bottom:12pt;margin-right:15pt;text-align:right}#sbo-rt-content .indexmain{margin-top:2pt;margin-bottom:2pt;text-indent:.12pt}#sbo-rt-content .indexsub{margin-top:2pt;margin-bottom:2pt;margin-left:24pt;text-indent:.12pt}#sbo-rt-content .indexsubsub{margin-top:2pt;margin-bottom:2pt;margin-left:40pt;text-indent:.12pt}#sbo-rt-content .paraindent{margin-top:4pt;margin-bottom:4pt;margin-left:25pt;text-indent:.12pt}#sbo-rt-content .indenthanding{margin-top:4pt;margin-bottom:4pt;padding-left:25pt;text-indent:-15pt}#sbo-rt-content .indenthanding1{margin-top:4pt;margin-bottom:4pt;padding-left:48pt;text-indent:-8pt}#sbo-rt-content .underline{text-decoration:underline}#sbo-rt-content .footnotes{font-size:small;margin-top:5pt;margin-bottom:4pt;padding-left:20pt;text-indent:-8pt}#sbo-rt-content .courierb{font-family:"Courier New Bold"}#sbo-rt-content .courieri{font-family:"Courier New Italic"}#sbo-rt-content .center1{margin-top:4pt;margin-bottom:4pt;margin-left:80pt;text-align:center}#sbo-rt-content .noindent{margin-top:6pt;margin-bottom:5pt;text-indent:.12pt}#sbo-rt-content .noindent1{margin-top:12pt;margin-bottom:2pt;text-indent:.12pt}#sbo-rt-content .edition{font-size:1.2em;margin-top:2pt;margin-bottom:2pt;text-align:center}#sbo-rt-content .image1{page-break-before:always;page-break-after:always}#sbo-rt-content .codelink{margin-top:6pt;margin-bottom:6pt;text-indent:.12pt;font-weight:bold;page-break-after:avoid;font-size:small}
    </style><link rel="canonical" href="/Library/view/effective-c-55/0321334876/ch08.html"><meta name="description" content="8. Customizing new and delete In these days of computing environments boasting built-in support for garbage collection (e.g., Java and .NET), the manual C++ approach to memory management can ... "><meta property="og:title" content="8. Customizing new and delete"><meta itemprop="isPartOf" content="/library/view/effective-c-55/0321334876/"><meta itemprop="name" content="8. Customizing new and delete"><meta property="og:url" itemprop="url" content="https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/ch08.html"><meta property="og:site_name" content="Safari"><meta property="og:image" itemprop="thumbnailUrl" content="https://www.safaribooksonline.com/library/cover/0321334876/"><meta property="og:description" itemprop="description" content="8. Customizing new and delete In these days of computing environments boasting built-in support for garbage collection (e.g., Java and .NET), the manual C++ approach to memory management can ... "><meta itemprop="inLanguage" content="en"><meta itemprop="publisher" content="Addison-Wesley Professional"><meta property="og:type" content="book"><meta property="og:book:isbn" itemprop="isbn" content="0321334876"><meta property="og:book:author" itemprop="author" content="Scott Meyers"><meta property="og:book:tag" itemprop="about" content="C++"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@safari"><style type="text/css" id="font-styles" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-size: <%= font_size %> !important; }"></style><style type="text/css" id="font-family" data-template="#sbo-rt-content, #sbo-rt-content p, #sbo-rt-content div { font-family: <%= font_family %> !important; }"></style><style type="text/css" id="column-width" data-template="#sbo-rt-content { max-width: <%= column_width %>% !important; margin: 0 auto !important; }"></style><!--[if lt IE 9]><script src="/static/js/src/respond.min.cf5c9b7980e5.js"></script><![endif]--><style id="annotator-dynamic-style">.annotator-adder, .annotator-outer, .annotator-notice {
  z-index: 100019;
}
.annotator-filter {
  z-index: 100009;
}</style></head>


<body class="reading sidenav nav-collapsed  scalefonts library" data-gr-c-s-loaded="true">

    
      <div class="hide working" role="status">
        <div class="working-image"></div>
      </div>
      <div class="sbo-site-nav">
        




<a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#container" class="skip">Skip to content</a><header class="topbar t-topbar"><nav role="navigation" class="js-site-nav"><ul class="topnav"><li class="t-logo"><a href="https://www.safaribooksonline.com/home/" class="l0 None safari-home nav-icn js-keyboard-nav-home"><svg width="20" height="20" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" version="1.1" fill="#4A3C31"><desc>Safari Home Icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M4 9.9L4 9.9 4 18 16 18 16 9.9 10 4 4 9.9ZM2.6 8.1L2.6 8.1 8.7 1.9 10 0.5 11.3 1.9 17.4 8.1 18 8.7 18 9.5 18 18.1 18 20 16.1 20 3.9 20 2 20 2 18.1 2 9.5 2 8.7 2.6 8.1Z"></path><rect x="10" y="12" width="3" height="7"></rect><rect transform="translate(18.121320, 10.121320) rotate(-315.000000) translate(-18.121320, -10.121320) " x="16.1" y="9.1" width="4" height="2"></rect><rect transform="translate(2.121320, 10.121320) scale(-1, 1) rotate(-315.000000) translate(-2.121320, -10.121320) " x="0.1" y="9.1" width="4" height="2"></rect></g></svg><span>Safari Home</span></a></li><li><a href="https://www.safaribooksonline.com/r/" class="t-recommendations-nav l0 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>recommendations icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M50 25C50 18.2 44.9 12.5 38.3 11.7 37.5 5.1 31.8 0 25 0 18.2 0 12.5 5.1 11.7 11.7 5.1 12.5 0 18.2 0 25 0 31.8 5.1 37.5 11.7 38.3 12.5 44.9 18.2 50 25 50 31.8 50 37.5 44.9 38.3 38.3 44.9 37.5 50 31.8 50 25ZM25 3.1C29.7 3.1 33.6 6.9 34.4 11.8 30.4 12.4 26.9 15.1 25 18.8 23.1 15.1 19.6 12.4 15.6 11.8 16.4 6.9 20.3 3.1 25 3.1ZM34.4 15.6C33.6 19.3 30.7 22.2 27.1 22.9 27.8 19.2 30.7 16.3 34.4 15.6ZM22.9 22.9C19.2 22.2 16.3 19.3 15.6 15.6 19.3 16.3 22.2 19.2 22.9 22.9ZM3.1 25C3.1 20.3 6.9 16.4 11.8 15.6 12.4 19.6 15.1 23.1 18.8 25 15.1 26.9 12.4 30.4 11.8 34.4 6.9 33.6 3.1 29.7 3.1 25ZM22.9 27.1C22.2 30.7 19.3 33.6 15.6 34.4 16.3 30.7 19.2 27.8 22.9 27.1ZM25 46.9C20.3 46.9 16.4 43.1 15.6 38.2 19.6 37.6 23.1 34.9 25 31.3 26.9 34.9 30.4 37.6 34.4 38.2 33.6 43.1 29.7 46.9 25 46.9ZM27.1 27.1C30.7 27.8 33.6 30.7 34.4 34.4 30.7 33.6 27.8 30.7 27.1 27.1ZM38.2 34.4C37.6 30.4 34.9 26.9 31.3 25 34.9 23.1 37.6 19.6 38.2 15.6 43.1 16.4 46.9 20.3 46.9 25 46.9 29.7 43.1 33.6 38.2 34.4Z" fill="currentColor"></path></g></svg><span>Recommended</span></a></li><li><a href="https://www.safaribooksonline.com/s/" class="t-queue-nav l0 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>queue icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 29.2C25.4 29.2 25.8 29.1 26.1 28.9L48.7 16.8C49.5 16.4 50 15.5 50 14.6 50 13.7 49.5 12.8 48.7 12.4L26.1 0.3C25.4-0.1 24.6-0.1 23.9 0.3L1.3 12.4C0.5 12.8 0 13.7 0 14.6 0 15.5 0.5 16.4 1.3 16.8L23.9 28.9C24.2 29.1 24.6 29.2 25 29.2ZM7.3 14.6L25 5.2 42.7 14.6 25 24 7.3 14.6ZM48.7 22.4L47.7 21.9 25 34.2 2.3 21.9 1.3 22.4C0.5 22.9 0 23.7 0 24.7 0 25.6 0.5 26.5 1.3 26.9L23.9 39.3C24.2 39.5 24.6 39.6 25 39.6 25.4 39.6 25.8 39.5 26.1 39.3L48.7 26.9C49.5 26.5 50 25.6 50 24.7 50 23.7 49.5 22.9 48.7 22.4ZM48.7 32.8L47.7 32.3 25 44.6 2.3 32.3 1.3 32.8C0.5 33.3 0 34.1 0 35.1 0 36 0.5 36.9 1.3 37.3L23.9 49.7C24.2 49.9 24.6 50 25 50 25.4 50 25.8 49.9 26.1 49.7L48.7 37.3C49.5 36.9 50 36 50 35.1 50 34.1 49.5 33.3 48.7 32.8Z" fill="currentColor"></path></g></svg><span>Queue</span></a></li><li class="search"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#" class="t-search-nav trigger nav-icn l0" data-dropdown-selector=".searchbox"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>search icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M31.3 0C20.9 0 12.5 8.4 12.5 18.8 12.5 22.5 13.6 25.9 15.4 28.8L1.2 42.9C-0.4 44.5-0.4 47.2 1.2 48.8 2 49.6 3.1 50 4.2 50 5.2 50 6.3 49.6 7.1 48.8L21.2 34.6C24.1 36.5 27.5 37.5 31.3 37.5 41.6 37.5 50 29.1 50 18.8 50 8.4 41.6 0 31.3 0ZM31.3 31.3C24.4 31.3 18.8 25.6 18.8 18.8 18.8 11.9 24.4 6.3 31.3 6.3 38.1 6.3 43.8 11.9 43.8 18.8 43.8 25.6 38.1 31.3 31.3 31.3Z" fill="currentColor"></path></g></svg><span>Search</span></a></li><li class="usermenu dropdown"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#" class="trigger l0 nav-icn nav-dropdown"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" version="1.1" fill="#4A3C31"><desc>navigation arrow</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M0.1 12.5L9.7 3.1C9.8 3 9.9 3 10 3 10.1 3 10.2 3 10.3 3.1L19.9 12.5C20 12.5 20 12.6 20 12.8 20 12.9 20 13 19.9 13L17 15.9C16.9 16 16.8 16 16.7 16 16.5 16 16.4 16 16.4 15.9L10 9.7 3.6 15.9C3.6 16 3.5 16 3.3 16 3.2 16 3.1 16 3 15.9L0.1 13C0 12.9 0 12.8 0 12.7 0 12.7 0 12.6 0.1 12.5Z"></path></g></svg><span>Expand Nav</span></a><div class="drop-content"><ul><li><a href="https://www.safaribooksonline.com/history/" class="t-recent-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>recent items icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 0C11.2 0 0 11.2 0 25 0 38.8 11.2 50 25 50 38.8 50 50 38.8 50 25 50 11.2 38.8 0 25 0ZM6.3 25C6.3 14.6 14.6 6.3 25 6.3 35.4 6.3 43.8 14.6 43.8 25 43.8 35.4 35.4 43.8 25 43.8 14.6 43.8 6.3 35.4 6.3 25ZM31.8 31.5C32.5 30.5 32.4 29.2 31.6 28.3L27.1 23.8 27.1 12.8C27.1 11.5 26.2 10.4 25 10.4 23.9 10.4 22.9 11.5 22.9 12.8L22.9 25.7 28.8 31.7C29.2 32.1 29.7 32.3 30.2 32.3 30.8 32.3 31.3 32 31.8 31.5Z" fill="currentColor"></path></g></svg><span>History</span></a></li><li><a href="https://www.safaribooksonline.com/topics" class="t-topics-link l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 55" version="1.1" fill="#4A3C31"><desc>topics icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M25 55L50 41.262 50 13.762 25 0 0 13.762 0 41.262 25 55ZM8.333 37.032L8.333 17.968 25 8.462 41.667 17.968 41.667 37.032 25 46.538 8.333 37.032Z" fill="currentColor"></path></g></svg><span>Topics</span></a></li><li><a href="https://www.safaribooksonline.com/tutorials/" class="l1 nav-icn t-tutorials-nav js-toggle-menu-item None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" version="1.1" fill="#4A3C31"><desc>tutorials icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M15.8 18.2C15.8 18.2 15.9 18.2 16 18.2 16.1 18.2 16.2 18.2 16.4 18.2 16.5 18.2 16.7 18.1 16.9 18 17 17.9 17.1 17.8 17.2 17.7 17.3 17.6 17.4 17.5 17.4 17.4 17.5 17.2 17.6 16.9 17.6 16.7 17.6 16.6 17.6 16.5 17.6 16.4 17.5 16.2 17.5 16.1 17.4 15.9 17.3 15.8 17.2 15.6 17 15.5 16.8 15.3 16.6 15.3 16.4 15.2 16.2 15.2 16 15.2 15.8 15.2 15.7 15.2 15.5 15.3 15.3 15.4 15.2 15.4 15.1 15.5 15 15.7 14.9 15.8 14.8 15.9 14.7 16 14.7 16.1 14.6 16.3 14.6 16.4 14.6 16.5 14.6 16.6 14.6 16.6 14.6 16.7 14.6 16.9 14.6 17 14.6 17.1 14.7 17.3 14.7 17.4 14.8 17.6 15 17.7 15.1 17.9 15.2 18 15.3 18 15.5 18.1 15.5 18.1 15.6 18.2 15.7 18.2 15.7 18.2 15.7 18.2 15.8 18.2L15.8 18.2ZM9.4 11.5C9.5 11.5 9.5 11.5 9.6 11.5 9.7 11.5 9.9 11.5 10 11.5 10.2 11.5 10.3 11.4 10.5 11.3 10.6 11.2 10.8 11.1 10.9 11 10.9 10.9 11 10.8 11.1 10.7 11.2 10.5 11.2 10.2 11.2 10 11.2 9.9 11.2 9.8 11.2 9.7 11.2 9.5 11.1 9.4 11 9.2 10.9 9.1 10.8 8.9 10.6 8.8 10.5 8.7 10.3 8.6 10 8.5 9.9 8.5 9.7 8.5 9.5 8.5 9.3 8.5 9.1 8.6 9 8.7 8.8 8.7 8.7 8.8 8.6 9 8.5 9.1 8.4 9.2 8.4 9.3 8.2 9.5 8.2 9.8 8.2 10 8.2 10.1 8.2 10.2 8.2 10.3 8.2 10.5 8.3 10.6 8.4 10.7 8.5 10.9 8.6 11.1 8.7 11.2 8.9 11.3 9 11.4 9.1 11.4 9.2 11.4 9.3 11.5 9.3 11.5 9.3 11.5 9.4 11.5 9.4 11.5L9.4 11.5ZM3 4.8C3.1 4.8 3.1 4.8 3.2 4.8 3.4 4.8 3.5 4.8 3.7 4.8 3.8 4.8 4 4.7 4.1 4.6 4.3 4.5 4.4 4.4 4.5 4.3 4.6 4.2 4.6 4.1 4.7 4 4.8 3.8 4.8 3.5 4.8 3.3 4.8 3.1 4.8 3 4.8 2.9 4.7 2.8 4.7 2.6 4.6 2.5 4.5 2.3 4.4 2.2 4.2 2.1 4 1.9 3.8 1.9 3.6 1.8 3.5 1.8 3.3 1.8 3.1 1.8 2.9 1.8 2.7 1.9 2.6 2 2.4 2.1 2.3 2.2 2.2 2.3 2.1 2.4 2 2.5 2 2.6 1.8 2.8 1.8 3 1.8 3.3 1.8 3.4 1.8 3.5 1.8 3.6 1.8 3.8 1.9 3.9 2 4 2.1 4.2 2.2 4.4 2.4 4.5 2.5 4.6 2.6 4.7 2.7 4.7 2.8 4.7 2.9 4.8 2.9 4.8 3 4.8 3 4.8 3 4.8L3 4.8ZM13.1 15.2C13.2 15.1 13.2 15.1 13.2 15.1 13.3 14.9 13.4 14.7 13.6 14.5 13.8 14.2 14.1 14 14.4 13.8 14.7 13.6 15.1 13.5 15.5 13.4 15.9 13.4 16.3 13.4 16.7 13.5 17.2 13.5 17.6 13.7 17.9 13.9 18.2 14.1 18.5 14.4 18.7 14.7 18.9 15 19.1 15.3 19.2 15.6 19.3 15.9 19.4 16.1 19.4 16.4 19.4 17 19.3 17.5 19.1 18.1 19 18.3 18.9 18.5 18.7 18.7 18.5 19 18.3 19.2 18 19.4 17.7 19.6 17.3 19.8 16.9 19.9 16.6 20 16.3 20 16 20 15.8 20 15.6 20 15.4 19.9 15.4 19.9 15.4 19.9 15.4 19.9 15.2 19.9 15 19.8 14.9 19.8 14.8 19.7 14.7 19.7 14.6 19.7 14.4 19.6 14.3 19.5 14.1 19.3 13.7 19.1 13.4 18.7 13.2 18.4 13.1 18.1 12.9 17.8 12.9 17.5 12.8 17.3 12.8 17.1 12.8 16.9L3.5 14.9C3.3 14.9 3.1 14.8 3 14.8 2.7 14.7 2.4 14.5 2.1 14.3 1.7 14 1.4 13.7 1.2 13.3 1 13 0.9 12.6 0.8 12.3 0.7 12 0.7 11.7 0.7 11.4 0.7 11 0.8 10.5 1 10.1 1.1 9.8 1.3 9.5 1.6 9.2 1.8 8.9 2.1 8.7 2.4 8.5 2.8 8.3 3.2 8.1 3.6 8.1 3.9 8 4.2 8 4.5 8 4.6 8 4.8 8 4.9 8.1L6.8 8.5C6.8 8.4 6.8 8.4 6.8 8.4 6.9 8.2 7.1 8 7.2 7.8 7.5 7.5 7.7 7.3 8 7.1 8.4 6.9 8.7 6.8 9.1 6.7 9.5 6.7 10 6.7 10.4 6.8 10.8 6.8 11.2 7 11.5 7.2 11.8 7.5 12.1 7.7 12.4 8 12.6 8.3 12.7 8.6 12.8 8.9 12.9 9.2 13 9.4 13 9.7 13 9.7 13 9.8 13 9.8 13.6 9.9 14.2 10.1 14.9 10.2 15 10.2 15 10.2 15.1 10.2 15.3 10.2 15.4 10.2 15.6 10.2 15.8 10.1 16 10 16.2 9.9 16.4 9.8 16.5 9.6 16.6 9.5 16.8 9.2 16.9 8.8 16.9 8.5 16.9 8.3 16.9 8.2 16.8 8 16.8 7.8 16.7 7.7 16.6 7.5 16.5 7.3 16.3 7.2 16.2 7.1 16 7 15.9 6.9 15.8 6.9 15.7 6.9 15.6 6.8 15.5 6.8L6.2 4.8C6.2 5 6 5.2 5.9 5.3 5.7 5.6 5.5 5.8 5.3 6 4.9 6.2 4.5 6.4 4.1 6.5 3.8 6.6 3.5 6.6 3.2 6.6 3 6.6 2.8 6.6 2.7 6.6 2.6 6.6 2.6 6.5 2.6 6.5 2.5 6.5 2.3 6.5 2.1 6.4 1.8 6.3 1.6 6.1 1.3 6 1 5.7 0.7 5.4 0.5 5 0.3 4.7 0.2 4.4 0.1 4.1 0 3.8 0 3.6 0 3.3 0 2.8 0.1 2.2 0.4 1.7 0.5 1.5 0.7 1.3 0.8 1.1 1.1 0.8 1.3 0.6 1.6 0.5 2 0.3 2.3 0.1 2.7 0.1 3.1 0 3.6 0 4 0.1 4.4 0.2 4.8 0.3 5.1 0.5 5.5 0.8 5.7 1 6 1.3 6.2 1.6 6.3 1.9 6.4 2.3 6.5 2.5 6.6 2.7 6.6 3 6.6 3 6.6 3.1 6.6 3.1 9.7 3.8 12.8 4.4 15.9 5.1 16.1 5.1 16.2 5.2 16.4 5.2 16.7 5.3 16.9 5.5 17.2 5.6 17.5 5.9 17.8 6.2 18.1 6.5 18.3 6.8 18.4 7.2 18.6 7.5 18.6 7.9 18.7 8.2 18.7 8.6 18.7 9 18.6 9.4 18.4 9.8 18.3 10.1 18.2 10.3 18 10.6 17.8 10.9 17.5 11.1 17.3 11.3 16.9 11.6 16.5 11.8 16 11.9 15.7 12 15.3 12 15 12 14.8 12 14.7 12 14.5 11.9 13.9 11.8 13.3 11.7 12.6 11.5 12.5 11.7 12.4 11.9 12.3 12 12.1 12.3 11.9 12.5 11.7 12.7 11.3 12.9 10.9 13.1 10.5 13.2 10.2 13.3 9.9 13.3 9.6 13.3 9.4 13.3 9.2 13.3 9 13.2 9 13.2 9 13.2 9 13.2 8.8 13.2 8.7 13.2 8.5 13.1 8.2 13 8 12.8 7.7 12.6 7.4 12.4 7.1 12 6.8 11.7 6.7 11.4 6.6 11.1 6.5 10.8 6.4 10.6 6.4 10.4 6.4 10.2 5.8 10.1 5.2 9.9 4.5 9.8 4.4 9.8 4.4 9.8 4.3 9.8 4.1 9.8 4 9.8 3.8 9.8 3.6 9.9 3.4 10 3.2 10.1 3 10.2 2.9 10.4 2.8 10.5 2.6 10.8 2.5 11.1 2.5 11.5 2.5 11.6 2.5 11.8 2.6 12 2.6 12.1 2.7 12.3 2.8 12.5 2.9 12.6 3.1 12.8 3.2 12.9 3.3 13 3.5 13.1 3.6 13.1 3.7 13.1 3.8 13.2 3.9 13.2L13.1 15.2 13.1 15.2Z" fill="currentColor"></path></g></svg><span>Tutorials</span></a></li><li class="nav-offers flyout-parent"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#" class="l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" width="50" height="50" viewBox="0 0 50 50" version="1.1" fill="#4A3C31"><desc>offers icon</desc><path d="M10.8 43.7L0 39 0 10.2 13.6 4.6 23.3 8.7 11.5 13.5C11 13.6 10.8 13.9 10.8 14.3L10.8 43.7 10.8 43.7Z"></path><polygon points="12.3 44.4 25 50 38 44.3 38 14.7 25.2 9.4 12.3 14.7 12.3 44.4"></polygon><path d="M36.6 4.7L50 10.2 50 39 39.5 43.6 39.5 14.3C39.5 13.8 39.2 13.6 38.8 13.5L27 8.7 36.6 4.7 36.6 4.7Z"></path><polygon points="34.8 4 25 0 15.4 3.9 25.2 7.9 34.8 4"></polygon></svg><span>Offers</span></a><ul class="flyout"><li><a href="https://www.safaribooksonline.com/oreilly-conferences/" class="l2 nav-icn"><span>Conferences</span></a></li><li><a href="https://www.safaribooksonline.com/oreilly-newsletters/" class="l2 nav-icn"><span>Newsletter</span></a></li></ul></li><li class="nav-highlights"><a href="https://www.safaribooksonline.com/u/003o000000t5q9fAAA/" class="t-highlights-nav l1 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 35" version="1.1" fill="#4A3C31"><desc>highlights icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M13.325 18.071L8.036 18.071C8.036 11.335 12.36 7.146 22.5 5.594L22.5 0C6.37 1.113 0 10.632 0 22.113 0 29.406 3.477 35 10.403 35 15.545 35 19.578 31.485 19.578 26.184 19.578 21.556 17.211 18.891 13.325 18.071L13.325 18.071ZM40.825 18.071L35.565 18.071C35.565 11.335 39.86 7.146 50 5.594L50 0C33.899 1.113 27.5 10.632 27.5 22.113 27.5 29.406 30.977 35 37.932 35 43.045 35 47.078 31.485 47.078 26.184 47.078 21.556 44.74 18.891 40.825 18.071L40.825 18.071Z" fill="currentColor"></path></g></svg><span>Highlights</span></a></li><li><a href="https://www.safaribooksonline.com/u/" class="t-settings-nav l1 js-settings nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z" fill="currentColor"></path></g></svg><span>Settings</span></a></li><li><a href="https://community.safaribooksonline.com/" class="l1 no-icon">Feedback</a></li><li><a href="https://www.safaribooksonline.com/accounts/logout/" class="l1 no-icon">Sign Out</a></li></ul><ul class="profile"><li><a href="https://www.safaribooksonline.com/u/" class="l2 nav-icn None"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 50 53" version="1.1" fill="#4A3C31"><desc>settings icon</desc><g stroke="none" stroke-width="1" fill-rule="evenodd"><path d="M44.6 29.6C44.7 28.6 44.8 27.5 44.8 26.5 44.8 25.5 44.7 24.4 44.6 23.4L49.6 19C50 18.8 50.1 18.3 49.9 17.9 48.9 14.7 47.1 11.7 44.9 9.1 44.6 8.8 44.2 8.7 43.8 8.8L37.4 11.1C35.8 9.8 34 8.7 32.1 8L30.9 1.4C30.8 0.9 30.4 0.6 30 0.5 26.7-0.2 23.3-0.2 20 0.5 19.6 0.6 19.2 0.9 19.1 1.4L17.9 8C16 8.7 14.1 9.8 12.6 11.1L6.2 8.8C5.8 8.7 5.4 8.8 5.1 9.1 2.9 11.7 1.1 14.7 0.1 17.9 -0.1 18.3 0 18.8 0.4 19L5.4 23.4C5.3 24.4 5.2 25.5 5.2 26.5 5.2 27.5 5.3 28.6 5.4 29.6L0.4 34C0 34.2-0.1 34.7 0.1 35.1 1.1 38.3 2.9 41.4 5.1 43.9 5.4 44.2 5.8 44.4 6.2 44.2L12.6 42C14.1 43.2 16 44.3 17.9 45L19.1 51.7C19.2 52.1 19.6 52.5 20 52.5 21.6 52.8 23.3 53 25 53 26.7 53 28.4 52.8 30 52.5 30.4 52.5 30.8 52.1 30.9 51.7L32.1 45C34 44.3 35.8 43.2 37.4 42L43.8 44.2C44.2 44.4 44.6 44.2 44.9 43.9 47.1 41.4 48.9 38.3 49.9 35.1 50.1 34.7 50 34.2 49.6 34L44.6 29.6ZM25 36.4C19.6 36.4 15.2 32 15.2 26.5 15.2 21 19.6 16.6 25 16.6 30.4 16.6 34.8 21 34.8 26.5 34.8 32 30.4 36.4 25 36.4Z" fill="currentColor"></path></g></svg><span>Settings</span></a></li><li><a href="https://community.safaribooksonline.com/" class="l2">Feedback</a></li><li><a href="https://www.safaribooksonline.com/accounts/logout/" class="l2">Sign Out</a></li></ul></div></li></ul></nav></header>


      </div>
      <div id="container" class="application">
        
          <div class="nav-container clearfix">
            


            
            
          </div>

          

  <div class="js-toc">
    
      <div class="sbo-reading-menu sbo-menu-top"><section class="sbo-toc-container toc-menu"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#" class="sbo-toc-thumb"><span class="sbo-title ss-list"><h1><div class="visuallyhidden">Table of Contents for </div>
      
      Effective C++: 55 Specific Ways to Improve Your Programs and Designs, Third Edition
      
    </h1></span></a><div class="toc-contents"></div></section></div>

    

    <div class="interface-controls interface-controls-top">
      <ul class="interface-control-btns js-bitlist js-reader">
        <li class="js-search-in-archive search-in-archive t-search-in-archive"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#" title="Search in archive" class="js-search-controls search-controls"><span class="icon">Search in book...</span></a><form class="search-archive-bar js-search-form"><input type="search" name="query" placeholder="Search inside this book..." autocomplete="off"></form><div class="search-archive-results"><div class="js-sitb-results-region"></div></div></li><li class="queue-control"><button type="button" class="rec-fav ss-queue js-queue js-current-chapter-queue" data-queue-endpoint="/api/v1/book/0321334876/chapter/ch08.html" data-for-analytics="0321334876:ch08.html"><span>Add to Queue</span></button></li><li class="js-font-control-panel font-control-activator"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#" data-push-state="false" id="font-controls" title="Change font size" aria-label="Change font size"><span class="icon">Toggle Font Controls</span></a></li><li class="dropdown sharing-controls"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#" class="trigger" data-push-state="false" title="Share" aria-label="Share"><i class="fa fa-share"></i></a><ul class="social-sharing dropdown-menu"><li><a class="twitter share-button t-twitter" target="_blank" aria-label="Share this section on Twitter" title="Share this section on Twitter" href="https://twitter.com/share?url=https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/ch08.html&amp;text=Effective%20C%2B%2B%3A%2055%20Specific%20Ways%20to%20Improve%20Your%20Programs%20and%20Designs%2C%20Third%20Edition&amp;via=safari"><span>Twitter</span></a></li><li><a class="facebook share-button t-facebook" target="_blank" aria-label="Share this section on Facebook" title="Share this section on Facebook" href="https://www.facebook.com/sharer/sharer.php?u=https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/ch08.html"><span>Facebook</span></a></li><li><a class="googleplus share-button t-googleplus" target="_blank" aria-label="Share this secton on Google Plus" title="Share this secton on Google Plus" href="https://plus.google.com/share?url=https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/ch08.html"><span>Google Plus</span></a></li><li><a class="email share-button t-email" aria-label="Share this section via email" title="Share this section via email" href="mailto:?subject=Safari:%208.%20Customizing%20new%20and%20delete&amp;body=https://www.safaribooksonline.com/library/view/effective-c-55/0321334876/ch08.html%0D%0Afrom%20Effective%20C%2B%2B%3A%2055%20Specific%20Ways%20to%20Improve%20Your%20Programs%20and%20Designs%2C%20Third%20Edition%0D%0A"><span>Email</span></a></li></ul></li>
      </ul>
    </div>

    <section role="document">
      
	  <div class="t-sbo-prev sbo-prev sbo-nav-top">
  
    
      
        <a href="/Library/view/effective-c-55/0321334876/ch07.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">7. Templates and Generic Programming</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-top">
  
    
      
        <a href="/Library/view/effective-c-55/0321334876/ch09.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">9. Miscellany</div>
        </a>
    
  
  </div>



<div id="sbo-rt-content"><div class="annotator-wrapper"><h2 id="ch08">8. Customizing new and delete</h2>
<p class="noindent"><a id="page_239"></a>In these days of computing environments boasting built-in support for garbage collection (e.g., Java and .NET), the manual C++ approach to memory management can look rather old-fashioned. Yet many developers working on demanding systems applications choose C++ <em>because</em> it lets them manage memory manually. Such developers study the memory usage characteristics of their software, and they tailor their allocation and deallocation routines to offer the best possible performance (in both time and space) for the systems they build.</p>
<p class="noindent">Doing that requires an understanding of how C++'s memory management routines behave, and that's the focus of this chapter. The two primary players in the game are the allocation and deallocation routines (<code>operator new</code> and <code>operator delete</code>), with a supporting role played by the new-handler — the function called when <code>operator new</code> can't satisfy a request for memory.</p>
<p class="noindent">Memory management in a multithreaded environment poses challenges not present in a single-threaded system, because the heap is a modifiable global resource, thus rife with opportunities for the race conditions that bedevil access to all such resources in threaded systems. Many Items in this chapter mention the use of modifiable static data, always something to put thread-aware programmers on high alert. Without proper synchronization, the use of lock-free algorithms, or careful design to prevent concurrent access, calls to memory routines can easily lead to corrupted heap management data structures. Rather than repeatedly remind you of this danger, I'll mention it here and assume that you keep it in mind for the rest of the chapter.</p>
<p class="noindent">Something else to keep in mind is that <code>operator new</code> and <code>operator delete</code> apply only to allocations for single objects. Memory for arrays is allocated by <code>operator new[]</code> and deallocated by <code>operator delete[]</code>. (In both cases, note the “<code>[]</code>” part of the function names.) Unless indicated otherwise, <a id="page_240"></a>everything I write about <code>operator new</code> and <code>operator delete</code> also applies to <code>operator new[]</code> and <code>operator delete[]</code>.</p>
<p class="noindent">Finally, note that heap memory for STL containers is managed by the containers' allocator objects, not by <code>new</code> and <code>delete</code> directly. That being the case, this chapter has nothing to say about STL allocators.</p>
<h3 id="ch08lev1sec1">Item 49: Understand the behavior of the new-handler</h3>
<p class="noindent">When <code>operator new</code> can't satisfy a memory allocation request, it throws an exception. Long ago, it returned a null pointer, and some older compilers still do that. You can still get the old behavior (sort of), but I'll defer that discussion until the end of this Item.</p>
<p class="noindent">Before <code>operator new</code> throws an exception in response to an unsatisfiable request for memory, it calls a client-specifiable error-handling function called a <em>new-handler</em>. (This is not quite true. What <code>operator new</code> really does is a bit more complicated. Details are provided in <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec3">Item 51</a>.) To specify the out-of-memory-handling function, clients call <code>set_new_handler</code>, a standard library function declared in <code>&lt;new&gt;</code>:</p>
<p class="codelink"><a id="procode325"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode325">Click here to view code image</a></p>
<p class="programlisting"><br>namespace std {<br><br>&nbsp;&nbsp;typedef void (*new_handler)();<br>&nbsp;&nbsp;new_handler <span class="courierb">set_new_handler</span>(new_handler p) throw();<br>}<br></p>
<p class="noindent">As you can see, <code>new_handler</code> is a typedef for a pointer to a function that takes and returns nothing, and <code>set_new_handler</code> is a function that takes and returns a <code>new_handler</code>. (The “<code>throw()</code>” at the end of <code>set_new_handler</code>'s declaration is an exception specification. It essentially says that this function won't throw any exceptions, though the truth is a bit more interesting. For details, see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch05.html#ch05lev1sec4">Item 29</a>.)</p>
<p class="noindent"><code>set_new_handler</code>'s parameter is a pointer to the function <code>operator new</code> should call if it can't allocate the requested memory. The return value of <code>set_new_handler</code> is a pointer to the function in effect for that purpose before <code>set_new_handler</code> was called.</p>
<p class="noindent">You use <code>set_new_handler</code> like this:</p>
<p class="codelink"><a id="procode326"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode326">Click here to view code image</a></p>
<p class="programlisting"><br>// function to call if operator new can't allocate enough memory<br>void outOfMem()<br>{<br>&nbsp;&nbsp;std::cerr &lt;&lt; "Unable to satisfy request for memory\n";<br>&nbsp;&nbsp;std::abort();<br>}<br><br><a id="page_241"></a>int main()<br>{<br>&nbsp;&nbsp;std::<span class="courierb">set_new_handler</span>(outOfMem);<br>&nbsp;&nbsp;int *pBigDataArray = new int[100000000L];<br>&nbsp;&nbsp;...<br>}<br></p>
<p class="noindent">If <code>operator new</code> is unable to allocate space for 100,000,000 integers, <code>outOfMem</code> will be called, and the program will abort after issuing an error message. (By the way, consider what happens if memory must be dynamically allocated during the course of writing the error message to <code>cerr</code>....)</p>
<p class="noindent">When <code>operator new</code> is unable to fulfill a memory request, it calls the new-handler function repeatedly until it <em>can</em> find enough memory. The code giving rise to these repeated calls is shown in <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec3">Item 51</a>, but this high-level description is enough to conclude that a well-designed new-handler function must do one of the following:</p>
<p class="indenthanding">• <strong>Make more memory available.</strong> This may allow the next memory allocation attempt inside <code>operator new</code> to succeed. One way to implement this strategy is to allocate a large block of memory at program start-up, then release it for use in the program the first time the new-handler is invoked.</p>
<p class="indenthanding">• <strong>Install a different new-handler.</strong> If the current new-handler can't make any more memory available, perhaps it knows of a different new-handler that can. If so, the current new-handler can install the other new-handler in its place (by calling <code>set_new_handler</code>). The next time <code>operator new</code> calls the new-handler function, it will get the one most recently installed. (A variation on this theme is for a new-handler to modify its <em>own</em> behavior, so the next time it's invoked, it does something different. One way to achieve this is to have the new-handler modify static, namespace-specific, or global data that affects the new-handler's behavior.)</p>
<p class="indenthanding">• <strong>Deinstall the new-handler</strong>, i.e., pass the null pointer to <code>set_new_handler</code>. With no new-handler installed, <code>operator new</code> will throw an exception when memory allocation is unsuccessful.</p>
<p class="indenthanding">• <strong>Throw an exception</strong> of type <code>bad_alloc</code> or some type derived from <code>bad_alloc</code>. Such exceptions will not be caught by <code>operator new</code>, so they will propagate to the site originating the request for memory.</p>
<p class="indenthanding">• <strong>Not return</strong>, typically by calling <code>abort</code> or <code>exit</code>.</p>
<p class="noindent">These choices give you considerable flexibility in implementing new-handler functions.</p>
<p class="noindent"><a id="page_242"></a>Sometimes you'd like to handle memory allocation failures in different ways, depending on the class of the object being allocated:</p>
<p class="codelink"><a id="procode327"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode327">Click here to view code image</a></p>
<p class="programlisting"><br>class X {<br>public:<br>&nbsp;&nbsp;static void outOfMemory();<br>&nbsp;&nbsp;...<br>};<br>class Y {<br>public:<br>&nbsp;&nbsp;static void outOfMemory();<br>&nbsp;&nbsp;...<br>};<br>X* p1 = new X;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if allocation is unsuccessful,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// call X::outOfMemory<br><br>Y* p2 = new Y;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if allocation is unsuccessful,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// call Y::outOfMemory<br></p>
<p class="noindent">C++ has no support for class-specific new-handlers, but it doesn't need any. You can implement this behavior yourself. You just have each class provide its own versions of <code>set_new_handler</code> and <code>operator new</code>. The class's <code>set_new_handler</code> allows clients to specify the new-handler for the class (exactly like the standard <code>set_new_handler</code> allows clients to specify the global new-handler). The class's <code>operator new</code> ensures that the class-specific new-handler is used in place of the global new-handler when memory for class objects is allocated.</p>
<p class="noindent">Suppose you want to handle memory allocation failures for the <code>Widget</code> class. You'll have to keep track of the function to call when <code>operator new</code> can't allocate enough memory for a <code>Widget</code> object, so you'll declare a static member of type <code>new_handler</code> to point to the new-handler function for the class. <code>Widget</code> will look something like this:</p>
<p class="codelink"><a id="procode328"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode328">Click here to view code image</a></p>
<p class="programlisting"><br>class Widget {<br>public:<br>&nbsp;&nbsp;static std::new_handler set_new_handler(std::new_handler p) throw();<br>&nbsp;&nbsp;static void * operator new(std::size_t size) throw(std::bad_alloc);<br>private:<br>&nbsp;&nbsp;<span class="courierb">static std::new_handler currentHandler;</span><br>};<br></p>
<p class="noindent">Static class members must be defined outside the class definition (unless they're <code>const</code> and integral—see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch01.html#ch01lev1sec2">Item 2</a>), so:</p>
<p class="codelink"><a id="procode329"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode329">Click here to view code image</a></p>
<p class="programlisting"><br>std::new_handler Widget::currentHandler = 0;&nbsp;&nbsp;&nbsp;&nbsp;// init to null in the class<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// impl. file<br></p>
<p class="noindent"><a id="page_243"></a>The <code>set_new_handler</code> function in <code>Widget</code> will save whatever pointer is passed to it, and it will return whatever pointer had been saved prior to the call. This is what the standard version of <code>set_new_handler</code> does:</p>
<p class="codelink"><a id="procode330"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode330">Click here to view code image</a></p>
<p class="programlisting"><br>std::new_handler Widget::set_new_handler(std::new_handler p) throw()<br>{<br>&nbsp;&nbsp;std::new_handler oldHandler = currentHandler;<br>&nbsp;&nbsp;currentHandler = p;<br>&nbsp;&nbsp;return oldHandler;<br>}<br></p>
<p class="noindent">Finally, <code>Widget</code>'s <code>operator new</code> will do the following:</p><ol>
<li>Call the standard <code>set_new_handler</code> with <code>Widget</code>'s error-handling function. This installs <code>Widget</code>'s new-handler as the global new-handler.</li>
<li>Call the global <code>operator new</code> to perform the actual memory allocation. If allocation fails, the global <code>operator new</code> invokes <code>Widget</code>'s new-handler, because that function was just installed as the global new-handler. If the global <code>operator new</code> is ultimately unable to allocate the memory, it throws a <code>bad_alloc</code> exception. In that case, <code>Widget</code>'s <code>operator new</code> must restore the original global new-handler, then propagate the exception. To ensure that the original new-handler is always reinstated, <code>Widget</code> treats the global new-handler as a resource and follows the advice of <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch03.html#ch03lev1sec1">Item 13</a> to use resource-managing objects to prevent resource leaks.</li>
<li>If the global <code>operator new</code> was able to allocate enough memory for a <code>Widget</code> object, <code>Widget</code>'s <code>operator new</code> returns a pointer to the allocated memory. The destructor for the object managing the global new-handler automatically restores the global new-handler to what it was prior to the call to <code>Widget</code>'s <code>operator new</code>.</li>
</ol>
<p class="noindent">Here's how you say all that in C++. We'll begin with the resource-handling class, which consists of nothing more than the fundamental RAII operations of acquiring a resource during construction and releasing it during destruction (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch03.html#ch03lev1sec1">Item 13</a>):</p>
<p class="codelink"><a id="procode331"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode331">Click here to view code image</a></p>
<p class="programlisting"><br>class NewHandlerHolder {<br>public:<br>&nbsp;&nbsp;explicit NewHandlerHolder(std::new_handler nh)&nbsp;&nbsp;&nbsp;&nbsp;// acquire current<br>&nbsp;&nbsp;:handler(nh) {}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// new-handler<br><br>&nbsp;&nbsp;~NewHandlerHolder()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// release it<br>&nbsp;&nbsp;{ std::set_new_handler(handler); }<br>private:<br>&nbsp;&nbsp;std::new_handler handler;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// remember it<br><br>&nbsp;&nbsp;NewHandlerHolder(const NewHandlerHolder&amp;);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// prevent copying<br>&nbsp;&nbsp;NewHandlerHolder&amp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (see Item 14)<br>&nbsp;&nbsp;&nbsp;operator=(const NewHandlerHolder&amp;);<br>};<br></p>
<p class="noindent"><a id="page_244"></a>This makes implementation of <code>Widget</code>'s <code>operator new</code> quite simple:</p>
<p class="codelink"><a id="procode332"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode332">Click here to view code image</a></p>
<p class="programlisting"><br>void * Widget::operator new(std::size_t size) throw(std::bad_alloc)<br>{<br>&nbsp;&nbsp;NewHandlerHolder&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// install Widget's<br>&nbsp;&nbsp;&nbsp;h(std::set_new_handler(currentHandler));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// new-handler<br><br>&nbsp;&nbsp;return ::operator new(size);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// allocate memory<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// or throw<br><br>}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// restore global<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// new-handler<br></p>
<p class="noindent">Clients of <code>Widget</code> use its new-handling capabilities like this:</p>
<p class="codelink"><a id="procode333"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode333">Click here to view code image</a></p>
<p class="programlisting"><br>void outOfMem();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// decl. of func. to call if mem. alloc.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// for Widget objects fails<br><br>Widget::set_new_handler(outOfMem); // set outOfMem as Widget's<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// new-handling function<br><br>Widget *pw1 = new Widget;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if memory allocation<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fails, call outOfMem<br><br>std::string *ps = new std::string; // if memory allocation fails,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// call the global new-handling<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// function (if there is one)<br><br>Widget::set_new_handler(0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// set the Widget-specific<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// new-handling function to<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// nothing (i.e., null)<br><br>Widget *pw2 = new Widget;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if mem. alloc. fails, throw an<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// exception immediately. (There is<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// no new- handling function for<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// class Widget.)<br></p>
<p class="noindent">The code for implementing this scheme is the same regardless of the class, so a reasonable goal would be to reuse it in other places. An easy way to make that possible is to create a “mixin-style” base class, i.e., a base class that's designed to allow derived classes to inherit a single specific capability — in this case, the ability to set a class-specific new-handler. Then turn the base class into a template, so that you get a different copy of the class data for each inheriting class.</p>
<p class="noindent">The base class part of this design lets derived classes inherit the <code>set_new_handler</code> and <code>operator new</code> functions they all need, while the template part of the design ensures that each inheriting class gets a different <code>currentHandler</code> data member. That may sound a bit complicated, but the code looks reassuringly familiar. In fact, the only real difference is that it's now available to any class that wants it:</p>
<p class="codelink"><a id="procode334"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode334">Click here to view code image</a></p>
<p class="programlisting"><br><br><a id="page_245"></a>template&lt;typename T&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "mixin-style" base class for<br>class NewHandlerSupport{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// class-specific set_new_handler<br>public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// support<br><br>&nbsp;&nbsp;static std::new_handler set_new_handler(std::new_handler p) throw();<br>&nbsp;&nbsp;static void * operator new(std::size_t size) throw(std::bad_alloc);<br><br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// other versions of op. new —<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// see Item 52<br>private:<br>&nbsp;&nbsp;static std::new_handler currentHandler;<br>};<br><br>template&lt;typename T&gt;<br>std::new_handler<br>NewHandlerSupport&lt;T&gt;::set_new_handler(std::new_handler p) throw()<br>{<br>std::new_handler oldHandler = currentHandler;<br>currentHandler = p;<br>return oldHandler;<br>}<br><br>template&lt;typename T&gt;<br>void* NewHandlerSupport&lt;T&gt;::operator new(std::size_t size)<br>&nbsp;&nbsp;throw(std::bad_alloc)<br>{<br>&nbsp;&nbsp;NewHandlerHolder h(std::set_new_handler(currentHandler));<br>&nbsp;&nbsp;return ::operator new(size);<br>}<br>// this initializes each currentHandler to null<br>template&lt;typename T&gt;<br>std::new_handler NewHandlerSupport&lt;T&gt;::currentHandler = 0;<br></p>
<p class="noindent">With this class template, adding <code>set_new_handler</code> support to <code>Widget</code> is easy: <code>Widget</code> just inherits from <code>NewHandlerSupport&lt;Widget&gt;</code>. (That may look peculiar, but I'll explain in more detail below exactly what's going on.)</p>
<p class="codelink"><a id="procode335"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode335">Click here to view code image</a></p>
<p class="programlisting"><br>class Widget<span class="courierb">: public NewHandlerSupport&lt;Widget&gt;</span> {<br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// as before, but without declarations for<br>};&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// set_new_handler or operator new<br></p>
<p class="noindent">That's all <code>Widget</code> needs to do to offer a class-specific <code>set_new_handler</code>.</p>
<p class="noindent">But maybe you're still fretting over <code>Widget</code> inheriting from <code>NewHandlerSupport&lt;Widget&gt;</code>. If so, your fretting may intensify when you note that the <code>NewHandlerSupport</code> template never uses its type parameter <code>T</code>. It doesn't need to. All we need is a different copy of <code>NewHandlerSupport</code> — in particular, its static data member <code>currentHandler</code> — for each class that inherits from <code>NewHandlerSupport</code>. The template parameter <code>T</code> just distinguishes one inheriting class from another. The template mechanism <a id="page_246"></a>itself automatically generates a copy of <code>currentHandler</code> for each <code>T</code> with which <code>NewHandlerSupport</code> is instantiated.</p>
<p class="noindent">As for <code>Widget</code> inheriting from a templatized base class that takes <code>Widget</code> as a type parameter, don't feel bad if the notion makes you a little woozy. It initially has that effect on everybody. However, it turns out to be such a useful technique, it has a name, albeit one that reflects the fact that it looks natural to no one the first time they see it. It's called the <em>curiously recurring template pattern</em> (CRTP). Honest.</p>
<p class="noindent">At one point, I published an article suggesting that a better name would be “Do It For Me,” because when <code>Widget</code> inherits from <code>NewHandlerSupport&lt;Widget&gt;</code>, it's really saying, “I'm <code>Widget</code>, and I want to inherit from the <code>NewHandlerSupport</code> class for <code>Widget</code>.” Nobody uses my proposed name (not even me), but thinking about CRTP as a way of saying “do it for me” may help you understand what the templatized inheritance is doing.</p>
<p class="noindent">Templates like <code>NewHandlerSupport</code> make it easy to add a class-specific new-handler to any class that wants one. Mixin-style inheritance, however, invariably leads to the topic of multiple inheritance, and before starting down that path, you'll want to read <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec9">Item 40</a>.</p>
<p class="noindent">Until 1993, C++ required that <code>operator new</code> return null when it was unable to allocate the requested memory. <code>operator new</code> is now specified to throw a <code>bad_alloc</code> exception, but a lot of C++ was written before compilers began supporting the revised specification. The C++ standardization committee didn't want to abandon the test-for-null code base, so they provided alternative forms of <code>operator new</code> that offer the traditional failure-yields-null behavior. These forms are called “nothrow” forms, in part because they employ <code>nothrow</code> objects (defined in the header <code>&lt;new&gt;</code>) at the point where <code>new</code> is used:</p>
<p class="codelink"><a id="procode336"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode336">Click here to view code image</a></p>
<p class="programlisting"><br>class Widget { ... };<br>Widget *pw1 = new Widget;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// throws bad_alloc if<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// allocation fails<br><br>if (pw1 == 0) ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this test <span class="courieri">must</span> fail<br><br>Widget *pw2 =new <span class="courierb">(std::nothrow)</span> Widget;&nbsp;&nbsp;&nbsp;// returns 0 if allocation for<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the Widget fails<br><br>if (pw2 == 0) ...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this test may succeed<br></p>
<p class="noindent">Nothrow <code>new</code> offers a less compelling guarantee about exceptions than is initially apparent. In the expression “<code>new (std::nothrow) Widget</code>,” two things happen. First, the nothrow version of <code>operator new</code> is called to allocate enough memory for a <code>Widget</code> object. If that allocation fails, <a id="page_247"></a><code>operator new</code> returns the null pointer, just as advertised. If it succeeds, however, the <code>Widget</code> constructor is called, and at that point, all bets are off. The <code>Widget</code> constructor can do whatever it likes. It might itself <code>new</code> up some memory, and if it does, it's not constrained to use nothrow <code>new</code>. Although the <code>operator new</code> call in “<code>new (std::nothrow) Widget</code>” won't throw, then, the <code>Widget</code> constructor might. If it does, the exception will be propagated as usual. Conclusion? Using nothrow <code>new</code> guarantees only that <code>operator new</code> won't throw, not that an expression like “<code>new (std::nothrow) Widget</code>” will never yield an exception. In all likelihood, you will never have a need for nothrow <code>new</code>.</p>
<p class="noindent">Regardless of whether you use “normal” (i.e., exception-throwing) <code>new</code> or its somewhat stunted nothrow cousin, it's important that you understand the behavior of the new-handler, because it's used with both forms.</p>
<div class="note">
<h3 id="ch08note01">Things to Remember</h3>
<p class="indenthanding">• <code>set_new_handler</code> allows you to specify a function to be called when memory allocation requests cannot be satisfied.</p>
<p class="indenthanding">• Nothrow <code>new</code> is of limited utility, because it applies only to memory allocation; subsequent constructor calls may still throw exceptions.</p>
</div>
<h3 id="ch08lev1sec2">Item 50: Understand when it makes sense to replace <code>new</code> and <code>delete</code></h3>
<p class="noindent">Let's return to fundamentals for a moment. Why would anybody want to replace the compiler-provided versions of <code>operator new</code> or <code>operator delete</code> in the first place? These are three of the most common reasons:</p>
<p class="indenthanding">• <strong>To detect usage errors.</strong> Failure to <code>delete</code> memory conjured up by <code>new</code> leads to memory leaks. Using more than one <code>delete</code> on <code>new</code>ed memory yields undefined behavior. If <code>operator new</code> keeps a list of allocated addresses and <code>operator delete</code> removes addresses from the list, it's easy to detect such usage errors. Similarly, a variety of programming mistakes can lead to data overruns (writing beyond the end of an allocated block) and underruns (writing prior to the beginning of an allocated block). Custom <code>operator new</code>s can overallocate blocks so there's room to put known byte patterns (“signatures”) before and after the memory made available to clients. <code>operator delete</code>s can check to see if the signatures are still intact. If they're not, an overrun or underrun occurred sometime during the life of the allocated block, and <code>operator delete</code> can log that fact, along with the value of the offending pointer.</p>
<p class="indenthanding">• <a id="page_248"></a><strong>To improve efficiency.</strong> The versions of <code>operator new</code> and <code>operator delete</code> that ship with compilers are designed for general-purpose use. They have to be acceptable for long-running programs (e.g., web servers), but they also have to be acceptable for programs that execute for less than a second. They have to handle series of requests for large blocks of memory, small blocks, and mixtures of the two. They have to accommodate allocation patterns ranging from the dynamic allocation of a few blocks that exist for the duration of the program to constant allocation and deallocation of a large number of short-lived objects. They have to worry about heap fragmentation, a process that, if unchecked, eventually leads to the inability to satisfy requests for large blocks of memory, even when ample free memory is distributed across many small blocks.</p>
<p class="paraindent">Given the demands made on memory managers, it's no surprise that the <code>operator new</code>s and <code>operator delete</code>s that ship with compilers take a middle-of-the-road strategy. They work reasonably well for everybody, but optimally for nobody. If you have a good understanding of your program's dynamic memory usage patterns, you can often find that custom versions of <code>operator new</code> and <code>operator delete</code> outperform the default ones. By “outperform,” I mean they run faster — sometimes orders of magnitude faster — and they require less memory — up to 50% less. For some (though by no means all) applications, replacing the stock <code>new</code> and <code>delete</code> with custom versions is an easy way to pick up significant performance improvements.</p>
<p class="indenthanding">• <strong>To collect usage statistics.</strong> Before heading down the path of writing custom <code>new</code>s and <code>delete</code>s, it's prudent to gather information about how your software uses its dynamic memory. What is the distribution of allocated block sizes? What is the distribution of their lifetimes? Do they tend to be allocated and deallocated in FIFO (“first in, first out”) order, LIFO (“last in, first out”) order, or something closer to random order? Do the usage patterns change over time, e.g., does your software have different allocation/deallocation patterns in different stages of execution? What is the maximum amount of dynamically allocated memory in use at any one time (i.e., its “high water mark”)? Custom versions of <code>operator new</code> and <code>operator delete</code> make it easy to collect this kind of information.</p>
<p class="noindent">In concept, writing a custom <code>operator new</code> is pretty easy. For example, here's a quick first pass at a global <code>operator new</code> that facilitates the detection of under- and overruns. There are a lot of little things wrong with it, but we'll worry about those in a moment.</p>
<p class="codelink"><a id="procode337"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode337">Click here to view code image</a></p>
<p class="programlisting"><br>static const int signature = 0xDEADBEEF;<br><br><a id="page_249"></a>typedef unsigned char Byte;<br><br>// this code has several flaws—see below<br>void* operator new(std::size_t size) throw(std::bad_alloc)<br>{<br>&nbsp;&nbsp;using namespace std;<br><br>&nbsp;&nbsp;size_t realSize = size + 2 * sizeof(int);&nbsp;&nbsp;&nbsp;&nbsp;// increase size of request so2<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// signatures will also fit inside<br><br>&nbsp;&nbsp;void *pMem = malloc(realSize);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// call malloc to get theactual<br>&nbsp;&nbsp;if (!pMem) throw bad_alloc();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// memory<br><br>&nbsp;&nbsp;// write signature into first and last parts of the memory<br>&nbsp;&nbsp;*(static_cast&lt;int*&gt;(pMem)) = signature;<br>&nbsp;&nbsp;*(reinterpret_cast&lt;int*&gt;(static_cast&lt;Byte*&gt;(pMem)+realSize-sizeof(int))) =<br>&nbsp;&nbsp;signature;<br><br>&nbsp;&nbsp;// return a pointer to the memory just past the first signature<br>&nbsp;&nbsp;return static_cast&lt;Byte*&gt;(pMem) + sizeof(int);<br>}<br></p>
<p class="noindent">Most of the shortcomings of this <code>operator new</code> have to do with its failure to adhere to the C++ conventions for functions of that name. For example, <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec3">Item 51</a> explains that all <code>operator new</code>s should contain a loop calling a new-handling function, but this one doesn't. However, <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec3">Item 51</a> is devoted to such conventions, so I'll ignore them here. I want to focus on a more subtle issue now: <em>alignment</em>.</p>
<p class="noindent">Many computer architectures require that data of particular types be placed in memory at particular kinds of addresses. For example, an architecture might require that pointers occur at addresses that are a multiple of four (i.e., be <em>four-byte aligned</em>) or that <code>double</code>s must occur at addresses that are a multiple of eight (i.e., be <em>eight-byte aligned</em>). Failure to follow such constraints could lead to hardware exceptions at runtime. Other architectures are more forgiving, though they may offer better performance if alignment preferences are satisfied. For example, <code>double</code>s may be aligned on any byte boundary on the Intel x86 architecture, but access to them is a lot faster if they are eight-byte aligned.</p>
<p class="noindent">Alignment is relevant here, because C++ requires that all <code>operator new</code>s return pointers that are suitably aligned for <em>any</em> data type. <code>malloc</code> labors under the same requirement, so having <code>operator new</code> return a pointer it gets from <code>malloc</code> is safe. However, in <code>operator new</code> above, we're not returning a pointer we got from <code>malloc</code>, we're returning a pointer we got from <code>malloc</code> <em>offset by the size of an <code>int</code></em>. There is no guarantee that this is safe! If the client called <code>operator new</code> to get enough memory for a <code>double</code> (or, if we were writing <code>operator new[]</code>, an array of <code>double</code>s) and we were running on a machine where <code>int</code>s were four bytes in size but <code>double</code>s were required to be eight-byte aligned, we'd probably return a <a id="page_250"></a>pointer with improper alignment. That might cause the program to crash. Or it might just cause it to run more slowly. Either way, it's probably not what we had in mind.</p>
<p class="noindent">Details like alignment are the kinds of things that distinguish professional-quality memory managers from ones thrown together by programmers distracted by the need to get on to other tasks. Writing a custom memory manager that almost works is pretty easy. Writing one that works <em>well</em> is a lot harder. As a general rule, I suggest you not attempt it unless you have to.</p>
<p class="noindent">In many cases, you don't have to. Some compilers have switches that enable debugging and logging functionality in their memory management functions. A quick glance through your compilers' documentation may eliminate your need to consider writing <code>new</code> and <code>delete</code>. On many platforms, commercial products can replace the memory management functions that ship with compilers. To avail yourself of their enhanced functionality and (presumably) improved performance, all you need do is relink. (Well, you also have to buy them.)</p>
<p class="noindent">Another option is open source memory managers. They're available for many platforms, so you can download and try those. One such open source allocator is the Pool library from Boost (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch09.html#ch09lev1sec3">Item 55</a>). The Pool library offers allocators tuned for one of the most common situations in which custom memory management is helpful: allocation of a large number of small objects. Many C++ books, including earlier editions of this one, show the code for a high-performance small-object allocator, but they usually omit such pesky details as portability and alignment considerations, thread safety, etc. Real libraries tend to have code that's a lot more robust. Even if you decide to write your own <code>new</code>s and <code>delete</code>s, looking at open source versions is likely to give you insights into the easy-to-overlook details that separate almost working from really working. (Given that alignment is one such detail, it's worth noting that TR1 (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch09.html#ch09lev1sec2">Item 54</a>) includes support for discovering type-specific alignment requirements.)</p>
<p class="noindent">The topic of this Item is knowing when it can make sense to replace the default versions of <code>new</code> and <code>delete</code>, either globally or on a per-class basis. We're now in a position to summarize when in more detail than we did before.</p>
<p class="indenthanding">• <strong>To detect usage errors</strong> (as above).</p>
<p class="indenthanding">• <strong>To collect statistics about the use of dynamically allocated memory</strong> (also as above).</p>
<p class="indenthanding">• <a id="page_251"></a><strong>To increase the speed of allocation and deallocation.</strong> General-purpose allocators are often (though not always) a lot slower than custom versions, especially if the custom versions are designed for objects of a particular type. Class-specific allocators are an example application of fixed-size allocators such as those offered by Boost's Pool library. If your application is single-threaded, but your compilers' default memory management routines are thread-safe, you may be able to win measurable speed improvements by writing thread-unsafe allocators. Of course, before jumping to the conclusion that <code>operator new</code> and <code>operator delete</code> are worth speeding up, be sure to profile your program to confirm that these functions are truly a bottleneck.</p>
<p class="indenthanding">• <strong>To reduce the space overhead of default memory management.</strong> General-purpose memory managers are often (though not always) not just slower than custom versions, they often use more memory, too. That's because they often incur some overhead for each allocated block. Allocators tuned for small objects (such as those in Boost's Pool library) essentially eliminate such overhead.</p>
<p class="indenthanding">• <strong>To compensate for suboptimal alignment in the default allocator.</strong> As I mentioned earlier, it's fastest to access <code>double</code>s on the x86 architecture when they are eight-byte aligned. Alas, the <code>operator new</code>s that ship with some compilers don't guarantee eight-byte alignment for dynamic allocations of <code>double</code>s. In such cases, replacing the default <code>operator new</code> with one that guarantees eight-byte alignment could yield big increases in program performance.</p>
<p class="indenthanding">• <strong>To cluster related objects near one another.</strong> If you know that particular data structures are generally used together and you'd like to minimize the frequency of page faults when working on the data, it can make sense to create a separate heap for the data structures so they are clustered together on as few pages as possible. Placement versions of <code>new</code> and <code>delete</code> (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec4">Item 52</a>) can make it possible to achieve such clustering.</p>
<p class="indenthanding">• <strong>To obtain unconventional behavior.</strong> Sometimes you want <code>operator</code>s <code>new</code> and <code>delete</code> to do something that the compiler-provided versions don't offer. For example, you might want to allocate and deallocate blocks in shared memory, but have only a C API through which to manage that memory. Writing custom versions of <code>new</code> and <code>delete</code> (probably placement versions — again, see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec4">Item 52</a>) would allow you to drape the C API in C++ clothing. As another example, you might write a custom <code>operator delete</code> that overwrites deallocated memory with zeros in order to increase the security of application data.</p>
<p class="noindent"><a id="page_252"></a></p>
<div class="note">
<h3 id="ch08note02">Things to Remember</h3>
<p class="indenthanding">• There are many valid reasons for writing custom versions of <code>new</code> and <code>delete</code>, including improving performance, debugging heap usage errors, and collecting heap usage information.</p>
</div>
<h3 id="ch08lev1sec3">Item 51: Adhere to convention when writing <code>new</code> and <code>delete</code></h3>
<p class="noindent"><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec2">Item 50</a> explains when you might want to write your own versions of <code>operator new</code> and <code>operator delete</code>, but it doesn't explain the conventions you must follow when you do it. The rules aren't hard to follow, but some of them are unintuitive, so it's important to know what they are.</p>
<p class="noindent">We'll begin with <code>operator new</code>. Implementing a conformant <code>operator new</code> requires having the right return value, calling the new-handling function when insufficient memory is available (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec1">Item 49</a>), and being prepared to cope with requests for no memory. You'll also want to avoid inadvertently hiding the “normal” form of <code>new</code>, though that's more a class interface issue than an implementation requirement; it's addressed in <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec4">Item 52</a>.</p>
<p class="noindent">The return value part of <code>operator new</code> is easy. If you can supply the requested memory, you return a pointer to it. If you can't, you follow the rule described in <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec1">Item 49</a> and throw an exception of type <code>bad_alloc</code>.</p>
<p class="noindent">It's not quite that simple, however, because <code>operator new</code> actually tries to allocate memory more than once, calling the new-handling function after each failure. The assumption here is that the new-handling function might be able to do something to free up some memory. Only when the pointer to the new-handling function is null does <code>operator new</code> throw an exception.</p>
<p class="noindent">Curiously, C++ requires that <code>operator new</code> return a legitimate pointer even when zero bytes are requested. (Requiring this odd-sounding behavior simplifies things elsewhere in the language.) That being the case, pseudocode for a non-member <code>operator new</code> looks like this:</p>
<p class="codelink"><a id="procode338"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode338">Click here to view code image</a></p>
<p class="programlisting"><br>void * operator new(std::size_t size) throw(std::bad_alloc)<br>{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// your operator new might<br>&nbsp;&nbsp;using namespace std;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// take additional params<br><br>&nbsp;&nbsp;if (size == 0) {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// handle 0-byte requests<br>&nbsp;&nbsp;&nbsp;&nbsp;size = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// by treating them as<br>&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1-byte requests<br><br>&nbsp;&nbsp;while (true) {<br>&nbsp;&nbsp;&nbsp;<span class="courieri">attempt to allocate size bytes;</span><br><br><a id="page_253"></a>&nbsp;&nbsp;&nbsp;&nbsp;if (<span class="courieri">the allocation was successful</span>)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (<span class="courieri">a pointer to the memory</span>);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// allocation was unsuccessful; find out what the<br>&nbsp;&nbsp;&nbsp;&nbsp;// current new-handling function is (see below)<br>&nbsp;&nbsp;&nbsp;&nbsp;new_handler globalHandler = set_new_handler(0);<br>&nbsp;&nbsp;&nbsp;&nbsp;set_new_handler(globalHandler);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (globalHandler) (*globalHandler)();<br>&nbsp;&nbsp;&nbsp;&nbsp;else throw std::bad_alloc();<br>&nbsp;&nbsp;}<br>}<br></p>
<p class="noindent">The trick of treating requests for zero bytes as if they were really requests for one byte looks slimy, but it's simple, it's legal, it works, and how often do you expect to be asked for zero bytes, anyway?</p>
<p class="noindent">You may also look askance at the place in the pseudocode where the new-handling function pointer is set to null, then promptly reset to what it was originally. Unfortunately, there is no way to get at the new-handling function pointer directly, so you have to call <code>set_new_handler</code> to find out what it is. Crude, yes, but also effective, at least for single-threaded code. In a multithreaded environment, you'll probably need some kind of lock to safely manipulate the (global) data structures behind the new-handling function.</p>
<p class="noindent"><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec1">Item 49</a> remarks that <code>operator new</code> contains an infinite loop, and the code above shows that loop explicitly; “<code>while (true)</code>” is about as infinite as it gets. The only way out of the loop is for memory to be successfully allocated or for the new-handling function to do one of the things described in <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec1">Item 49</a>: make more memory available, install a different new-handler, deinstall the new-handler, throw an exception of or derived from <code>bad_alloc</code>, or fail to return. It should now be clear why the new-handler must do one of those things. If it doesn't, the loop inside <code>operator new</code> will never terminate.</p>
<p class="noindent">Many people don't realize that <code>operator new</code> member functions are inherited by derived classes. That can lead to some interesting complications. In the pseudocode for <code>operator new</code> above, notice that the function tries to allocate <code>size</code> bytes (unless <code>size</code> is zero). That makes perfect sense, because that's the argument that was passed to the function. However, as <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#ch08lev1sec2">Item 50</a> explains, one of the most common reasons for writing a custom memory manager is to optimize allocation for objects of a <em>specific</em> class, not for a class or any of its derived classes. That is, given an <code>operator new</code> for a class <code>X</code>, the behavior of that function is typically tuned for objects of size <code>sizeof(X)</code>—nothing larger and nothing smaller. Because of inheritance, however, it is possible <a id="page_254"></a>that the <code>operator new</code> in a base class will be called to allocate memory for an object of a derived class:</p>
<p class="codelink"><a id="procode339"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode339">Click here to view code image</a></p>
<p class="programlisting"><br>class Base {<br>public:<br>&nbsp;&nbsp;<span class="courierb">static void * operator new(std::size_t size) throw(std::bad_alloc);</span><br>&nbsp;&nbsp;...<br>};<br><br>class Derived: public Base&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Derived doesn't declare<br>{ ... };&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// operator new<br><br>Derived *p = <span class="courierb">new Derived</span>;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// calls Base::operator new!<br></p>
<p class="noindent">If <code>Base</code>'s class-specific <code>operator new</code> wasn't designed to cope with this — and chances are that it wasn't — the best way for it to handle the situation is to slough off calls requesting the “wrong” amount of memory to the standard <code>operator new</code>, like this:</p>
<p class="codelink"><a id="procode340"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode340">Click here to view code image</a></p>
<p class="programlisting"><br>void * Base::operator new(std::size_t size) throw(std::bad_alloc)<br>{<br>&nbsp;&nbsp;<span class="courierb">if (size != sizeof(Base))</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if size is "wrong,"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="courierb">return ::operator new(size);</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// have standard operator<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// new handle the request<br><br>&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// otherwise handle<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the request here<br>}<br></p>
<p class="noindent">“Hold on!” I hear you cry, “You forgot to check for the pathological-but-nevertheless-possible case where <code>size</code> is zero!” Actually, I didn't, and please stop using hyphens when you cry out. The test is still there, it's just been incorporated into the test of <code>size</code> against <code>sizeof(Base)</code>. C++ works in some mysterious ways, and one of those ways is to decree that all freestanding objects have non-zero size (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec8">Item 39</a>). By definition, <code>sizeof(Base)</code> can never be zero, so if <code>size</code> is zero, the request will be forwarded to <code>::operator new</code>, and it will become that function's responsibility to treat the request in a reasonable fashion.</p>
<p class="noindent">If you'd like to control memory allocation for arrays on a per-class basis, you need to implement <code>operator new</code>'s array-specific cousin, <code>operator new[]</code>. (This function is usually called “array new,” because it's hard to figure out how to pronounce “<code>operator new[]</code>”.) If you decide to write <code>operator new[]</code>, remember that all you're doing is allocating a chunk of raw memory — you can't do anything to the as-yet-nonexistent objects in the array. In fact, you can't even figure out how many objects will be in the array. First, you don't know how big each object is. After all, a base class's <code>operator new[]</code> might, through inheritance, be called to allocate memory for an array of derived class objects, and derived class objects are usually bigger than base class objects.</p>
<p class="noindent"><a id="page_255"></a>Hence, you can't assume inside <code>Base::operator new[]</code> that the size of each object going into the array is <code>sizeof(Base)</code>, and that means you can't assume that the number of objects in the array is <code>(</code><em><code>bytes requested</code></em><code>)/sizeof(Base)</code>. Second, the <code>size_t</code> parameter passed to <code>operator new[]</code> may be for more memory than will be filled with objects, because, as <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch03.html#ch03lev1sec4">Item 16</a> explains, dynamically allocated arrays may include extra space to store the number of array elements.</p>
<p class="noindent">So much for the conventions you need to follow when writing <code>operator new</code>. For <code>operator delete</code>, things are simpler. About all you need to remember is that C++ guarantees it's always safe to delete the null pointer, so you need to honor that guarantee. Here's pseudocode for a non-member <code>operator delete</code>:</p>
<p class="codelink"><a id="procode341"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode341">Click here to view code image</a></p>
<p class="programlisting"><br>void operator delete(void *rawMemory) throw()<br>{<br>&nbsp;&nbsp;if (rawMemory == 0) return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do nothing if the null<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// pointer is being deleted<br><br>&nbsp;&nbsp;<span class="courieri">deallocate the memory pointed to by rawMemory;</span><br>}<br></p>
<p class="noindent">The member version of this function is simple, too, except you've got to be sure to check the size of what's being deleted. Assuming your class-specific <code>operator new</code> forwards requests of the “wrong” size to <code>::operator new</code>, you've got to forward “wrongly sized” deletion requests to <code>::operator delete</code>:</p>
<p class="codelink"><a id="procode342"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode342">Click here to view code image</a></p>
<p class="programlisting"><br>class Base {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// same as before, but now<br>public:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// operator delete is declared<br><br>&nbsp;&nbsp;static void * operator new(std::size_t size) throw(std::bad_alloc);<br>&nbsp;&nbsp;<span class="courierb">static void operator delete(void *rawMemory, std::size_t size) throw();</span><br>&nbsp;&nbsp;...<br>};<br>void Base::operator delete(void *rawMemory, std::size_t size) throw()<br>{<br>&nbsp;&nbsp;if (rawMemory == 0) return;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// check for null pointer<br><br>&nbsp;&nbsp;<span class="courierb">if (size != sizeof(Base)) {</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if size is "wrong,"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="courierb">::operator delete(rawMemory);</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// have standard operator<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="courierb">return;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// delete handle the request<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;<span class="courieri">deallocate the memory pointed to by rawMemory;</span><br>&nbsp;&nbsp;return;<br>}<br></p>
<p class="noindent">Interestingly, the <code>size_t</code> value C++ passes to <code>operator delete</code> may be incorrect if the object being deleted was derived from a base class lacking a virtual destructor. This is reason enough for making sure <a id="page_256"></a>your base classes have virtual destructors, but <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch02.html#ch02lev1sec3">Item 7</a> describes a second, arguably better reason. For now, simply note that if you omit virtual destructors in base classes, <code>operator delete</code> functions may not work correctly.</p>
<div class="note">
<h3 id="ch08note03">Things to Remember</h3>
<p class="indenthanding">• <code>operator new</code> should contain an infinite loop trying to allocate memory, should call the new-handler if it can't satisfy a memory request, and should handle requests for zero bytes. Class-specific versions should handle requests for larger blocks than expected.</p>
<p class="indenthanding">• <code>operator delete</code> should do nothing if passed a pointer that is null. Class-specific versions should handle blocks that are larger than expected.</p>
</div>
<h3 id="ch08lev1sec4">Item 52: Write placement <code>delete</code> if you write placement <code>new</code></h3>
<p class="noindent">Placement <code>new</code> and placement <code>delete</code> aren't the most commonly encountered beasts in the C++ menagerie, so don't worry if you're not familiar with them. Instead, recall from <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch03.html#ch03lev1sec4">Items 16</a> and <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch03.html#ch03lev1sec5">17</a> that when you write a <code>new</code> expression such as this,</p>
<p class="programlisting"><br>Widget *pw = new Widget;<br></p>
<p class="noindent">two functions are called: one to <code>operator new</code> to allocate memory, a second to <code>Widget</code>'s default constructor.</p>
<p class="noindent">Suppose that the first call succeeds, but the second call results in an exception being thrown. In that case, the memory allocation performed in step 1 must be undone. Otherwise we'll have a memory leak. Client code can't deallocate the memory, because if the <code>Widget</code> constructor throws an exception, <code>pw</code> is never assigned. There'd be no way for clients to get at the pointer to the memory that should be deallocated. The responsibility for undoing step 1 must therefore fall on the C++ runtime system.</p>
<p class="noindent">The runtime system is happy to call the <code>operator delete</code> that corresponds to the version of <code>operator new</code> it called in step 1, but it can do that only if it knows which <code>operator delete</code> — there may be many — is the proper one to call. This isn't an issue if you're dealing with the versions of <code>new</code> and <code>delete</code> that have the normal signatures, because the normal <code>operator new</code>,</p>
<p class="codelink"><a id="procode343"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode343">Click here to view code image</a></p>
<p class="programlisting"><br>void* operator new(std::size_t) throw(std::bad_alloc);<br></p>
<p class="noindent">corresponds to the normal <code>operator delete:</code></p>
<p class="codelink"><a id="procode344"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode344">Click here to view code image</a></p>
<p class="programlisting"><br><br><a id="page_257"></a>void operator delete(void *rawMemory) throw();&nbsp;&nbsp;// normal signature<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// at global scope<br><br>void operator delete(void *rawMemory,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// typical normal<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::size_t size) throw(); // signature at class<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// scope<br></p>
<p class="noindent">When you're using only the normal forms of <code>new</code> and <code>delete</code>, then, the runtime system has no trouble finding the <code>delete</code> that knows how to undo what <code>new</code> did. The which-<code>delete</code>-goes-with-this-<code>new</code> issue does arise, however, when you start declaring non-normal forms of <code>operator new</code> — forms that take additional parameters.</p>
<p class="noindent">For example, suppose you write a class-specific <code>operator new</code> that requires specification of an <code>ostream</code> to which allocation information should be logged, and you also write a normal class-specific <code>operator delete</code>:</p>
<p class="codelink"><a id="procode345"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode345">Click here to view code image</a></p>
<p class="programlisting"><br>class Widget {<br>public:<br>&nbsp;&nbsp;...<br>&nbsp;&nbsp;static void* operator new(std::size_t size,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// non-normal<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::ostream&amp; logStream)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// form of new<br>&nbsp;&nbsp;&nbsp;&nbsp;throw(std::bad_alloc);<br><br>&nbsp;&nbsp;static void operator delete(void *pMemory&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// normal class-<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::size_t size) throw();&nbsp;&nbsp;&nbsp;// specific form<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// of delete<br>&nbsp;&nbsp;...<br>};<br></p>
<p class="noindent">This design is problematic, but before we see why, we need to make a brief terminological detour.</p>
<p class="noindent">When an <code>operator new</code> function takes extra parameters (other than the mandatory <code>size_t</code> argument), that function is known as a <em>placement</em> version of <code>new</code>. The <code>operator new</code> above is thus a placement version. A particularly useful placement <code>new</code> is the one that takes a pointer specifying where an object should be constructed. That <code>operator new</code> looks like this:</p>
<p class="codelink"><a id="procode346"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode346">Click here to view code image</a></p>
<p class="programlisting"><br>void* operator new(std::size_t, <span class="courierb">void *pMemory</span>) throw();&nbsp;&nbsp;&nbsp;// "placement<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// new"<br></p>
<p class="noindent">This version of <code>new</code> is part of C++'s standard library, and you have access to it whenever you <code>#include &lt;new&gt;</code>. Among other things, this <code>new</code> is used inside <code>vector</code> to create objects in the vector's unused capacity. It's also the <em>original</em> placement <code>new</code>. In fact, that's how this function is known: as <em>placement <code>new</code></em>. Which means that the term “placement <code>new</code>” is overloaded. Most of the time when people talk <a id="page_258"></a>about placement <code>new</code>, they're talking about this specific function, the <code>operator new</code> taking a single extra argument of type <code>void*</code>. Less commonly, they're talking about any version of <code>operator new</code> that takes extra arguments. Context generally clears up any ambiguity, but it's important to understand that the general term “placement <code>new</code>” means any version of <code>new</code> taking extra arguments, because the phrase “placement <code>delete</code>” (which we'll encounter in a moment) derives directly from it.</p>
<p class="noindent">But let's get back to the declaration of the <code>Widget</code> class, the one whose design I said was problematic. The difficulty is that this class will give rise to subtle memory leaks. Consider this client code, which logs allocation information to <code>cerr</code> when dynamically creating a <code>Widget</code>:</p>
<p class="codelink"><a id="procode347"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode347">Click here to view code image</a></p>
<p class="programlisting"><br>Widget *pw = new (std::cerr) Widget; // call operator new, passing cerr as<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the ostream; <span class="courieri">this leaks memory</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// <span class="courieri">if the Widget constructor throws</span><br></p>
<p class="noindent">Once again, if memory allocation succeeds and the <code>Widget</code> constructor throws an exception, the runtime system is responsible for undoing the allocation that <code>operator new</code> performed. However, the runtime system can't really understand how the called version of <code>operator new</code> works, so it can't undo the allocation itself. Instead, the runtime system looks for a version of <code>operator delete</code> that takes <em>the same number and types of extra arguments</em> as <code>operator new</code>, and, if it finds it, that's the one it calls. In this case, <code>operator new</code> takes an extra argument of type <code>ostream&amp;</code>, so the corresponding <code>operator delete</code> would have this signature:</p>
<p class="codelink"><a id="procode348"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode348">Click here to view code image</a></p>
<p class="programlisting"><br>void operator delete(void *, <span class="courierb">std::ostream&amp;</span>) throw();<br></p>
<p class="noindent">By analogy with placement versions of <code>new</code>, versions of <code>operator delete</code> that take extra parameters are known as <em>placement <code>delete</code>s</em>. In this case, <code>Widget</code> declares no placement version of <code>operator delete</code>, so the runtime system doesn't know how to undo what the call to placement <code>new</code> does. As a result, it does nothing. In this example, <em>no <code>operator delete</code> is called</em> if the <code>Widget</code> constructor throws an exception!</p>
<p class="noindent">The rule is simple: if an <code>operator new</code> with extra parameters isn't matched by an <code>operator delete</code> with the same extra parameters, no <code>operator delete</code> will be called if a memory allocation by the <code>new</code> needs to be undone. To eliminate the memory leak in the code above, <code>Widget</code> needs to declare a placement <code>delete</code> that corresponds to the logging placement <code>new</code>:</p>
<p class="codelink"><a id="procode349"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode349">Click here to view code image</a></p>
<p class="programlisting"><br>class Widget {<br>public:<br>&nbsp;&nbsp;...<br><br><a id="page_259"></a>&nbsp;&nbsp;static void* operator new(std::size_t size, std::ostream&amp; logStream)<br>&nbsp;&nbsp;&nbsp;&nbsp;throw(std::bad_alloc);<br>&nbsp;&nbsp;static void operator delete(void *pMemory) throw();<br><br>&nbsp;&nbsp;<span class="courierb">static void operator delete(void *pMemory, std::ostream&amp; logStream)</span><br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="courierb">throw();</span><br>&nbsp;&nbsp;...<br>};<br></p>
<p class="noindent">With this change, if an exception is thrown from the <code>Widget</code> constructor in this statement,</p>
<p class="codelink"><a id="procode350"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode350">Click here to view code image</a></p>
<p class="programlisting"><br>Widget *pw = new (std::cerr) Widget;&nbsp;&nbsp;&nbsp;// as before, but no leak this time<br></p>
<p class="noindent">the corresponding placement <code>delete</code> is automatically invoked, and that allows <code>Widget</code> to ensure that no memory is leaked.</p>
<p class="noindent">However, consider what happens if no exception is thrown (which will usually be the case) and we get to a <code>delete</code> in client code:</p>
<p class="codelink"><a id="procode351"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode351">Click here to view code image</a></p>
<p class="programlisting"><br>delete pw;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// invokes the normal<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// operator delete<br></p>
<p class="noindent">As the comment indicates, this calls the normal <code>operator delete</code>, not the placement version. Placement <code>delete</code> is called <em>only</em> if an exception arises from a constructor call that's coupled to a call to a placement <code>new</code>. Applying <code>delete</code> to a pointer (such as <code>pw</code> above) never yields a call to a placement version of <code>delete</code>. <em>Never</em>.</p>
<p class="noindent">This means that to forestall all memory leaks associated with placement versions of <code>new</code>, you must provide both the normal <code>operator delete</code> (for when no exception is thrown during construction) and a placement version that takes the same extra arguments as <code>operator new</code> does (for when one is). Do that, and you'll never lose sleep over subtle memory leaks again. Well, at least not <em>these</em> subtle memory leaks.</p>
<p class="noindent">Incidentally, because member function names hide functions with the same names in outer scopes (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec2">Item 33</a>), you need to be careful to avoid having class-specific <code>new</code>s hide other <code>new</code>s (including the normal versions) that your clients expect. For example, if you have a base class that declares only a placement version of <code>operator new</code>, clients will find that the normal form of <code>new</code> is unavailable to them:</p>
<p class="codelink"><a id="procode352"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode352">Click here to view code image</a></p>
<p class="programlisting"><br>class Base {<br>public:<br>&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;static void* operator new(std::size_t size,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// this new hides<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::ostream&amp; logStream)&nbsp;&nbsp;&nbsp;&nbsp;// the normal<br>&nbsp;&nbsp;&nbsp;&nbsp;throw(std::bad_alloc);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// global forms<br>&nbsp;&nbsp;...<br>};<br><br><a id="page_260"></a>Base *pb = new Base;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error! the normal form of<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// operator new is hidden<br><br>Base *pb = new (std::cerr) Base;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fine, calls Base's<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// placement new<br></p>
<p class="noindent">Similarly, <code>operator new</code>s in derived classes hide both global and inherited versions of <code>operator new</code>:</p>
<p class="codelink"><a id="procode353"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode353">Click here to view code image</a></p>
<p class="programlisting"><br>class Derived: public Base {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// inherits from Base above<br>public:<br>&nbsp;&nbsp;...<br><br>&nbsp;&nbsp;static void* operator new(std::size_t size)&nbsp;&nbsp;// redeclares the normal<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw(std::bad_alloc);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// form of new<br>&nbsp;&nbsp;...<br>};<br>Derived *pd = new (std::clog) Derived;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error! Base's placement<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// new is hidden<br><br>Derived *pd = new Derived;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// fine, calls Derived's<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// operator new<br></p>
<p class="noindent"><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec2">Item 33</a> discusses this kind of name hiding in considerable detail, but for purposes of writing memory allocation functions, what you need to remember is that by default, C++ offers the following forms of <code>operator new</code> at global scope:</p>
<p class="codelink"><a id="procode354"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode354">Click here to view code image</a></p>
<p class="programlisting"><br>void* operator new(std::size_t) throw(std::bad_alloc);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// normal new<br><br>void* operator new(std::size_t, void*) throw();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// placement new<br><br>void* operator new(std::size_t,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// nothrow new —<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const std::nothrow_t&amp;) throw();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// see Item 49<br></p>
<p class="noindent">If you declare any <code>operator new</code>s in a class, you'll hide all these standard forms. Unless you mean to prevent class clients from using these forms, be sure to make them available in addition to any custom <code>operator new</code> forms you create. For each <code>operator new</code> you make available, of course, be sure to offer the corresponding <code>operator delete</code>, too. If you want these functions to behave in the usual way, just have your class-specific versions call the global versions.</p>
<p class="noindent">An easy way to do this is to create a base class containing all the normal forms of <code>new</code> and <code>delete</code>:</p>
<p class="codelink"><a id="procode355"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode355">Click here to view code image</a></p>
<p class="programlisting"><br>class StandardNewDeleteForms {<br>public:<br>&nbsp;&nbsp;<span class="courierb">// normal new/delete</span><br>&nbsp;&nbsp;static void* operator new(std::size_t size) throw(std::bad_alloc)<br>&nbsp;&nbsp;{ return ::operator new(size); }<br>&nbsp;&nbsp;static void operator delete(void *pMemory) throw()<br>&nbsp;&nbsp;{ ::operator delete(pMemory); }<br><br><br><a id="page_261"></a>&nbsp;&nbsp;<span class="courierb">// placement new/delete</span><br>&nbsp;&nbsp;static void* operator new(std::size_t size, void *ptr) throw()<br>&nbsp;&nbsp;{ return ::operator new(size, ptr); }<br>&nbsp;&nbsp;static void operator delete(void *pMemory, void *ptr) throw()<br>&nbsp;&nbsp;{ return ::operator delete(pMemory, ptr); }<br><br>&nbsp;&nbsp;<span class="courierb">// nothrow new/delete</span><br>&nbsp;&nbsp;static void* operator new(std::size_t size, const std::nothrow_t&amp; nt) throw()<br>&nbsp;&nbsp;{ return ::operator new(size, nt); }<br>&nbsp;&nbsp;static void operator delete(void *pMemory, const std::nothrow_t&amp;) throw()<br>&nbsp;&nbsp;{ ::operator delete(pMemory); }<br>};<br></p>
<p class="noindent">Clients who want to augment the standard forms with custom forms can then just use inheritance and <code>using</code> declarations (see <a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch06.html#ch06lev1sec2">Item 33</a>) to get the standard forms:</p>
<p class="codelink"><a id="procode356"></a><a class="nounder" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/images.html#iprocode356">Click here to view code image</a></p>
<p class="programlisting"><br>class Widget<span class="courierb">: public StandardNewDeleteForms</span> {&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// inherit std forms<br>public:<br>&nbsp;&nbsp;&nbsp;<span class="courierb">using StandardNewDeleteForms::operator new;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// make those<br>&nbsp;&nbsp;&nbsp;<span class="courierb">using StandardNewDeleteForms::operator delete;</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// forms visible<br><br>&nbsp;&nbsp;&nbsp;static void* operator new(std::size_t size,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// add a custom<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::ostream&amp; logStream)&nbsp;&nbsp;&nbsp;// placement new<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw(std::bad_alloc);<br><br>&nbsp;&nbsp;&nbsp;static void operator delete(void *pMemory,&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// add the corres-<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;std::ostream&amp; logStream) // ponding place-<br>&nbsp;&nbsp;&nbsp;&nbsp;throw();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ment delete<br>&nbsp;&nbsp;...<br>};<br></p>
<div class="note">
<h3 id="ch08note04">Things to Remember</h3>
<p class="indenthanding">• When you write a placement version of <code>operator new</code>, be sure to write the corresponding placement version of <code>operator delete</code>. If you don't, your program may experience subtle, intermittent memory leaks.</p>
<p class="indenthanding">• When you declare placement versions of <code>new</code> and <code>delete</code>, be sure not to unintentionally hide the normal versions of those functions.</p>
</div>
<div class="annotator-outer annotator-viewer viewer annotator-hide">
  <ul class="annotator-widget annotator-listing"></ul>
</div><div class="annotator-modal-wrapper annotator-editor-modal annotator-editor annotator-hide">
	<div class="annotator-outer editor">
		<h2 class="title">Highlight</h2>
		<form class="annotator-widget">
			<ul class="annotator-listing">
			<li class="annotator-item"><textarea id="annotator-field-0" placeholder="Add a note using markdown (optional)" class="js-editor" maxlength="750"></textarea></li></ul>
			<div class="annotator-controls">
				<a class="link-to-markdown" href="https://daringfireball.net/projects/markdown/basics" target="_blank">?</a>
				<ul>
					<li class="delete annotator-hide"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#delete" class="annotator-delete-note button positive">Delete Note</a></li>
					<li class="save"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#save" class="annotator-save annotator-focus button positive">Save Note</a></li>
					<li class="cancel"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#cancel" class="annotator-cancel button">Cancel</a></li>
				</ul>
			</div>
		</form>
	</div>
</div><div class="annotator-modal-wrapper annotator-delete-confirm-modal" style="display: none;">
  <div class="annotator-outer">
    <h2 class="title">Highlight</h2>
      <a class="js-close-delete-confirm annotator-cancel close" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#close">Close</a>
      <div class="annotator-widget">
         <div class="delete-confirm">
            Are you sure you want to permanently delete this note?
         </div>
         <div class="annotator-controls">
            <a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#cancel" class="annotator-cancel button js-cancel-delete-confirm">No, I changed my mind</a>
            <a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#delete" class="annotator-delete button positive js-delete-confirm">Yes, delete it</a>
         </div>
       </div>
   </div>
</div><div class="annotator-adder" style="display: none;">
	<ul class="adders ">
		
		<li class="copy"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#">Copy</a></li>
		
		<li class="add-highlight"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#">Add Highlight</a></li>
		<li class="add-note"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#">
			
				Add Note
			
		</a></li>
	</ul>
</div></div></div>



  <div class="t-sbo-prev sbo-prev sbo-nav-bottom">
  
    
      
        <a href="/Library/view/effective-c-55/0321334876/ch07.html" class="prev nav-link">
      
          <span aria-hidden="true" class="pagination-label t-prev-label">Prev</span>
          <span class="visuallyhidden">Previous Chapter</span>
          <div class="pagination-title t-prev-title">7. Templates and Generic Programming</div>
        </a>
    
  
  </div>

  <div class="t-sbo-next sbo-next sbo-nav-bottom">
  
    
      
        <a href="/Library/view/effective-c-55/0321334876/ch09.html" class="next nav-link">
      
          <span aria-hidden="true" class="pagination-label t-next-label">Next</span>
          <span class="visuallyhidden">Next Chapter</span>
          <div class="pagination-title t-next-title">9. Miscellany</div>
        </a>
    
  
  </div>


      
    </section>
    <div class="reading-controls-bottom">
      <ul class="interface-controls js-bitlist">
        <li class="queue-control">
            <button type="button" class="rec-fav ss-queue js-queue js-current-chapter-queue" data-queue-endpoint="/api/v1/book/0321334876/chapter/ch08.html" data-for-analytics="0321334876:ch08.html">
      <span>Add to Queue</span>
  </button>
        </li>
      </ul>
    </div>
  </div>
<section class="sbo-saved-archives"></section>



          
          
  





    
    



        
      </div>
      



  <footer class="pagefoot t-pagefoot">
    <a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#" class="icon-up"><div class="visuallyhidden">Back to top</div></a>
    <ul class="js-footer-nav">
      
        <li><a class="t-recommendations-footer" href="https://www.safaribooksonline.com/r/">Recommended</a></li>
      
      <li><a class="t-queue-footer" href="https://www.safaribooksonline.com/s/">Queue</a></li>
      
        <li><a class="t-recent-footer" href="https://www.safaribooksonline.com/history/">History</a></li>
        <li><a class="t-topics-footer" href="https://www.safaribooksonline.com/topics?q=*&amp;limit=21">Topics</a></li>
      
      
        <li><a class="t-tutorials-footer" href="https://www.safaribooksonline.com/tutorials/">Tutorials</a></li>
      
      <li><a class="t-settings-footer js-settings" href="https://www.safaribooksonline.com/u/">Settings</a></li>
      <li><a href="https://www.safaribooksonline.com/blog/">Blog</a></li>
      <li class="full-support"><a href="https://www.safaribooksonline.com/public/support">Support</a></li>
      <li><a href="https://community.safaribooksonline.com/">Feedback</a></li>
      <li><a href="https://www.safaribooksonline.com/apps/">Get the App</a></li>
      <li><a href="https://www.safaribooksonline.com/accounts/logout/">Sign Out</a></li>
    </ul>
    <span class="copyright">© 2016 <a href="https://www.safaribooksonline.com/" target="_blank">Safari</a>.</span>
    <a href="https://www.safaribooksonline.com/terms/">Terms of Service</a> /
    <a href="https://www.safaribooksonline.com/privacy/">Privacy Policy</a>
  </footer>




    

    
    
  

<div class="annotator-notice"></div><div class="font-flyout"><div class="font-controls-panel">
	<div class="nightmodes">
		<ul>
			<li class="day"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#" id="day-mode" title="Day Mode">
				<i class="fa fa-sun-o"></i>
				<span>Day Mode</span></a></li>
			<li class="cloudy"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#" id="cloudy-mode" title="Cloudy Mode">
				<i class="fa fa-cloud"></i>
				<span>Cloud Mode</span>
			</a></li>
			<li class="night"><a href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#" id="night-mode" title="Night Mode">
				<i class="fa fa-moon-o"></i>
				<span>Night Mode</span>
			</a></li>
		</ul>
	</div>

	<div class="font-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-font left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-font-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-font right"></i>
		</div>
	</div>

	<div class="column-resizer resizer">
		<div class="draggable-containment-wrapper">
			<i class="fa fa-compress left"></i>
			<span class="filler" style="width: 50%;"></span>
			<div id="js-column-size-draggable" class="draggable ui-widget-content ui-draggable ui-draggable-handle" style="position: relative; left: 80px;"></div>
			<i class="fa fa-expand right"></i>
		</div>
	</div>

	<a id="reset" class="button" href="https://www.safaribooksonline.com//library/view/effective-c-55/0321334876/ch08.html#">Reset</a>
</div>
</div></body><span class="gr__tooltip"><span class="gr__tooltip-content"></span><i class="gr__tooltip-logo"></i><span class="gr__triangle"></span></span></html>